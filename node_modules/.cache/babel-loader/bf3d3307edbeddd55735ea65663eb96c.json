{"ast":null,"code":"\"use strict\"; // Actual implementation of the Performance class.\n\nconst clockIsAccurate = require(\"./clock-is-accurate\");\n\nconst calculateClockOffset = require(\"./calculate-clock-offset\");\n\nconst {\n  hrtime,\n  toMS\n} = require(\"./utils\");\n\nconst kTimeOrigin = Symbol(\"time origin\");\nconst kTimeOriginTimestamp = Symbol(\"time origin timestamp\");\n\nclass Performance {\n  constructor() {\n    // Time origin.\n    const timeOrigin = hrtime();\n    this[kTimeOrigin] = timeOrigin;\n\n    if (clockIsAccurate) {\n      // Let |t1| be the DOMHighResTimeStamp representing the high resolution Unix time at which the global monotonic\n      // clock is zero. This has to be calculated for every Performance object to account for clock drifts.\n      const t1 = calculateClockOffset(); // Let |t2| be the DOMHighResTimeStamp representing the high resolution time value of the global monotonic clock\n      // at global's time origin.\n\n      const t2 = toMS(timeOrigin); // Return the sum of |t1| and |t2|.\n\n      this[kTimeOriginTimestamp] = t1 + t2;\n    } else {\n      // Clock isn't accurate enough. Use millisecond accuracy per spec.\n      const cur = Date.now();\n      this[kTimeOriginTimestamp] = cur;\n    }\n  } // The timeOrigin getter actually returns the time origin timestamp, not the raw time origin.\n\n\n  get timeOrigin() {\n    return this[kTimeOriginTimestamp];\n  }\n\n  now() {\n    const diff = toMS(hrtime(this[kTimeOrigin]));\n    return clockIsAccurate ? diff : Math.round(diff);\n  }\n\n  toJSON() {\n    return {\n      timeOrigin: this.timeOrigin\n    };\n  }\n\n}\n\nmodule.exports = {\n  Performance\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/w3c-hr-time/lib/performance.js"],"names":["clockIsAccurate","require","calculateClockOffset","hrtime","toMS","kTimeOrigin","Symbol","kTimeOriginTimestamp","Performance","constructor","timeOrigin","t1","t2","cur","Date","now","diff","Math","round","toJSON","module","exports"],"mappings":"AAAA,a,CAEA;;AAEA,MAAMA,eAAe,GAAGC,OAAO,CAAC,qBAAD,CAA/B;;AACA,MAAMC,oBAAoB,GAAGD,OAAO,CAAC,0BAAD,CAApC;;AACA,MAAM;AAAEE,EAAAA,MAAF;AAAUC,EAAAA;AAAV,IAAmBH,OAAO,CAAC,SAAD,CAAhC;;AAEA,MAAMI,WAAW,GAAGC,MAAM,CAAC,aAAD,CAA1B;AACA,MAAMC,oBAAoB,GAAGD,MAAM,CAAC,uBAAD,CAAnC;;AAEA,MAAME,WAAN,CAAkB;AAChBC,EAAAA,WAAW,GAAG;AACZ;AACA,UAAMC,UAAU,GAAGP,MAAM,EAAzB;AACA,SAAKE,WAAL,IAAoBK,UAApB;;AAEA,QAAIV,eAAJ,EAAqB;AACnB;AACA;AACA,YAAMW,EAAE,GAAGT,oBAAoB,EAA/B,CAHmB,CAKnB;AACA;;AACA,YAAMU,EAAE,GAAGR,IAAI,CAACM,UAAD,CAAf,CAPmB,CASnB;;AACA,WAAKH,oBAAL,IAA6BI,EAAE,GAAGC,EAAlC;AACD,KAXD,MAWO;AACL;AACA,YAAMC,GAAG,GAAGC,IAAI,CAACC,GAAL,EAAZ;AACA,WAAKR,oBAAL,IAA6BM,GAA7B;AACD;AACF,GAtBe,CAwBhB;;;AACc,MAAVH,UAAU,GAAG;AACf,WAAO,KAAKH,oBAAL,CAAP;AACD;;AAEDQ,EAAAA,GAAG,GAAG;AACJ,UAAMC,IAAI,GAAGZ,IAAI,CAACD,MAAM,CAAC,KAAKE,WAAL,CAAD,CAAP,CAAjB;AACA,WAAOL,eAAe,GAAGgB,IAAH,GAAUC,IAAI,CAACC,KAAL,CAAWF,IAAX,CAAhC;AACD;;AAEDG,EAAAA,MAAM,GAAG;AACP,WAAO;AACLT,MAAAA,UAAU,EAAE,KAAKA;AADZ,KAAP;AAGD;;AAtCe;;AAyClBU,MAAM,CAACC,OAAP,GAAiB;AAAEb,EAAAA;AAAF,CAAjB","sourcesContent":["\"use strict\";\n\n// Actual implementation of the Performance class.\n\nconst clockIsAccurate = require(\"./clock-is-accurate\");\nconst calculateClockOffset = require(\"./calculate-clock-offset\");\nconst { hrtime, toMS } = require(\"./utils\");\n\nconst kTimeOrigin = Symbol(\"time origin\");\nconst kTimeOriginTimestamp = Symbol(\"time origin timestamp\");\n\nclass Performance {\n  constructor() {\n    // Time origin.\n    const timeOrigin = hrtime();\n    this[kTimeOrigin] = timeOrigin;\n\n    if (clockIsAccurate) {\n      // Let |t1| be the DOMHighResTimeStamp representing the high resolution Unix time at which the global monotonic\n      // clock is zero. This has to be calculated for every Performance object to account for clock drifts.\n      const t1 = calculateClockOffset();\n\n      // Let |t2| be the DOMHighResTimeStamp representing the high resolution time value of the global monotonic clock\n      // at global's time origin.\n      const t2 = toMS(timeOrigin);\n\n      // Return the sum of |t1| and |t2|.\n      this[kTimeOriginTimestamp] = t1 + t2;\n    } else {\n      // Clock isn't accurate enough. Use millisecond accuracy per spec.\n      const cur = Date.now();\n      this[kTimeOriginTimestamp] = cur;\n    }\n  }\n\n  // The timeOrigin getter actually returns the time origin timestamp, not the raw time origin.\n  get timeOrigin() {\n    return this[kTimeOriginTimestamp];\n  }\n\n  now() {\n    const diff = toMS(hrtime(this[kTimeOrigin]));\n    return clockIsAccurate ? diff : Math.round(diff);\n  }\n\n  toJSON() {\n    return {\n      timeOrigin: this.timeOrigin\n    };\n  }\n}\n\nmodule.exports = { Performance };\n"]},"metadata":{},"sourceType":"script"}