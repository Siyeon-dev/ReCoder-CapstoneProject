{"ast":null,"code":"\"use strict\";\n\nconst {\n  wrapperForImpl\n} = require(\"../generated/utils\"); // If we were to implement the MutationObserver by spec, the MutationObservers will not be collected by the GC because\n// all the MO are kept in a mutation observer list (https://github.com/jsdom/jsdom/pull/2398/files#r238123889). The\n// mutation observer list is primarily used to invoke the mutation observer callback in the same order than the\n// mutation observer creation.\n// In order to get around this issue, we will assign an increasing id for each mutation observer, this way we would be\n// able to invoke the callback in the creation order without having to keep a list of all the mutation observers.\n\n\nlet mutationObserverId = 0; // https://dom.spec.whatwg.org/#mutationobserver\n\nclass MutationObserverImpl {\n  // https://dom.spec.whatwg.org/#dom-mutationobserver-mutationobserver\n  constructor(globalObject, args) {\n    const [callback] = args;\n    this._callback = callback;\n    this._nodeList = [];\n    this._recordQueue = [];\n    this._id = ++mutationObserverId;\n  } // https://dom.spec.whatwg.org/#dom-mutationobserver-observe\n\n\n  observe(target, options) {\n    if ((\"attributeOldValue\" in options || \"attributeFilter\" in options) && !(\"attributes\" in options)) {\n      options.attributes = true;\n    }\n\n    if (\"characterDataOldValue\" in options & !(\"characterData\" in options)) {\n      options.characterData = true;\n    }\n\n    if (!options.childList && !options.attributes && !options.characterData) {\n      throw new TypeError(\"The options object must set at least one of 'attributes', 'characterData', or 'childList' \" + \"to true.\");\n    } else if (options.attributeOldValue && !options.attributes) {\n      throw new TypeError(\"The options object may only set 'attributeOldValue' to true when 'attributes' is true or \" + \"not present.\");\n    } else if (\"attributeFilter\" in options && !options.attributes) {\n      throw new TypeError(\"The options object may only set 'attributeFilter' when 'attributes' is true or not \" + \"present.\");\n    } else if (options.characterDataOldValue && !options.characterData) {\n      throw new TypeError(\"The options object may only set 'characterDataOldValue' to true when 'characterData' is \" + \"true or not present.\");\n    }\n\n    const existingRegisteredObserver = target._registeredObserverList.find(registeredObserver => {\n      return registeredObserver.observer === this;\n    });\n\n    if (existingRegisteredObserver) {\n      for (const node of this._nodeList) {\n        node._registeredObserverList = node._registeredObserverList.filter(registeredObserver => {\n          return registeredObserver.source !== existingRegisteredObserver;\n        });\n      }\n\n      existingRegisteredObserver.options = options;\n    } else {\n      target._registeredObserverList.push({\n        observer: this,\n        options\n      });\n\n      this._nodeList.push(target);\n    }\n  } // https://dom.spec.whatwg.org/#dom-mutationobserver-disconnect\n\n\n  disconnect() {\n    for (const node of this._nodeList) {\n      node._registeredObserverList = node._registeredObserverList.filter(registeredObserver => {\n        return registeredObserver.observer !== this;\n      });\n    }\n\n    this._recordQueue = [];\n  } // https://dom.spec.whatwg.org/#dom-mutationobserver-takerecords\n\n\n  takeRecords() {\n    // TODO: revisit if https://github.com/jsdom/webidl2js/pull/108 gets fixed.\n    const records = this._recordQueue.map(wrapperForImpl);\n\n    this._recordQueue = [];\n    return records;\n  }\n\n}\n\nmodule.exports = {\n  implementation: MutationObserverImpl\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/jsdom/lib/jsdom/living/mutation-observer/MutationObserver-impl.js"],"names":["wrapperForImpl","require","mutationObserverId","MutationObserverImpl","constructor","globalObject","args","callback","_callback","_nodeList","_recordQueue","_id","observe","target","options","attributes","characterData","childList","TypeError","attributeOldValue","characterDataOldValue","existingRegisteredObserver","_registeredObserverList","find","registeredObserver","observer","node","filter","source","push","disconnect","takeRecords","records","map","module","exports","implementation"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst { wrapperForImpl } = require(\"../generated/utils\");\n\n// If we were to implement the MutationObserver by spec, the MutationObservers will not be collected by the GC because\n// all the MO are kept in a mutation observer list (https://github.com/jsdom/jsdom/pull/2398/files#r238123889). The\n// mutation observer list is primarily used to invoke the mutation observer callback in the same order than the\n// mutation observer creation.\n// In order to get around this issue, we will assign an increasing id for each mutation observer, this way we would be\n// able to invoke the callback in the creation order without having to keep a list of all the mutation observers.\nlet mutationObserverId = 0;\n\n// https://dom.spec.whatwg.org/#mutationobserver\nclass MutationObserverImpl {\n  // https://dom.spec.whatwg.org/#dom-mutationobserver-mutationobserver\n  constructor(globalObject, args) {\n    const [callback] = args;\n\n    this._callback = callback;\n    this._nodeList = [];\n    this._recordQueue = [];\n\n    this._id = ++mutationObserverId;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-mutationobserver-observe\n  observe(target, options) {\n    if ((\"attributeOldValue\" in options || \"attributeFilter\" in options) && !(\"attributes\" in options)) {\n      options.attributes = true;\n    }\n\n    if (\"characterDataOldValue\" in options & !(\"characterData\" in options)) {\n      options.characterData = true;\n    }\n\n    if (!options.childList && !options.attributes && !options.characterData) {\n      throw new TypeError(\"The options object must set at least one of 'attributes', 'characterData', or 'childList' \" +\n        \"to true.\");\n    } else if (options.attributeOldValue && !options.attributes) {\n      throw new TypeError(\"The options object may only set 'attributeOldValue' to true when 'attributes' is true or \" +\n        \"not present.\");\n    } else if ((\"attributeFilter\" in options) && !options.attributes) {\n      throw new TypeError(\"The options object may only set 'attributeFilter' when 'attributes' is true or not \" +\n        \"present.\");\n    } else if (options.characterDataOldValue && !options.characterData) {\n      throw new TypeError(\"The options object may only set 'characterDataOldValue' to true when 'characterData' is \" +\n        \"true or not present.\");\n    }\n\n    const existingRegisteredObserver = target._registeredObserverList.find(registeredObserver => {\n      return registeredObserver.observer === this;\n    });\n\n    if (existingRegisteredObserver) {\n      for (const node of this._nodeList) {\n        node._registeredObserverList = node._registeredObserverList.filter(registeredObserver => {\n          return registeredObserver.source !== existingRegisteredObserver;\n        });\n      }\n\n      existingRegisteredObserver.options = options;\n    } else {\n      target._registeredObserverList.push({\n        observer: this,\n        options\n      });\n\n      this._nodeList.push(target);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-mutationobserver-disconnect\n  disconnect() {\n    for (const node of this._nodeList) {\n      node._registeredObserverList = node._registeredObserverList.filter(registeredObserver => {\n        return registeredObserver.observer !== this;\n      });\n    }\n\n    this._recordQueue = [];\n  }\n\n  // https://dom.spec.whatwg.org/#dom-mutationobserver-takerecords\n  takeRecords() {\n    // TODO: revisit if https://github.com/jsdom/webidl2js/pull/108 gets fixed.\n    const records = this._recordQueue.map(wrapperForImpl);\n    this._recordQueue = [];\n\n    return records;\n  }\n}\n\nmodule.exports = {\n  implementation: MutationObserverImpl\n};\n"]},"metadata":{},"sourceType":"script"}