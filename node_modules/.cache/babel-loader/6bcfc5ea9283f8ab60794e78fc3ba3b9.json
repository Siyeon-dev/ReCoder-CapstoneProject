{"ast":null,"code":"\"use strict\";\n\nconst {\n  mixin\n} = require(\"../../utils\");\n\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst NodeImpl = require(\"./Node-impl\").implementation;\n\nconst NonElementParentNodeImpl = require(\"./NonElementParentNode-impl\").implementation;\n\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\n\nconst idlUtils = require(\"../generated/utils\");\n\nclass DocumentFragmentImpl extends NodeImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, {\n      ownerDocument: idlUtils.implForWrapper(globalObject._document),\n      ...privateData\n    });\n    const {\n      host\n    } = privateData;\n    this._host = host;\n    this.nodeType = NODE_TYPE.DOCUMENT_FRAGMENT_NODE;\n  } // This is implemented separately for Document (which has a _ids cache) and DocumentFragment (which does not).\n\n\n  getElementById(id) {\n    if (id === \"\") {\n      return null;\n    }\n\n    for (const descendant of domSymbolTree.treeIterator(this)) {\n      if (descendant.nodeType === NODE_TYPE.ELEMENT_NODE && descendant.getAttributeNS(null, \"id\") === id) {\n        return descendant;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nmixin(DocumentFragmentImpl.prototype, NonElementParentNodeImpl.prototype);\nmixin(DocumentFragmentImpl.prototype, ParentNodeImpl.prototype);\nmodule.exports = {\n  implementation: DocumentFragmentImpl\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/jsdom/lib/jsdom/living/nodes/DocumentFragment-impl.js"],"names":["mixin","require","domSymbolTree","NODE_TYPE","NodeImpl","implementation","NonElementParentNodeImpl","ParentNodeImpl","idlUtils","DocumentFragmentImpl","constructor","globalObject","args","privateData","ownerDocument","implForWrapper","_document","host","_host","nodeType","DOCUMENT_FRAGMENT_NODE","getElementById","id","descendant","treeIterator","ELEMENT_NODE","getAttributeNS","prototype","module","exports"],"mappings":"AAAA;;AACA,MAAM;AAAEA,EAAAA;AAAF,IAAYC,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAoBD,OAAO,CAAC,+BAAD,CAAjC;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,aAAD,CAAP,CAAuBI,cAAxC;;AACA,MAAMC,wBAAwB,GAAGL,OAAO,CAAC,6BAAD,CAAP,CAAuCI,cAAxE;;AACA,MAAME,cAAc,GAAGN,OAAO,CAAC,mBAAD,CAAP,CAA6BI,cAApD;;AACA,MAAMG,QAAQ,GAAGP,OAAO,CAAC,oBAAD,CAAxB;;AAEA,MAAMQ,oBAAN,SAAmCL,QAAnC,CAA4C;AAC1CM,EAAAA,WAAW,CAACC,YAAD,EAAeC,IAAf,EAAqBC,WAArB,EAAkC;AAC3C,UAAMF,YAAN,EAAoBC,IAApB,EAA0B;AACxBE,MAAAA,aAAa,EAAEN,QAAQ,CAACO,cAAT,CAAwBJ,YAAY,CAACK,SAArC,CADS;AAExB,SAAGH;AAFqB,KAA1B;AAKA,UAAM;AAAEI,MAAAA;AAAF,QAAWJ,WAAjB;AACA,SAAKK,KAAL,GAAaD,IAAb;AAEA,SAAKE,QAAL,GAAgBhB,SAAS,CAACiB,sBAA1B;AACD,GAXyC,CAa1C;;;AACAC,EAAAA,cAAc,CAACC,EAAD,EAAK;AACjB,QAAIA,EAAE,KAAK,EAAX,EAAe;AACb,aAAO,IAAP;AACD;;AAED,SAAK,MAAMC,UAAX,IAAyBrB,aAAa,CAACsB,YAAd,CAA2B,IAA3B,CAAzB,EAA2D;AACzD,UAAID,UAAU,CAACJ,QAAX,KAAwBhB,SAAS,CAACsB,YAAlC,IAAkDF,UAAU,CAACG,cAAX,CAA0B,IAA1B,EAAgC,IAAhC,MAA0CJ,EAAhG,EAAoG;AAClG,eAAOC,UAAP;AACD;AACF;;AAED,WAAO,IAAP;AACD;;AA1ByC;;AA6B5CvB,KAAK,CAACS,oBAAoB,CAACkB,SAAtB,EAAiCrB,wBAAwB,CAACqB,SAA1D,CAAL;AACA3B,KAAK,CAACS,oBAAoB,CAACkB,SAAtB,EAAiCpB,cAAc,CAACoB,SAAhD,CAAL;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACfxB,EAAAA,cAAc,EAAEI;AADD,CAAjB","sourcesContent":["\"use strict\";\nconst { mixin } = require(\"../../utils\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst NODE_TYPE = require(\"../node-type\");\nconst NodeImpl = require(\"./Node-impl\").implementation;\nconst NonElementParentNodeImpl = require(\"./NonElementParentNode-impl\").implementation;\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\n\nclass DocumentFragmentImpl extends NodeImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, {\n      ownerDocument: idlUtils.implForWrapper(globalObject._document),\n      ...privateData\n    });\n\n    const { host } = privateData;\n    this._host = host;\n\n    this.nodeType = NODE_TYPE.DOCUMENT_FRAGMENT_NODE;\n  }\n\n  // This is implemented separately for Document (which has a _ids cache) and DocumentFragment (which does not).\n  getElementById(id) {\n    if (id === \"\") {\n      return null;\n    }\n\n    for (const descendant of domSymbolTree.treeIterator(this)) {\n      if (descendant.nodeType === NODE_TYPE.ELEMENT_NODE && descendant.getAttributeNS(null, \"id\") === id) {\n        return descendant;\n      }\n    }\n\n    return null;\n  }\n}\n\nmixin(DocumentFragmentImpl.prototype, NonElementParentNodeImpl.prototype);\nmixin(DocumentFragmentImpl.prototype, ParentNodeImpl.prototype);\n\nmodule.exports = {\n  implementation: DocumentFragmentImpl\n};\n"]},"metadata":{},"sourceType":"script"}