{"ast":null,"code":"'use strict';\n\nvar acorn = require('acorn');\n\nvar walk = require('acorn-walk');\n\nfunction isScope(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'ArrowFunctionExpression' || node.type === 'Program';\n}\n\nfunction isBlockScope(node) {\n  return node.type === 'BlockStatement' || isScope(node);\n}\n\nfunction declaresArguments(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n\nfunction declaresThis(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n\nfunction reallyParse(source, options) {\n  var parseOptions = Object.assign({}, options, {\n    allowReturnOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowHashBang: true\n  });\n  return acorn.parse(source, parseOptions);\n}\n\nmodule.exports = findGlobals;\nmodule.exports.parse = reallyParse;\n\nfunction findGlobals(source, options) {\n  options = options || {};\n  var globals = [];\n  var ast; // istanbul ignore else\n\n  if (typeof source === 'string') {\n    ast = reallyParse(source, options);\n  } else {\n    ast = source;\n  } // istanbul ignore if\n\n\n  if (!(ast && typeof ast === 'object' && ast.type === 'Program')) {\n    throw new TypeError('Source must be either a string of JavaScript or an acorn AST');\n  }\n\n  var declareFunction = function (node) {\n    var fn = node;\n    fn.locals = fn.locals || Object.create(null);\n    node.params.forEach(function (node) {\n      declarePattern(node, fn);\n    });\n\n    if (node.id) {\n      fn.locals[node.id.name] = true;\n    }\n  };\n\n  var declareClass = function (node) {\n    node.locals = node.locals || Object.create(null);\n\n    if (node.id) {\n      node.locals[node.id.name] = true;\n    }\n  };\n\n  var declarePattern = function (node, parent) {\n    switch (node.type) {\n      case 'Identifier':\n        parent.locals[node.name] = true;\n        break;\n\n      case 'ObjectPattern':\n        node.properties.forEach(function (node) {\n          declarePattern(node.value || node.argument, parent);\n        });\n        break;\n\n      case 'ArrayPattern':\n        node.elements.forEach(function (node) {\n          if (node) declarePattern(node, parent);\n        });\n        break;\n\n      case 'RestElement':\n        declarePattern(node.argument, parent);\n        break;\n\n      case 'AssignmentPattern':\n        declarePattern(node.left, parent);\n        break;\n      // istanbul ignore next\n\n      default:\n        throw new Error('Unrecognized pattern type: ' + node.type);\n    }\n  };\n\n  var declareModuleSpecifier = function (node, parents) {\n    ast.locals = ast.locals || Object.create(null);\n    ast.locals[node.local.name] = true;\n  };\n\n  walk.ancestor(ast, {\n    'VariableDeclaration': function (node, parents) {\n      var parent = null;\n\n      for (var i = parents.length - 1; i >= 0 && parent === null; i--) {\n        if (node.kind === 'var' ? isScope(parents[i]) : isBlockScope(parents[i])) {\n          parent = parents[i];\n        }\n      }\n\n      parent.locals = parent.locals || Object.create(null);\n      node.declarations.forEach(function (declaration) {\n        declarePattern(declaration.id, parent);\n      });\n    },\n    'FunctionDeclaration': function (node, parents) {\n      var parent = null;\n\n      for (var i = parents.length - 2; i >= 0 && parent === null; i--) {\n        if (isScope(parents[i])) {\n          parent = parents[i];\n        }\n      }\n\n      parent.locals = parent.locals || Object.create(null);\n\n      if (node.id) {\n        parent.locals[node.id.name] = true;\n      }\n\n      declareFunction(node);\n    },\n    'Function': declareFunction,\n    'ClassDeclaration': function (node, parents) {\n      var parent = null;\n\n      for (var i = parents.length - 2; i >= 0 && parent === null; i--) {\n        if (isBlockScope(parents[i])) {\n          parent = parents[i];\n        }\n      }\n\n      parent.locals = parent.locals || Object.create(null);\n\n      if (node.id) {\n        parent.locals[node.id.name] = true;\n      }\n\n      declareClass(node);\n    },\n    'Class': declareClass,\n    'TryStatement': function (node) {\n      if (node.handler === null) return;\n      node.handler.locals = node.handler.locals || Object.create(null);\n      declarePattern(node.handler.param, node.handler);\n    },\n    'ImportDefaultSpecifier': declareModuleSpecifier,\n    'ImportSpecifier': declareModuleSpecifier,\n    'ImportNamespaceSpecifier': declareModuleSpecifier\n  });\n\n  function identifier(node, parents) {\n    var name = node.name;\n    if (name === 'undefined') return;\n\n    for (var i = 0; i < parents.length; i++) {\n      if (name === 'arguments' && declaresArguments(parents[i])) {\n        return;\n      }\n\n      if (parents[i].locals && name in parents[i].locals) {\n        return;\n      }\n    }\n\n    node.parents = parents.slice();\n    globals.push(node);\n  }\n\n  walk.ancestor(ast, {\n    'VariablePattern': identifier,\n    'Identifier': identifier,\n    'ThisExpression': function (node, parents) {\n      for (var i = 0; i < parents.length; i++) {\n        if (declaresThis(parents[i])) {\n          return;\n        }\n      }\n\n      node.parents = parents.slice();\n      globals.push(node);\n    }\n  });\n  var groupedGlobals = Object.create(null);\n  globals.forEach(function (node) {\n    var name = node.type === 'ThisExpression' ? 'this' : node.name;\n    groupedGlobals[name] = groupedGlobals[name] || [];\n    groupedGlobals[name].push(node);\n  });\n  return Object.keys(groupedGlobals).sort().map(function (name) {\n    return {\n      name: name,\n      nodes: groupedGlobals[name]\n    };\n  });\n}","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/acorn-globals/index.js"],"names":["acorn","require","walk","isScope","node","type","isBlockScope","declaresArguments","declaresThis","reallyParse","source","options","parseOptions","Object","assign","allowReturnOutsideFunction","allowImportExportEverywhere","allowHashBang","parse","module","exports","findGlobals","globals","ast","TypeError","declareFunction","fn","locals","create","params","forEach","declarePattern","id","name","declareClass","parent","properties","value","argument","elements","left","Error","declareModuleSpecifier","parents","local","ancestor","i","length","kind","declarations","declaration","handler","param","identifier","slice","push","groupedGlobals","keys","sort","map","nodes"],"mappings":"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","sourcesContent":["'use strict';\n\nvar acorn = require('acorn');\nvar walk = require('acorn-walk');\n\nfunction isScope(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'ArrowFunctionExpression' || node.type === 'Program';\n}\nfunction isBlockScope(node) {\n  return node.type === 'BlockStatement' || isScope(node);\n}\n\nfunction declaresArguments(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n\nfunction declaresThis(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n\nfunction reallyParse(source, options) {\n  var parseOptions = Object.assign({}, options,\n    {\n      allowReturnOutsideFunction: true,\n      allowImportExportEverywhere: true,\n      allowHashBang: true\n    }\n  );\n  return acorn.parse(source, parseOptions);\n}\nmodule.exports = findGlobals;\nmodule.exports.parse = reallyParse;\nfunction findGlobals(source, options) {\n  options = options || {};\n  var globals = [];\n  var ast;\n  // istanbul ignore else\n  if (typeof source === 'string') {\n    ast = reallyParse(source, options);\n  } else {\n    ast = source;\n  }\n  // istanbul ignore if\n  if (!(ast && typeof ast === 'object' && ast.type === 'Program')) {\n    throw new TypeError('Source must be either a string of JavaScript or an acorn AST');\n  }\n  var declareFunction = function (node) {\n    var fn = node;\n    fn.locals = fn.locals || Object.create(null);\n    node.params.forEach(function (node) {\n      declarePattern(node, fn);\n    });\n    if (node.id) {\n      fn.locals[node.id.name] = true;\n    }\n  };\n  var declareClass = function (node) {\n    node.locals = node.locals || Object.create(null);\n    if (node.id) {\n      node.locals[node.id.name] = true;\n    }\n  };\n  var declarePattern = function (node, parent) {\n    switch (node.type) {\n      case 'Identifier':\n        parent.locals[node.name] = true;\n        break;\n      case 'ObjectPattern':\n        node.properties.forEach(function (node) {\n          declarePattern(node.value || node.argument, parent);\n        });\n        break;\n      case 'ArrayPattern':\n        node.elements.forEach(function (node) {\n          if (node) declarePattern(node, parent);\n        });\n        break;\n      case 'RestElement':\n        declarePattern(node.argument, parent);\n        break;\n      case 'AssignmentPattern':\n        declarePattern(node.left, parent);\n        break;\n      // istanbul ignore next\n      default:\n        throw new Error('Unrecognized pattern type: ' + node.type);\n    }\n  };\n  var declareModuleSpecifier = function (node, parents) {\n    ast.locals = ast.locals || Object.create(null);\n    ast.locals[node.local.name] = true;\n  };\n  walk.ancestor(ast, {\n    'VariableDeclaration': function (node, parents) {\n      var parent = null;\n      for (var i = parents.length - 1; i >= 0 && parent === null; i--) {\n        if (node.kind === 'var' ? isScope(parents[i]) : isBlockScope(parents[i])) {\n          parent = parents[i];\n        }\n      }\n      parent.locals = parent.locals || Object.create(null);\n      node.declarations.forEach(function (declaration) {\n        declarePattern(declaration.id, parent);\n      });\n    },\n    'FunctionDeclaration': function (node, parents) {\n      var parent = null;\n      for (var i = parents.length - 2; i >= 0 && parent === null; i--) {\n        if (isScope(parents[i])) {\n          parent = parents[i];\n        }\n      }\n      parent.locals = parent.locals || Object.create(null);\n      if (node.id) {\n        parent.locals[node.id.name] = true;\n      }\n      declareFunction(node);\n    },\n    'Function': declareFunction,\n    'ClassDeclaration': function (node, parents) {\n      var parent = null;\n      for (var i = parents.length - 2; i >= 0 && parent === null; i--) {\n        if (isBlockScope(parents[i])) {\n          parent = parents[i];\n        }\n      }\n      parent.locals = parent.locals || Object.create(null);\n      if (node.id) {\n        parent.locals[node.id.name] = true;\n      }\n      declareClass(node);\n    },\n    'Class': declareClass,\n    'TryStatement': function (node) {\n      if (node.handler === null) return;\n      node.handler.locals = node.handler.locals || Object.create(null);\n      declarePattern(node.handler.param, node.handler);\n    },\n    'ImportDefaultSpecifier': declareModuleSpecifier,\n    'ImportSpecifier': declareModuleSpecifier,\n    'ImportNamespaceSpecifier': declareModuleSpecifier\n  });\n  function identifier(node, parents) {\n    var name = node.name;\n    if (name === 'undefined') return;\n    for (var i = 0; i < parents.length; i++) {\n      if (name === 'arguments' && declaresArguments(parents[i])) {\n        return;\n      }\n      if (parents[i].locals && name in parents[i].locals) {\n        return;\n      }\n    }\n    node.parents = parents.slice();\n    globals.push(node);\n  }\n  walk.ancestor(ast, {\n    'VariablePattern': identifier,\n    'Identifier': identifier,\n    'ThisExpression': function (node, parents) {\n      for (var i = 0; i < parents.length; i++) {\n        if (declaresThis(parents[i])) {\n          return;\n        }\n      }\n      node.parents = parents.slice();\n      globals.push(node);\n    }\n  });\n  var groupedGlobals = Object.create(null);\n  globals.forEach(function (node) {\n    var name = node.type === 'ThisExpression' ? 'this' : node.name;\n    groupedGlobals[name] = (groupedGlobals[name] || []);\n    groupedGlobals[name].push(node);\n  });\n  return Object.keys(groupedGlobals).sort().map(function (name) {\n    return {name: name, nodes: groupedGlobals[name]};\n  });\n}\n"]},"metadata":{},"sourceType":"script"}