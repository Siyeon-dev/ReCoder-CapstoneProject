{"ast":null,"code":"\"use strict\";\n\nconst MIMEType = require(\"whatwg-mimetype\");\n\nconst {\n  parseURL,\n  serializeURL\n} = require(\"whatwg-url\");\n\nconst {\n  stripLeadingAndTrailingASCIIWhitespace,\n  stringPercentDecode,\n  isomorphicDecode,\n  forgivingBase64Decode\n} = require(\"./utils.js\");\n\nmodule.exports = stringInput => {\n  const urlRecord = parseURL(stringInput);\n\n  if (urlRecord === null) {\n    return null;\n  }\n\n  return module.exports.fromURLRecord(urlRecord);\n};\n\nmodule.exports.fromURLRecord = urlRecord => {\n  if (urlRecord.scheme !== \"data\") {\n    return null;\n  }\n\n  const input = serializeURL(urlRecord, true).substring(\"data:\".length);\n  let position = 0;\n  let mimeType = \"\";\n\n  while (position < input.length && input[position] !== \",\") {\n    mimeType += input[position];\n    ++position;\n  }\n\n  mimeType = stripLeadingAndTrailingASCIIWhitespace(mimeType);\n\n  if (position === input.length) {\n    return null;\n  }\n\n  ++position;\n  const encodedBody = input.substring(position);\n  let body = stringPercentDecode(encodedBody); // Can't use /i regexp flag because it isn't restricted to ASCII.\n\n  const mimeTypeBase64MatchResult = /(.*); *[Bb][Aa][Ss][Ee]64$/.exec(mimeType);\n\n  if (mimeTypeBase64MatchResult) {\n    const stringBody = isomorphicDecode(body);\n    body = forgivingBase64Decode(stringBody);\n\n    if (body === null) {\n      return null;\n    }\n\n    mimeType = mimeTypeBase64MatchResult[1];\n  }\n\n  if (mimeType.startsWith(\";\")) {\n    mimeType = \"text/plain\" + mimeType;\n  }\n\n  let mimeTypeRecord;\n\n  try {\n    mimeTypeRecord = new MIMEType(mimeType);\n  } catch (e) {\n    mimeTypeRecord = new MIMEType(\"text/plain;charset=US-ASCII\");\n  }\n\n  return {\n    mimeType: mimeTypeRecord,\n    body\n  };\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/data-urls/lib/parser.js"],"names":["MIMEType","require","parseURL","serializeURL","stripLeadingAndTrailingASCIIWhitespace","stringPercentDecode","isomorphicDecode","forgivingBase64Decode","module","exports","stringInput","urlRecord","fromURLRecord","scheme","input","substring","length","position","mimeType","encodedBody","body","mimeTypeBase64MatchResult","exec","stringBody","startsWith","mimeTypeRecord","e"],"mappings":"AAAA;;AACA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,iBAAD,CAAxB;;AACA,MAAM;AAAEC,EAAAA,QAAF;AAAYC,EAAAA;AAAZ,IAA6BF,OAAO,CAAC,YAAD,CAA1C;;AACA,MAAM;AACJG,EAAAA,sCADI;AAEJC,EAAAA,mBAFI;AAGJC,EAAAA,gBAHI;AAIJC,EAAAA;AAJI,IAKFN,OAAO,CAAC,YAAD,CALX;;AAOAO,MAAM,CAACC,OAAP,GAAiBC,WAAW,IAAI;AAC9B,QAAMC,SAAS,GAAGT,QAAQ,CAACQ,WAAD,CAA1B;;AAEA,MAAIC,SAAS,KAAK,IAAlB,EAAwB;AACtB,WAAO,IAAP;AACD;;AAED,SAAOH,MAAM,CAACC,OAAP,CAAeG,aAAf,CAA6BD,SAA7B,CAAP;AACD,CARD;;AAUAH,MAAM,CAACC,OAAP,CAAeG,aAAf,GAA+BD,SAAS,IAAI;AAC1C,MAAIA,SAAS,CAACE,MAAV,KAAqB,MAAzB,EAAiC;AAC/B,WAAO,IAAP;AACD;;AAED,QAAMC,KAAK,GAAGX,YAAY,CAACQ,SAAD,EAAY,IAAZ,CAAZ,CAA8BI,SAA9B,CAAwC,QAAQC,MAAhD,CAAd;AAEA,MAAIC,QAAQ,GAAG,CAAf;AAEA,MAAIC,QAAQ,GAAG,EAAf;;AACA,SAAOD,QAAQ,GAAGH,KAAK,CAACE,MAAjB,IAA2BF,KAAK,CAACG,QAAD,CAAL,KAAoB,GAAtD,EAA2D;AACzDC,IAAAA,QAAQ,IAAIJ,KAAK,CAACG,QAAD,CAAjB;AACA,MAAEA,QAAF;AACD;;AACDC,EAAAA,QAAQ,GAAGd,sCAAsC,CAACc,QAAD,CAAjD;;AAEA,MAAID,QAAQ,KAAKH,KAAK,CAACE,MAAvB,EAA+B;AAC7B,WAAO,IAAP;AACD;;AAED,IAAEC,QAAF;AAEA,QAAME,WAAW,GAAGL,KAAK,CAACC,SAAN,CAAgBE,QAAhB,CAApB;AAEA,MAAIG,IAAI,GAAGf,mBAAmB,CAACc,WAAD,CAA9B,CAxB0C,CA0B1C;;AACA,QAAME,yBAAyB,GAAG,6BAA6BC,IAA7B,CAAkCJ,QAAlC,CAAlC;;AACA,MAAIG,yBAAJ,EAA+B;AAC7B,UAAME,UAAU,GAAGjB,gBAAgB,CAACc,IAAD,CAAnC;AACAA,IAAAA,IAAI,GAAGb,qBAAqB,CAACgB,UAAD,CAA5B;;AAEA,QAAIH,IAAI,KAAK,IAAb,EAAmB;AACjB,aAAO,IAAP;AACD;;AACDF,IAAAA,QAAQ,GAAGG,yBAAyB,CAAC,CAAD,CAApC;AACD;;AAED,MAAIH,QAAQ,CAACM,UAAT,CAAoB,GAApB,CAAJ,EAA8B;AAC5BN,IAAAA,QAAQ,GAAG,eAAeA,QAA1B;AACD;;AAED,MAAIO,cAAJ;;AACA,MAAI;AACFA,IAAAA,cAAc,GAAG,IAAIzB,QAAJ,CAAakB,QAAb,CAAjB;AACD,GAFD,CAEE,OAAOQ,CAAP,EAAU;AACVD,IAAAA,cAAc,GAAG,IAAIzB,QAAJ,CAAa,6BAAb,CAAjB;AACD;;AAED,SAAO;AACLkB,IAAAA,QAAQ,EAAEO,cADL;AAELL,IAAAA;AAFK,GAAP;AAID,CArDD","sourcesContent":["\"use strict\";\nconst MIMEType = require(\"whatwg-mimetype\");\nconst { parseURL, serializeURL } = require(\"whatwg-url\");\nconst {\n  stripLeadingAndTrailingASCIIWhitespace,\n  stringPercentDecode,\n  isomorphicDecode,\n  forgivingBase64Decode\n} = require(\"./utils.js\");\n\nmodule.exports = stringInput => {\n  const urlRecord = parseURL(stringInput);\n\n  if (urlRecord === null) {\n    return null;\n  }\n\n  return module.exports.fromURLRecord(urlRecord);\n};\n\nmodule.exports.fromURLRecord = urlRecord => {\n  if (urlRecord.scheme !== \"data\") {\n    return null;\n  }\n\n  const input = serializeURL(urlRecord, true).substring(\"data:\".length);\n\n  let position = 0;\n\n  let mimeType = \"\";\n  while (position < input.length && input[position] !== \",\") {\n    mimeType += input[position];\n    ++position;\n  }\n  mimeType = stripLeadingAndTrailingASCIIWhitespace(mimeType);\n\n  if (position === input.length) {\n    return null;\n  }\n\n  ++position;\n\n  const encodedBody = input.substring(position);\n\n  let body = stringPercentDecode(encodedBody);\n\n  // Can't use /i regexp flag because it isn't restricted to ASCII.\n  const mimeTypeBase64MatchResult = /(.*); *[Bb][Aa][Ss][Ee]64$/.exec(mimeType);\n  if (mimeTypeBase64MatchResult) {\n    const stringBody = isomorphicDecode(body);\n    body = forgivingBase64Decode(stringBody);\n\n    if (body === null) {\n      return null;\n    }\n    mimeType = mimeTypeBase64MatchResult[1];\n  }\n\n  if (mimeType.startsWith(\";\")) {\n    mimeType = \"text/plain\" + mimeType;\n  }\n\n  let mimeTypeRecord;\n  try {\n    mimeTypeRecord = new MIMEType(mimeType);\n  } catch (e) {\n    mimeTypeRecord = new MIMEType(\"text/plain;charset=US-ASCII\");\n  }\n\n  return {\n    mimeType: mimeTypeRecord,\n    body\n  };\n};\n"]},"metadata":{},"sourceType":"script"}