{"ast":null,"code":"\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\n\nconst {\n  simultaneousIterators\n} = require(\"../../utils\");\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\n\nconst {\n  clone,\n  locateNamespacePrefix,\n  locateNamespace\n} = require(\"../node\");\n\nconst {\n  setAnExistingAttributeValue\n} = require(\"../attributes\");\n\nconst NodeList = require(\"../generated/NodeList\");\n\nconst {\n  nodeRoot,\n  nodeLength\n} = require(\"../helpers/node\");\n\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\n\nconst {\n  documentBaseURLSerialized\n} = require(\"../helpers/document-base-url\");\n\nconst {\n  queueTreeMutationRecord\n} = require(\"../helpers/mutation-observers\");\n\nconst {\n  enqueueCECallbackReaction,\n  tryUpgradeElement\n} = require(\"../helpers/custom-elements\");\n\nconst {\n  isShadowRoot,\n  shadowIncludingRoot,\n  assignSlot,\n  assignSlotableForTree,\n  assignSlotable,\n  signalSlotChange,\n  isSlot,\n  shadowIncludingInclusiveDescendantsIterator,\n  shadowIncludingDescendantsIterator\n} = require(\"../helpers/shadow-dom\");\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE || node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE || node.nodeType === NODE_TYPE.NOTATION_NODE || node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId || a.systemId !== b.systemId) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName || a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.ATTRIBUTE_NODE:\n      if (a._namespace !== b._namespace || a._localName !== b._localName || a._value !== b._value) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n\n  return true;\n} // Needed by https://dom.spec.whatwg.org/#concept-node-equals\n\n\nfunction attributeListsEqual(elementA, elementB) {\n  const listA = elementA._attributeList;\n  const listB = elementB._attributeList;\n  const lengthA = listA.length;\n  const lengthB = listB.length;\n\n  if (lengthA !== lengthB) {\n    return false;\n  }\n\n  for (let i = 0; i < lengthA; ++i) {\n    const attrA = listA[i];\n\n    if (!listB.some(attrB => nodeEquals(attrA, attrB))) {\n      return false;\n    }\n  }\n\n  return true;\n} // https://dom.spec.whatwg.org/#concept-tree-host-including-inclusive-ancestor\n\n\nfunction isHostInclusiveAncestor(nodeImplA, nodeImplB) {\n  for (const ancestor of domSymbolTree.ancestorsIterator(nodeImplB)) {\n    if (ancestor === nodeImplA) {\n      return true;\n    }\n  }\n\n  const rootImplB = nodeRoot(nodeImplB);\n\n  if (rootImplB._host) {\n    return isHostInclusiveAncestor(nodeImplA, rootImplB._host);\n  }\n\n  return false;\n}\n\nclass NodeImpl extends EventTargetImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n    domSymbolTree.initialize(this);\n    this._ownerDocument = privateData.ownerDocument;\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n    this._registeredObserverList = [];\n    this._referencedRanges = new Set();\n  }\n\n  _getTheParent() {\n    if (this._assignedSlot) {\n      return this._assignedSlot;\n    }\n\n    return domSymbolTree.parent(this);\n  }\n\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n\n  getRootNode(options) {\n    return options.composed ? shadowIncludingRoot(this) : nodeRoot(this);\n  }\n\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        return this._qualifiedName;\n\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    } // should never happen\n\n\n    return null;\n  }\n\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  } // https://dom.spec.whatwg.org/#connected\n  // https://dom.spec.whatwg.org/#dom-node-isconnected\n\n\n  get isConnected() {\n    const root = shadowIncludingRoot(this);\n    return root && root.nodeType === NODE_TYPE.DOCUMENT_NODE;\n  }\n\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = NodeList.createImpl(this._globalObject, [], {\n        element: this,\n        query: () => domSymbolTree.childrenToArray(this)\n      });\n    } else {\n      this._childNodesList._update();\n    }\n\n    return this._childNodesList;\n  }\n\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n\n  _modified() {\n    this._version++;\n\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n\n    if (this._childNodesList) {\n      this._childNodesList._update();\n    }\n\n    this._clearMemoizedQueries();\n  }\n\n  _childTextContentChangeSteps() {// Default: do nothing\n  }\n\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n\n  _attach() {\n    this._attached = true;\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n\n  _detach() {\n    this._attached = false;\n\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  } // https://dom.spec.whatwg.org/#dom-node-normalize\n\n\n  normalize() {\n    // It is important to use a treeToArray instead of a treeToIterator here, because the\n    // treeToIterator doesn't support tree mutation in the middle of the traversal.\n    for (const node of domSymbolTree.treeToArray(this)) {\n      const parentNode = domSymbolTree.parent(node);\n\n      if (parentNode === null || node.nodeType !== NODE_TYPE.TEXT_NODE) {\n        continue;\n      }\n\n      let length = nodeLength(node);\n\n      if (length === 0) {\n        parentNode._remove(node);\n\n        continue;\n      }\n\n      const continuousExclusiveTextNodes = [];\n\n      for (const currentNode of domSymbolTree.previousSiblingsIterator(node)) {\n        if (currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n          break;\n        }\n\n        continuousExclusiveTextNodes.unshift(currentNode);\n      }\n\n      for (const currentNode of domSymbolTree.nextSiblingsIterator(node)) {\n        if (currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n          break;\n        }\n\n        continuousExclusiveTextNodes.push(currentNode);\n      }\n\n      const data = continuousExclusiveTextNodes.reduce((d, n) => d + n._data, \"\");\n      node.replaceData(length, 0, data);\n      let currentNode = domSymbolTree.nextSibling(node);\n\n      while (currentNode && currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n        const currentNodeParent = domSymbolTree.parent(currentNode);\n        const currentNodeIndex = domSymbolTree.index(currentNode);\n\n        for (const range of node._referencedRanges) {\n          const {\n            _start,\n            _end\n          } = range;\n\n          if (_start.node === currentNode) {\n            range._setLiveRangeStart(node, _start.offset + length);\n          }\n\n          if (_end.node === currentNode) {\n            range._setLiveRangeEnd(node, _end.offset + length);\n          }\n\n          if (_start.node === currentNodeParent && _start.offset === currentNodeIndex) {\n            range._setLiveRangeStart(node, length);\n          }\n\n          if (_end.node === currentNodeParent && _end.offset === currentNodeIndex) {\n            range._setLiveRangeStart(node, length);\n          }\n        }\n\n        length += nodeLength(currentNode);\n        currentNode = domSymbolTree.nextSibling(currentNode);\n      }\n\n      for (const continuousExclusiveTextNode of continuousExclusiveTextNodes) {\n        parentNode._remove(continuousExclusiveTextNode);\n      }\n    }\n  }\n\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n\n  compareDocumentPosition(other) {\n    // Let node1 be other and node2 be the context object.\n    let node1 = other;\n    let node2 = this;\n\n    if (isObsoleteNodeType(node2) || isObsoleteNodeType(node1)) {\n      throw new Error(\"Obsolete node type\");\n    }\n\n    let attr1 = null;\n    let attr2 = null;\n\n    if (node1.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      attr1 = node1;\n      node1 = attr1._element;\n    }\n\n    if (node2.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      attr2 = node2;\n      node2 = attr2._element;\n\n      if (attr1 !== null && node1 !== null && node2 === node1) {\n        for (const attr of node2._attributeList) {\n          if (nodeEquals(attr, attr1)) {\n            return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_PRECEDING;\n          }\n\n          if (nodeEquals(attr, attr2)) {\n            return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n          }\n        }\n      }\n    }\n\n    const result = domSymbolTree.compareTreePosition(node2, node1); // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    return result;\n  }\n\n  lookupPrefix(namespace) {\n    if (namespace === null || namespace === \"\") {\n      return null;\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          return locateNamespacePrefix(this, namespace);\n        }\n\n      case NODE_TYPE.DOCUMENT_NODE:\n        {\n          return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n        }\n\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        {\n          return null;\n        }\n\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n        }\n\n      default:\n        {\n          return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n        }\n    }\n  }\n\n  lookupNamespaceURI(prefix) {\n    if (prefix === \"\") {\n      prefix = null;\n    }\n\n    return locateNamespace(this, prefix);\n  }\n\n  isDefaultNamespace(namespace) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    const defaultNamespace = locateNamespace(this, null);\n    return defaultNamespace === namespace;\n  }\n\n  contains(other) {\n    if (other === null) {\n      return false;\n    } else if (this === other) {\n      return true;\n    }\n\n    return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    } // Fast-path, not in the spec\n\n\n    if (this === node) {\n      return true;\n    }\n\n    return nodeEquals(this, node);\n  }\n\n  isSameNode(node) {\n    if (this === node) {\n      return true;\n    }\n\n    return false;\n  }\n\n  cloneNode(deep) {\n    if (isShadowRoot(this)) {\n      throw DOMException.create(this._globalObject, [\"ShadowRoot nodes are not clonable.\", \"NotSupportedError\"]);\n    }\n\n    deep = Boolean(deep);\n    return clone(this, undefined, deep);\n  }\n\n  get nodeValue() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._value;\n        }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          return this._data;\n        }\n\n      default:\n        {\n          return null;\n        }\n    }\n  }\n\n  set nodeValue(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          setAnExistingAttributeValue(this, value);\n          break;\n        }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          this.replaceData(0, this.length, value);\n          break;\n        }\n    }\n  } // https://dom.spec.whatwg.org/#dom-node-textcontent\n\n\n  get textContent() {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          let text = \"\";\n\n          for (const child of domSymbolTree.treeIterator(this)) {\n            if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n              text += child.nodeValue;\n            }\n          }\n\n          return text;\n        }\n\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._value;\n        }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          return this._data;\n        }\n\n      default:\n        {\n          return null;\n        }\n    }\n  }\n\n  set textContent(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          // https://dom.spec.whatwg.org/#string-replace-all\n          let nodeImpl = null;\n\n          if (value !== \"\") {\n            nodeImpl = this._ownerDocument.createTextNode(value);\n          }\n\n          this._replaceAll(nodeImpl);\n\n          break;\n        }\n\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          setAnExistingAttributeValue(this, value);\n          break;\n        }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          this.replaceData(0, this.length, value);\n          break;\n        }\n    }\n  } // https://dom.spec.whatwg.org/#dom-node-insertbefore\n\n\n  insertBefore(nodeImpl, childImpl) {\n    return this._preInsert(nodeImpl, childImpl);\n  } // https://dom.spec.whatwg.org/#dom-node-appendchild\n\n\n  appendChild(nodeImpl) {\n    return this._append(nodeImpl);\n  } // https://dom.spec.whatwg.org/#dom-node-replacechild\n\n\n  replaceChild(nodeImpl, childImpl) {\n    return this._replace(nodeImpl, childImpl);\n  } // https://dom.spec.whatwg.org/#dom-node-removechild\n\n\n  removeChild(oldChildImpl) {\n    return this._preRemove(oldChildImpl);\n  } // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n\n\n  _preInsertValidity(nodeImpl, childImpl) {\n    const {\n      nodeType,\n      nodeName\n    } = nodeImpl;\n    const {\n      nodeType: parentType,\n      nodeName: parentName\n    } = this;\n\n    if (parentType !== NODE_TYPE.DOCUMENT_NODE && parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && parentType !== NODE_TYPE.ELEMENT_NODE) {\n      throw DOMException.create(this._globalObject, [`Node can't be inserted in a ${parentName} parent.`, \"HierarchyRequestError\"]);\n    }\n\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw DOMException.create(this._globalObject, [\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\"]);\n    }\n\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\"The child can not be found in the parent.\", \"NotFoundError\"]);\n    }\n\n    if (nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE && nodeType !== NODE_TYPE.ELEMENT_NODE && nodeType !== NODE_TYPE.TEXT_NODE && nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n    nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE && nodeType !== NODE_TYPE.COMMENT_NODE) {\n      throw DOMException.create(this._globalObject, [`${nodeName} node can't be inserted in parent node.`, \"HierarchyRequestError\"]);\n    }\n\n    if (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE || nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE) {\n      throw DOMException.create(this._globalObject, [`${nodeName} node can't be inserted in ${parentName} parent.`, \"HierarchyRequestError\"]);\n    }\n\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          {\n            const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n\n            if (nodeChildrenElements.length > 1) {\n              throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n            }\n\n            const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n\n            if (hasNodeTextChildren) {\n              throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n            }\n\n            if (nodeChildrenElements.length === 1 && (parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) || childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE)) {\n              throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n            }\n\n            break;\n          }\n\n        case NODE_TYPE.ELEMENT_NODE:\n          if (parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) || childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n            throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n          }\n\n          break;\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) || childImpl && domSymbolTree.previousSibling(childImpl) && domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE || !childImpl && parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE)) {\n            throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n          }\n\n          break;\n      }\n    }\n  } // https://dom.spec.whatwg.org/#concept-node-pre-insert\n\n\n  _preInsert(nodeImpl, childImpl) {\n    this._preInsertValidity(nodeImpl, childImpl);\n\n    let referenceChildImpl = childImpl;\n\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n\n    this._ownerDocument._adoptNode(nodeImpl);\n\n    this._insert(nodeImpl, referenceChildImpl);\n\n    return nodeImpl;\n  } // https://dom.spec.whatwg.org/#concept-node-insert\n\n\n  _insert(nodeImpl, childImpl, suppressObservers) {\n    const count = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenCount(nodeImpl) : 1;\n\n    if (childImpl) {\n      const childIndex = domSymbolTree.index(childImpl);\n\n      for (const range of this._referencedRanges) {\n        const {\n          _start,\n          _end\n        } = range;\n\n        if (_start.offset > childIndex) {\n          range._setLiveRangeStart(this, _start.offset + count);\n        }\n\n        if (_end.offset > childIndex) {\n          range._setLiveRangeEnd(this, _end.offset + count);\n        }\n      }\n    }\n\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenToArray(nodeImpl) : [nodeImpl];\n\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n\n      while (grandChildImpl = domSymbolTree.firstChild(nodeImpl)) {\n        nodeImpl._remove(grandChildImpl, true);\n      }\n    }\n\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      queueTreeMutationRecord(nodeImpl, [], nodesImpl, null, null);\n    }\n\n    const previousChildImpl = childImpl ? domSymbolTree.previousSibling(childImpl) : domSymbolTree.lastChild(this);\n\n    for (const node of nodesImpl) {\n      if (!childImpl) {\n        domSymbolTree.appendChild(this, node);\n      } else {\n        domSymbolTree.insertBefore(childImpl, node);\n      }\n\n      if (this.nodeType === NODE_TYPE.ELEMENT_NODE && this._shadowRoot !== null && (node.nodeType === NODE_TYPE.ELEMENT_NODE || node.nodeType === NODE_TYPE.TEXT_NODE)) {\n        assignSlot(node);\n      }\n\n      this._modified();\n\n      if (node.nodeType === NODE_TYPE.TEXT_NODE || node.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n        this._childTextContentChangeSteps();\n      }\n\n      if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n        signalSlotChange(this);\n      }\n\n      const root = nodeRoot(node);\n\n      if (isShadowRoot(root)) {\n        assignSlotableForTree(root);\n      }\n\n      if (this._attached && nodeImpl._attach) {\n        node._attach();\n      }\n\n      this._descendantAdded(this, node);\n\n      for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {\n        if (inclusiveDescendant.isConnected) {\n          if (inclusiveDescendant._ceState === \"custom\") {\n            enqueueCECallbackReaction(inclusiveDescendant, \"connectedCallback\", []);\n          } else {\n            tryUpgradeElement(inclusiveDescendant);\n          }\n        }\n      }\n    }\n\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, nodesImpl, [], previousChildImpl, childImpl);\n    }\n  } // https://dom.spec.whatwg.org/#concept-node-append\n\n\n  _append(nodeImpl) {\n    return this._preInsert(nodeImpl, null);\n  } // https://dom.spec.whatwg.org/#concept-node-replace\n\n\n  _replace(nodeImpl, childImpl) {\n    const {\n      nodeType,\n      nodeName\n    } = nodeImpl;\n    const {\n      nodeType: parentType,\n      nodeName: parentName\n    } = this; // Note: This section differs from the pre-insert validation algorithm.\n\n    if (parentType !== NODE_TYPE.DOCUMENT_NODE && parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && parentType !== NODE_TYPE.ELEMENT_NODE) {\n      throw DOMException.create(this._globalObject, [`Node can't be inserted in a ${parentName} parent.`, \"HierarchyRequestError\"]);\n    }\n\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw DOMException.create(this._globalObject, [\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\"]);\n    }\n\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\"The child can not be found in the parent.\", \"NotFoundError\"]);\n    }\n\n    if (nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE && nodeType !== NODE_TYPE.ELEMENT_NODE && nodeType !== NODE_TYPE.TEXT_NODE && nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n    nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE && nodeType !== NODE_TYPE.COMMENT_NODE) {\n      throw DOMException.create(this._globalObject, [`${nodeName} node can't be inserted in parent node.`, \"HierarchyRequestError\"]);\n    }\n\n    if (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE || nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE) {\n      throw DOMException.create(this._globalObject, [`${nodeName} node can't be inserted in ${parentName} parent.`, \"HierarchyRequestError\"]);\n    }\n\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          {\n            const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n\n            if (nodeChildrenElements.length > 1) {\n              throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n            }\n\n            const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n\n            if (hasNodeTextChildren) {\n              throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n            }\n\n            const parentChildElements = parentChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n\n            if (nodeChildrenElements.length === 1 && (parentChildElements.length === 1 && parentChildElements[0] !== childImpl || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE)) {\n              throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n            }\n\n            break;\n          }\n\n        case NODE_TYPE.ELEMENT_NODE:\n          if (parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE && child !== childImpl) || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n            throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n          }\n\n          break;\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && child !== childImpl) || childImpl && domSymbolTree.previousSibling(childImpl) && domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE) {\n            throw DOMException.create(this._globalObject, [`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\"]);\n          }\n\n          break;\n      }\n    }\n\n    let referenceChildImpl = domSymbolTree.nextSibling(childImpl);\n\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n\n    const previousSiblingImpl = domSymbolTree.previousSibling(childImpl);\n\n    this._ownerDocument._adoptNode(nodeImpl);\n\n    let removedNodesImpl = [];\n\n    if (domSymbolTree.parent(childImpl)) {\n      removedNodesImpl = [childImpl];\n\n      this._remove(childImpl, true);\n    }\n\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenToArray(nodeImpl) : [nodeImpl];\n\n    this._insert(nodeImpl, referenceChildImpl, true);\n\n    queueTreeMutationRecord(this, nodesImpl, removedNodesImpl, previousSiblingImpl, referenceChildImpl);\n    return childImpl;\n  } // https://dom.spec.whatwg.org/#concept-node-replace-all\n\n\n  _replaceAll(nodeImpl) {\n    if (nodeImpl !== null) {\n      this._ownerDocument._adoptNode(nodeImpl);\n    }\n\n    const removedNodesImpl = domSymbolTree.childrenToArray(this);\n    let addedNodesImpl;\n\n    if (nodeImpl === null) {\n      addedNodesImpl = [];\n    } else if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      addedNodesImpl = domSymbolTree.childrenToArray(nodeImpl);\n    } else {\n      addedNodesImpl = [nodeImpl];\n    }\n\n    for (const childImpl of domSymbolTree.childrenIterator(this)) {\n      this._remove(childImpl, true);\n    }\n\n    if (nodeImpl !== null) {\n      this._insert(nodeImpl, null, true);\n    }\n\n    if (addedNodesImpl.length > 0 || removedNodesImpl.length > 0) {\n      queueTreeMutationRecord(this, addedNodesImpl, removedNodesImpl, null, null);\n    }\n  } // https://dom.spec.whatwg.org/#concept-node-pre-remove\n\n\n  _preRemove(childImpl) {\n    if (domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\"The node to be removed is not a child of this node.\", \"NotFoundError\"]);\n    }\n\n    this._remove(childImpl);\n\n    return childImpl;\n  } // https://dom.spec.whatwg.org/#concept-node-remove\n\n\n  _remove(nodeImpl, suppressObservers) {\n    const index = domSymbolTree.index(nodeImpl);\n\n    for (const descendant of domSymbolTree.treeIterator(nodeImpl)) {\n      for (const range of descendant._referencedRanges) {\n        const {\n          _start,\n          _end\n        } = range;\n\n        if (_start.node === descendant) {\n          range._setLiveRangeStart(this, index);\n        }\n\n        if (_end.node === descendant) {\n          range._setLiveRangeEnd(this, index);\n        }\n      }\n    }\n\n    for (const range of this._referencedRanges) {\n      const {\n        _start,\n        _end\n      } = range;\n\n      if (_start.node === this && _start.offset > index) {\n        range._setLiveRangeStart(this, _start.offset - 1);\n      }\n\n      if (_end.node === this && _end.offset > index) {\n        range._setLiveRangeEnd(this, _end.offset - 1);\n      }\n    }\n\n    if (this._ownerDocument) {\n      this._ownerDocument._runPreRemovingSteps(nodeImpl);\n    }\n\n    const oldPreviousSiblingImpl = domSymbolTree.previousSibling(nodeImpl);\n    const oldNextSiblingImpl = domSymbolTree.nextSibling(nodeImpl);\n    domSymbolTree.remove(nodeImpl);\n\n    if (nodeImpl._assignedSlot) {\n      assignSlotable(nodeImpl._assignedSlot);\n    }\n\n    if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n      signalSlotChange(this);\n    }\n\n    let hasSlotDescendant = isSlot(nodeImpl);\n\n    if (!hasSlotDescendant) {\n      for (const child of domSymbolTree.treeIterator(nodeImpl)) {\n        if (isSlot(child)) {\n          hasSlotDescendant = true;\n          break;\n        }\n      }\n    }\n\n    if (hasSlotDescendant) {\n      assignSlotableForTree(nodeRoot(this));\n      assignSlotableForTree(nodeImpl);\n    }\n\n    this._modified();\n\n    nodeImpl._detach();\n\n    this._descendantRemoved(this, nodeImpl);\n\n    if (this.isConnected) {\n      if (nodeImpl._ceState === \"custom\") {\n        enqueueCECallbackReaction(nodeImpl, \"disconnectedCallback\", []);\n      }\n\n      for (const descendantImpl of shadowIncludingDescendantsIterator(nodeImpl)) {\n        if (descendantImpl._ceState === \"custom\") {\n          enqueueCECallbackReaction(descendantImpl, \"disconnectedCallback\", []);\n        }\n      }\n    }\n\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, [], [nodeImpl], oldPreviousSiblingImpl, oldNextSiblingImpl);\n    }\n\n    if (nodeImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n      this._childTextContentChangeSteps();\n    }\n  }\n\n}\n\nmodule.exports = {\n  implementation: NodeImpl\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/jsdom/lib/jsdom/living/nodes/Node-impl.js"],"names":["DOMException","require","EventTargetImpl","implementation","simultaneousIterators","NODE_TYPE","NODE_DOCUMENT_POSITION","clone","locateNamespacePrefix","locateNamespace","setAnExistingAttributeValue","NodeList","nodeRoot","nodeLength","domSymbolTree","documentBaseURLSerialized","queueTreeMutationRecord","enqueueCECallbackReaction","tryUpgradeElement","isShadowRoot","shadowIncludingRoot","assignSlot","assignSlotableForTree","assignSlotable","signalSlotChange","isSlot","shadowIncludingInclusiveDescendantsIterator","shadowIncludingDescendantsIterator","isObsoleteNodeType","node","nodeType","ENTITY_NODE","ENTITY_REFERENCE_NODE","NOTATION_NODE","CDATA_SECTION_NODE","nodeEquals","a","b","DOCUMENT_TYPE_NODE","name","publicId","systemId","ELEMENT_NODE","_namespaceURI","_prefix","_localName","_attributes","length","ATTRIBUTE_NODE","_namespace","_value","PROCESSING_INSTRUCTION_NODE","_target","_data","TEXT_NODE","COMMENT_NODE","attributeListsEqual","nodes","childrenIterator","elementA","elementB","listA","_attributeList","listB","lengthA","lengthB","i","attrA","some","attrB","isHostInclusiveAncestor","nodeImplA","nodeImplB","ancestor","ancestorsIterator","rootImplB","_host","NodeImpl","constructor","globalObject","args","privateData","initialize","_ownerDocument","ownerDocument","_childNodesList","_childrenList","_version","_memoizedQueries","_registeredObserverList","_referencedRanges","Set","_getTheParent","_assignedSlot","parent","parentNode","getRootNode","options","composed","nodeName","tagName","_qualifiedName","target","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","firstChild","isConnected","root","lastChild","childNodes","createImpl","_globalObject","element","query","childrenToArray","_update","nextSibling","previousSibling","_modified","_clearMemoizedQueries","_childTextContentChangeSteps","myParent","_descendantRemoved","child","_descendantAdded","_attach","_attached","_detach","_lastFocusedElement","hasChildNodes","hasChildren","normalize","treeToArray","_remove","continuousExclusiveTextNodes","currentNode","previousSiblingsIterator","unshift","nextSiblingsIterator","push","data","reduce","d","n","replaceData","currentNodeParent","currentNodeIndex","index","range","_start","_end","_setLiveRangeStart","offset","_setLiveRangeEnd","continuousExclusiveTextNode","parentElement","baseURI","compareDocumentPosition","other","node1","node2","Error","attr1","attr2","_element","attr","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","result","compareTreePosition","DOCUMENT_POSITION_DISCONNECTED","lookupPrefix","namespace","documentElement","lookupNamespaceURI","prefix","isDefaultNamespace","defaultNamespace","contains","Boolean","DOCUMENT_POSITION_CONTAINED_BY","isEqualNode","isSameNode","cloneNode","deep","create","undefined","nodeValue","value","textContent","text","treeIterator","nodeImpl","createTextNode","_replaceAll","insertBefore","childImpl","_preInsert","appendChild","_append","replaceChild","_replace","removeChild","oldChildImpl","_preRemove","_preInsertValidity","parentType","parentName","nodeChildren","parentChildren","nodeChildrenElements","filter","hasNodeTextChildren","referenceChildImpl","_adoptNode","_insert","suppressObservers","count","childrenCount","childIndex","nodesImpl","grandChildImpl","previousChildImpl","_shadowRoot","_assignedNodes","inclusiveDescendant","_ceState","parentChildElements","previousSiblingImpl","removedNodesImpl","addedNodesImpl","descendant","_runPreRemovingSteps","oldPreviousSiblingImpl","oldNextSiblingImpl","remove","hasSlotDescendant","descendantImpl","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst { simultaneousIterators } = require(\"../../utils\");\nconst NODE_TYPE = require(\"../node-type\");\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\nconst { clone, locateNamespacePrefix, locateNamespace } = require(\"../node\");\nconst { setAnExistingAttributeValue } = require(\"../attributes\");\n\nconst NodeList = require(\"../generated/NodeList\");\n\nconst { nodeRoot, nodeLength } = require(\"../helpers/node\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst { documentBaseURLSerialized } = require(\"../helpers/document-base-url\");\nconst { queueTreeMutationRecord } = require(\"../helpers/mutation-observers\");\nconst { enqueueCECallbackReaction, tryUpgradeElement } = require(\"../helpers/custom-elements\");\nconst {\n  isShadowRoot, shadowIncludingRoot, assignSlot, assignSlotableForTree, assignSlotable, signalSlotChange, isSlot,\n  shadowIncludingInclusiveDescendantsIterator, shadowIncludingDescendantsIterator\n} = require(\"../helpers/shadow-dom\");\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE ||\n    node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE ||\n    node.nodeType === NODE_TYPE.NOTATION_NODE ||\n    node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId ||\n          a.systemId !== b.systemId) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName ||\n          a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ATTRIBUTE_NODE:\n      if (a._namespace !== b._namespace || a._localName !== b._localName || a._value !== b._value) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Needed by https://dom.spec.whatwg.org/#concept-node-equals\nfunction attributeListsEqual(elementA, elementB) {\n  const listA = elementA._attributeList;\n  const listB = elementB._attributeList;\n\n  const lengthA = listA.length;\n  const lengthB = listB.length;\n\n  if (lengthA !== lengthB) {\n    return false;\n  }\n\n  for (let i = 0; i < lengthA; ++i) {\n    const attrA = listA[i];\n\n    if (!listB.some(attrB => nodeEquals(attrA, attrB))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// https://dom.spec.whatwg.org/#concept-tree-host-including-inclusive-ancestor\nfunction isHostInclusiveAncestor(nodeImplA, nodeImplB) {\n  for (const ancestor of domSymbolTree.ancestorsIterator(nodeImplB)) {\n    if (ancestor === nodeImplA) {\n      return true;\n    }\n  }\n\n  const rootImplB = nodeRoot(nodeImplB);\n  if (rootImplB._host) {\n    return isHostInclusiveAncestor(nodeImplA, rootImplB._host);\n  }\n\n  return false;\n}\n\nclass NodeImpl extends EventTargetImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n\n    domSymbolTree.initialize(this);\n\n    this._ownerDocument = privateData.ownerDocument;\n\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n    this._registeredObserverList = [];\n    this._referencedRanges = new Set();\n  }\n\n  _getTheParent() {\n    if (this._assignedSlot) {\n      return this._assignedSlot;\n    }\n\n    return domSymbolTree.parent(this);\n  }\n\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n\n  getRootNode(options) {\n    return options.composed ? shadowIncludingRoot(this) : nodeRoot(this);\n  }\n\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        return this._qualifiedName;\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    }\n\n    // should never happen\n    return null;\n  }\n\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  }\n\n  // https://dom.spec.whatwg.org/#connected\n  // https://dom.spec.whatwg.org/#dom-node-isconnected\n  get isConnected() {\n    const root = shadowIncludingRoot(this);\n    return root && root.nodeType === NODE_TYPE.DOCUMENT_NODE;\n  }\n\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = NodeList.createImpl(this._globalObject, [], {\n        element: this,\n        query: () => domSymbolTree.childrenToArray(this)\n      });\n    } else {\n      this._childNodesList._update();\n    }\n\n    return this._childNodesList;\n  }\n\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n\n  _modified() {\n    this._version++;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n    if (this._childNodesList) {\n      this._childNodesList._update();\n    }\n    this._clearMemoizedQueries();\n  }\n\n  _childTextContentChangeSteps() {\n    // Default: do nothing\n  }\n\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n\n  _attach() {\n    this._attached = true;\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n\n  _detach() {\n    this._attached = false;\n\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-normalize\n  normalize() {\n    // It is important to use a treeToArray instead of a treeToIterator here, because the\n    // treeToIterator doesn't support tree mutation in the middle of the traversal.\n    for (const node of domSymbolTree.treeToArray(this)) {\n      const parentNode = domSymbolTree.parent(node);\n      if (parentNode === null || node.nodeType !== NODE_TYPE.TEXT_NODE) {\n        continue;\n      }\n\n      let length = nodeLength(node);\n\n      if (length === 0) {\n        parentNode._remove(node);\n        continue;\n      }\n\n      const continuousExclusiveTextNodes = [];\n\n      for (const currentNode of domSymbolTree.previousSiblingsIterator(node)) {\n        if (currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n          break;\n        }\n\n        continuousExclusiveTextNodes.unshift(currentNode);\n      }\n      for (const currentNode of domSymbolTree.nextSiblingsIterator(node)) {\n        if (currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n          break;\n        }\n\n        continuousExclusiveTextNodes.push(currentNode);\n      }\n\n      const data = continuousExclusiveTextNodes.reduce((d, n) => d + n._data, \"\");\n      node.replaceData(length, 0, data);\n\n      let currentNode = domSymbolTree.nextSibling(node);\n      while (currentNode && currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n        const currentNodeParent = domSymbolTree.parent(currentNode);\n        const currentNodeIndex = domSymbolTree.index(currentNode);\n\n        for (const range of node._referencedRanges) {\n          const { _start, _end } = range;\n\n          if (_start.node === currentNode) {\n            range._setLiveRangeStart(node, _start.offset + length);\n          }\n          if (_end.node === currentNode) {\n            range._setLiveRangeEnd(node, _end.offset + length);\n          }\n          if (_start.node === currentNodeParent && _start.offset === currentNodeIndex) {\n            range._setLiveRangeStart(node, length);\n          }\n          if (_end.node === currentNodeParent && _end.offset === currentNodeIndex) {\n            range._setLiveRangeStart(node, length);\n          }\n        }\n\n        length += nodeLength(currentNode);\n        currentNode = domSymbolTree.nextSibling(currentNode);\n      }\n\n      for (const continuousExclusiveTextNode of continuousExclusiveTextNodes) {\n        parentNode._remove(continuousExclusiveTextNode);\n      }\n    }\n  }\n\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n\n  compareDocumentPosition(other) {\n    // Let node1 be other and node2 be the context object.\n    let node1 = other;\n    let node2 = this;\n\n    if (isObsoleteNodeType(node2) || isObsoleteNodeType(node1)) {\n      throw new Error(\"Obsolete node type\");\n    }\n\n    let attr1 = null;\n    let attr2 = null;\n\n    if (node1.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      attr1 = node1;\n      node1 = attr1._element;\n    }\n\n    if (node2.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      attr2 = node2;\n      node2 = attr2._element;\n\n      if (attr1 !== null && node1 !== null && node2 === node1) {\n        for (const attr of node2._attributeList) {\n          if (nodeEquals(attr, attr1)) {\n            return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n              NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_PRECEDING;\n          }\n\n          if (nodeEquals(attr, attr2)) {\n            return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n              NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n          }\n        }\n      }\n    }\n\n    const result = domSymbolTree.compareTreePosition(node2, node1);\n\n    // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    return result;\n  }\n\n  lookupPrefix(namespace) {\n    if (namespace === null || namespace === \"\") {\n      return null;\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE: {\n        return locateNamespacePrefix(this, namespace);\n      }\n      case NODE_TYPE.DOCUMENT_NODE: {\n        return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n      }\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n        return null;\n      }\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n      }\n      default: {\n        return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n      }\n    }\n  }\n\n  lookupNamespaceURI(prefix) {\n    if (prefix === \"\") {\n      prefix = null;\n    }\n\n    return locateNamespace(this, prefix);\n  }\n\n  isDefaultNamespace(namespace) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    const defaultNamespace = locateNamespace(this, null);\n    return defaultNamespace === namespace;\n  }\n\n  contains(other) {\n    if (other === null) {\n      return false;\n    } else if (this === other) {\n      return true;\n    }\n    return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    }\n\n    // Fast-path, not in the spec\n    if (this === node) {\n      return true;\n    }\n\n    return nodeEquals(this, node);\n  }\n\n  isSameNode(node) {\n    if (this === node) {\n      return true;\n    }\n\n    return false;\n  }\n\n  cloneNode(deep) {\n    if (isShadowRoot(this)) {\n      throw DOMException.create(this._globalObject, [\"ShadowRoot nodes are not clonable.\", \"NotSupportedError\"]);\n    }\n\n    deep = Boolean(deep);\n\n    return clone(this, undefined, deep);\n  }\n\n  get nodeValue() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._value;\n      }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        return this._data;\n      }\n      default: {\n        return null;\n      }\n    }\n  }\n\n  set nodeValue(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        setAnExistingAttributeValue(this, value);\n        break;\n      }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        this.replaceData(0, this.length, value);\n        break;\n      }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-textcontent\n  get textContent() {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE: {\n        let text = \"\";\n        for (const child of domSymbolTree.treeIterator(this)) {\n          if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n            text += child.nodeValue;\n          }\n        }\n        return text;\n      }\n\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._value;\n      }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        return this._data;\n      }\n\n      default: {\n        return null;\n      }\n    }\n  }\n  set textContent(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE: {\n        // https://dom.spec.whatwg.org/#string-replace-all\n        let nodeImpl = null;\n\n        if (value !== \"\") {\n          nodeImpl = this._ownerDocument.createTextNode(value);\n        }\n\n        this._replaceAll(nodeImpl);\n        break;\n      }\n\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        setAnExistingAttributeValue(this, value);\n        break;\n      }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        this.replaceData(0, this.length, value);\n        break;\n      }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-insertbefore\n  insertBefore(nodeImpl, childImpl) {\n    return this._preInsert(nodeImpl, childImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-appendchild\n  appendChild(nodeImpl) {\n    return this._append(nodeImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-replacechild\n  replaceChild(nodeImpl, childImpl) {\n    return this._replace(nodeImpl, childImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-removechild\n  removeChild(oldChildImpl) {\n    return this._preRemove(oldChildImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n  _preInsertValidity(nodeImpl, childImpl) {\n    const { nodeType, nodeName } = nodeImpl;\n    const { nodeType: parentType, nodeName: parentName } = this;\n\n    if (\n      parentType !== NODE_TYPE.DOCUMENT_NODE &&\n      parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      parentType !== NODE_TYPE.ELEMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `Node can't be inserted in a ${parentName} parent.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw DOMException.create(this._globalObject, [\n        \"The operation would yield an incorrect node tree.\",\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\n        \"The child can not be found in the parent.\",\n        \"NotFoundError\"\n      ]);\n    }\n\n    if (\n      nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE &&\n      nodeType !== NODE_TYPE.ELEMENT_NODE &&\n      nodeType !== NODE_TYPE.TEXT_NODE &&\n      nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n      nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE &&\n      nodeType !== NODE_TYPE.COMMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `${nodeName} node can't be inserted in parent node.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (\n      (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE) ||\n      (nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE)\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `${nodeName} node can't be inserted in ${parentName} parent.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n          const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n          if (nodeChildrenElements.length > 1) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n\n          const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n          if (hasNodeTextChildren) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n\n          if (\n            nodeChildrenElements.length === 1 &&\n            (\n              parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) ||\n              (childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) ||\n              (\n                childImpl &&\n                domSymbolTree.nextSibling(childImpl) &&\n                domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n              )\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n        }\n\n        case NODE_TYPE.ELEMENT_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) ||\n            (childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) ||\n            (\n              childImpl &&\n              domSymbolTree.nextSibling(childImpl) &&\n              domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) ||\n            (\n              childImpl &&\n              domSymbolTree.previousSibling(childImpl) &&\n              domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE\n            ) ||\n            (!childImpl && parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE))\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n      }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-pre-insert\n  _preInsert(nodeImpl, childImpl) {\n    this._preInsertValidity(nodeImpl, childImpl);\n\n    let referenceChildImpl = childImpl;\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n\n    this._ownerDocument._adoptNode(nodeImpl);\n\n    this._insert(nodeImpl, referenceChildImpl);\n\n    return nodeImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-insert\n  _insert(nodeImpl, childImpl, suppressObservers) {\n    const count = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ?\n        domSymbolTree.childrenCount(nodeImpl) :\n        1;\n\n    if (childImpl) {\n      const childIndex = domSymbolTree.index(childImpl);\n\n      for (const range of this._referencedRanges) {\n        const { _start, _end } = range;\n\n        if (_start.offset > childIndex) {\n          range._setLiveRangeStart(this, _start.offset + count);\n        }\n\n        if (_end.offset > childIndex) {\n          range._setLiveRangeEnd(this, _end.offset + count);\n        }\n      }\n    }\n\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ?\n      domSymbolTree.childrenToArray(nodeImpl) :\n      [nodeImpl];\n\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n      while ((grandChildImpl = domSymbolTree.firstChild(nodeImpl))) {\n        nodeImpl._remove(grandChildImpl, true);\n      }\n    }\n\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      queueTreeMutationRecord(nodeImpl, [], nodesImpl, null, null);\n    }\n\n    const previousChildImpl = childImpl ?\n      domSymbolTree.previousSibling(childImpl) :\n      domSymbolTree.lastChild(this);\n\n    for (const node of nodesImpl) {\n      if (!childImpl) {\n        domSymbolTree.appendChild(this, node);\n      } else {\n        domSymbolTree.insertBefore(childImpl, node);\n      }\n\n      if (\n        (this.nodeType === NODE_TYPE.ELEMENT_NODE && this._shadowRoot !== null) &&\n        (node.nodeType === NODE_TYPE.ELEMENT_NODE || node.nodeType === NODE_TYPE.TEXT_NODE)\n      ) {\n        assignSlot(node);\n      }\n\n      this._modified();\n\n      if (node.nodeType === NODE_TYPE.TEXT_NODE ||\n          node.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n        this._childTextContentChangeSteps();\n      }\n\n      if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n        signalSlotChange(this);\n      }\n\n      const root = nodeRoot(node);\n      if (isShadowRoot(root)) {\n        assignSlotableForTree(root);\n      }\n\n      if (this._attached && nodeImpl._attach) {\n        node._attach();\n      }\n\n      this._descendantAdded(this, node);\n\n      for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {\n        if (inclusiveDescendant.isConnected) {\n          if (inclusiveDescendant._ceState === \"custom\") {\n            enqueueCECallbackReaction(inclusiveDescendant, \"connectedCallback\", []);\n          } else {\n            tryUpgradeElement(inclusiveDescendant);\n          }\n        }\n      }\n    }\n\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, nodesImpl, [], previousChildImpl, childImpl);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-append\n  _append(nodeImpl) {\n    return this._preInsert(nodeImpl, null);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-replace\n  _replace(nodeImpl, childImpl) {\n    const { nodeType, nodeName } = nodeImpl;\n    const { nodeType: parentType, nodeName: parentName } = this;\n\n    // Note: This section differs from the pre-insert validation algorithm.\n    if (\n      parentType !== NODE_TYPE.DOCUMENT_NODE &&\n      parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      parentType !== NODE_TYPE.ELEMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `Node can't be inserted in a ${parentName} parent.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw DOMException.create(this._globalObject, [\n        \"The operation would yield an incorrect node tree.\",\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\n        \"The child can not be found in the parent.\",\n        \"NotFoundError\"\n      ]);\n    }\n\n    if (\n      nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE &&\n      nodeType !== NODE_TYPE.ELEMENT_NODE &&\n      nodeType !== NODE_TYPE.TEXT_NODE &&\n      nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n      nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE &&\n      nodeType !== NODE_TYPE.COMMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `${nodeName} node can't be inserted in parent node.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (\n      (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE) ||\n      (nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE)\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `${nodeName} node can't be inserted in ${parentName} parent.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n          const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n          if (nodeChildrenElements.length > 1) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n\n          const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n          if (hasNodeTextChildren) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n\n\n          const parentChildElements = parentChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n          if (\n            nodeChildrenElements.length === 1 &&\n            (\n              (parentChildElements.length === 1 && parentChildElements[0] !== childImpl) ||\n              (\n                childImpl &&\n                domSymbolTree.nextSibling(childImpl) &&\n                domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n              )\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n        }\n\n        case NODE_TYPE.ELEMENT_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE && child !== childImpl) ||\n            (\n              childImpl &&\n              domSymbolTree.nextSibling(childImpl) &&\n              domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && child !== childImpl) ||\n            (\n              childImpl &&\n              domSymbolTree.previousSibling(childImpl) &&\n              domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n      }\n    }\n\n    let referenceChildImpl = domSymbolTree.nextSibling(childImpl);\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n\n    const previousSiblingImpl = domSymbolTree.previousSibling(childImpl);\n\n    this._ownerDocument._adoptNode(nodeImpl);\n\n    let removedNodesImpl = [];\n\n    if (domSymbolTree.parent(childImpl)) {\n      removedNodesImpl = [childImpl];\n      this._remove(childImpl, true);\n    }\n\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ?\n      domSymbolTree.childrenToArray(nodeImpl) :\n      [nodeImpl];\n\n    this._insert(nodeImpl, referenceChildImpl, true);\n\n    queueTreeMutationRecord(this, nodesImpl, removedNodesImpl, previousSiblingImpl, referenceChildImpl);\n\n    return childImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-replace-all\n  _replaceAll(nodeImpl) {\n    if (nodeImpl !== null) {\n      this._ownerDocument._adoptNode(nodeImpl);\n    }\n\n    const removedNodesImpl = domSymbolTree.childrenToArray(this);\n\n    let addedNodesImpl;\n    if (nodeImpl === null) {\n      addedNodesImpl = [];\n    } else if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      addedNodesImpl = domSymbolTree.childrenToArray(nodeImpl);\n    } else {\n      addedNodesImpl = [nodeImpl];\n    }\n\n    for (const childImpl of domSymbolTree.childrenIterator(this)) {\n      this._remove(childImpl, true);\n    }\n\n    if (nodeImpl !== null) {\n      this._insert(nodeImpl, null, true);\n    }\n\n    if (addedNodesImpl.length > 0 || removedNodesImpl.length > 0) {\n      queueTreeMutationRecord(this, addedNodesImpl, removedNodesImpl, null, null);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-pre-remove\n  _preRemove(childImpl) {\n    if (domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\n        \"The node to be removed is not a child of this node.\",\n        \"NotFoundError\"\n      ]);\n    }\n\n    this._remove(childImpl);\n\n    return childImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-remove\n  _remove(nodeImpl, suppressObservers) {\n    const index = domSymbolTree.index(nodeImpl);\n\n    for (const descendant of domSymbolTree.treeIterator(nodeImpl)) {\n      for (const range of descendant._referencedRanges) {\n        const { _start, _end } = range;\n\n        if (_start.node === descendant) {\n          range._setLiveRangeStart(this, index);\n        }\n\n        if (_end.node === descendant) {\n          range._setLiveRangeEnd(this, index);\n        }\n      }\n    }\n\n    for (const range of this._referencedRanges) {\n      const { _start, _end } = range;\n\n      if (_start.node === this && _start.offset > index) {\n        range._setLiveRangeStart(this, _start.offset - 1);\n      }\n\n      if (_end.node === this && _end.offset > index) {\n        range._setLiveRangeEnd(this, _end.offset - 1);\n      }\n    }\n\n    if (this._ownerDocument) {\n      this._ownerDocument._runPreRemovingSteps(nodeImpl);\n    }\n\n    const oldPreviousSiblingImpl = domSymbolTree.previousSibling(nodeImpl);\n    const oldNextSiblingImpl = domSymbolTree.nextSibling(nodeImpl);\n\n    domSymbolTree.remove(nodeImpl);\n\n    if (nodeImpl._assignedSlot) {\n      assignSlotable(nodeImpl._assignedSlot);\n    }\n\n    if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n      signalSlotChange(this);\n    }\n\n    let hasSlotDescendant = isSlot(nodeImpl);\n    if (!hasSlotDescendant) {\n      for (const child of domSymbolTree.treeIterator(nodeImpl)) {\n        if (isSlot(child)) {\n          hasSlotDescendant = true;\n          break;\n        }\n      }\n    }\n\n    if (hasSlotDescendant) {\n      assignSlotableForTree(nodeRoot(this));\n      assignSlotableForTree(nodeImpl);\n    }\n\n    this._modified();\n    nodeImpl._detach();\n    this._descendantRemoved(this, nodeImpl);\n\n    if (this.isConnected) {\n      if (nodeImpl._ceState === \"custom\") {\n        enqueueCECallbackReaction(nodeImpl, \"disconnectedCallback\", []);\n      }\n\n      for (const descendantImpl of shadowIncludingDescendantsIterator(nodeImpl)) {\n        if (descendantImpl._ceState === \"custom\") {\n          enqueueCECallbackReaction(descendantImpl, \"disconnectedCallback\", []);\n        }\n      }\n    }\n\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, [], [nodeImpl], oldPreviousSiblingImpl, oldNextSiblingImpl);\n    }\n\n    if (nodeImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n      this._childTextContentChangeSteps();\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: NodeImpl\n};\n"]},"metadata":{},"sourceType":"script"}