{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ed5 = require(\"xmlchars/xml/1.0/ed5\");\n\nconst ed2 = require(\"xmlchars/xml/1.1/ed2\");\n\nconst NSed3 = require(\"xmlchars/xmlns/1.0/ed3\");\n\nvar isS = ed5.isS;\nvar isChar10 = ed5.isChar;\nvar isNameStartChar = ed5.isNameStartChar;\nvar isNameChar = ed5.isNameChar;\nvar S_LIST = ed5.S_LIST;\nvar NAME_RE = ed5.NAME_RE;\nvar isChar11 = ed2.isChar;\nvar isNCNameStartChar = NSed3.isNCNameStartChar;\nvar isNCNameChar = NSed3.isNCNameChar;\nvar NC_NAME_RE = NSed3.NC_NAME_RE;\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nconst rootNS = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  __proto__: null,\n  xml: XML_NAMESPACE,\n  xmlns: XMLNS_NAMESPACE\n};\nconst XML_ENTITIES = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  __proto__: null,\n  amp: \"&\",\n  gt: \">\",\n  lt: \"<\",\n  quot: \"\\\"\",\n  apos: \"'\"\n}; // EOC: end-of-chunk\n\nconst EOC = -1;\nconst NL_LIKE = -2;\nconst S_BEGIN = 0; // Initial state.\n\nconst S_BEGIN_WHITESPACE = 1; // leading whitespace\n\nconst S_DOCTYPE = 2; // <!DOCTYPE\n\nconst S_DOCTYPE_QUOTE = 3; // <!DOCTYPE \"//blah\n\nconst S_DTD = 4; // <!DOCTYPE \"//blah\" [ ...\n\nconst S_DTD_QUOTED = 5; // <!DOCTYPE \"//blah\" [ \"foo\n\nconst S_DTD_OPEN_WAKA = 6;\nconst S_DTD_OPEN_WAKA_BANG = 7;\nconst S_DTD_COMMENT = 8; // <!--\n\nconst S_DTD_COMMENT_ENDING = 9; // <!-- blah -\n\nconst S_DTD_COMMENT_ENDED = 10; // <!-- blah --\n\nconst S_DTD_PI = 11; // <?\n\nconst S_DTD_PI_ENDING = 12; // <?hi \"there\" ?\n\nconst S_TEXT = 13; // general stuff\n\nconst S_ENTITY = 14; // &amp and such\n\nconst S_OPEN_WAKA = 15; // <\n\nconst S_OPEN_WAKA_BANG = 16; // <!...\n\nconst S_COMMENT = 17; // <!--\n\nconst S_COMMENT_ENDING = 18; // <!-- blah -\n\nconst S_COMMENT_ENDED = 19; // <!-- blah --\n\nconst S_CDATA = 20; // <![CDATA[ something\n\nconst S_CDATA_ENDING = 21; // ]\n\nconst S_CDATA_ENDING_2 = 22; // ]]\n\nconst S_PI_FIRST_CHAR = 23; // <?hi, first char\n\nconst S_PI_REST = 24; // <?hi, rest of the name\n\nconst S_PI_BODY = 25; // <?hi there\n\nconst S_PI_ENDING = 26; // <?hi \"there\" ?\n\nconst S_XML_DECL_NAME_START = 27; // <?xml\n\nconst S_XML_DECL_NAME = 28; // <?xml foo\n\nconst S_XML_DECL_EQ = 29; // <?xml foo=\n\nconst S_XML_DECL_VALUE_START = 30; // <?xml foo=\n\nconst S_XML_DECL_VALUE = 31; // <?xml foo=\"bar\"\n\nconst S_XML_DECL_SEPARATOR = 32; // <?xml foo=\"bar\"\n\nconst S_XML_DECL_ENDING = 33; // <?xml ... ?\n\nconst S_OPEN_TAG = 34; // <strong\n\nconst S_OPEN_TAG_SLASH = 35; // <strong /\n\nconst S_ATTRIB = 36; // <a\n\nconst S_ATTRIB_NAME = 37; // <a foo\n\nconst S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _\n\nconst S_ATTRIB_VALUE = 39; // <a foo=\n\nconst S_ATTRIB_VALUE_QUOTED = 40; // <a foo=\"bar\n\nconst S_ATTRIB_VALUE_CLOSED = 41; // <a foo=\"bar\"\n\nconst S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar\n\nconst S_CLOSE_TAG = 43; // </a\n\nconst S_CLOSE_TAG_SAW_WHITE = 44; // </a   >\n\nconst TAB = 9;\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\nconst NEL = 0x85;\nconst LS = 0x2028; // Line Separator\n\nconst isQuote = c => c === DQUOTE || c === SQUOTE;\n\nconst QUOTES = [DQUOTE, SQUOTE];\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\n\nfunction nsPairCheck(parser, prefix, uri) {\n  switch (prefix) {\n    case \"xml\":\n      if (uri !== XML_NAMESPACE) {\n        parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n      }\n\n      break;\n\n    case \"xmlns\":\n      if (uri !== XMLNS_NAMESPACE) {\n        parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n      }\n\n      break;\n\n    default:\n  }\n\n  switch (uri) {\n    case XMLNS_NAMESPACE:\n      parser.fail(prefix === \"\" ? `the default namespace may not be set to ${uri}.` : `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n      break;\n\n    case XML_NAMESPACE:\n      switch (prefix) {\n        case \"xml\":\n          // Assinging the XML namespace to \"xml\" is fine.\n          break;\n\n        case \"\":\n          parser.fail(`the default namespace may not be set to ${uri}.`);\n          break;\n\n        default:\n          parser.fail(\"may not assign the xml namespace to another prefix.\");\n      }\n\n      break;\n\n    default:\n  }\n}\n\nfunction nsMappingCheck(parser, mapping) {\n  for (const local of Object.keys(mapping)) {\n    nsPairCheck(parser, local, mapping[local]);\n  }\n}\n\nconst isNCName = name => NC_NAME_RE.test(name);\n\nconst isName = name => NAME_RE.test(name);\n\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n/**\n * The list of supported events.\n */\n\nexports.EVENTS = [\"xmldecl\", \"text\", \"processinginstruction\", \"doctype\", \"comment\", \"opentagstart\", \"attribute\", \"opentag\", \"closetag\", \"cdata\", \"error\", \"end\", \"ready\"];\nconst EVENT_NAME_TO_HANDLER_NAME = {\n  xmldecl: \"xmldeclHandler\",\n  text: \"textHandler\",\n  processinginstruction: \"piHandler\",\n  doctype: \"doctypeHandler\",\n  comment: \"commentHandler\",\n  opentagstart: \"openTagStartHandler\",\n  attribute: \"attributeHandler\",\n  opentag: \"openTagHandler\",\n  closetag: \"closeTagHandler\",\n  cdata: \"cdataHandler\",\n  error: \"errorHandler\",\n  end: \"endHandler\",\n  ready: \"readyHandler\"\n};\n\nclass SaxesParser {\n  /**\n   * @param opt The parser options.\n   */\n  constructor(opt) {\n    this.opt = opt !== null && opt !== void 0 ? opt : {};\n    this.fragmentOpt = !!this.opt.fragment;\n    const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n    this.trackPosition = this.opt.position !== false;\n    this.fileName = this.opt.fileName;\n\n    if (xmlnsOpt) {\n      // This is the function we use to perform name checks on PIs and entities.\n      // When namespaces are used, colons are not allowed in PI target names or\n      // entity names. So the check depends on whether namespaces are used. See:\n      //\n      // https://www.w3.org/XML/xml-names-19990114-errata.html\n      // NE08\n      //\n      this.nameStartCheck = isNCNameStartChar;\n      this.nameCheck = isNCNameChar;\n      this.isName = isNCName; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.processAttribs = this.processAttribsNS; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.pushAttrib = this.pushAttribNS; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      this.ns = Object.assign({\n        __proto__: null\n      }, rootNS);\n      const additional = this.opt.additionalNamespaces;\n\n      if (additional != null) {\n        nsMappingCheck(this, additional);\n        Object.assign(this.ns, additional);\n      }\n    } else {\n      this.nameStartCheck = isNameStartChar;\n      this.nameCheck = isNameChar;\n      this.isName = isName; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.processAttribs = this.processAttribsPlain; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.pushAttrib = this.pushAttribPlain;\n    } //\n    // The order of the members in this table needs to correspond to the state\n    // numbers given to the states that correspond to the methods being recorded\n    // here.\n    //\n\n\n    this.stateTable = [\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.sBegin, this.sBeginWhitespace, this.sDoctype, this.sDoctypeQuote, this.sDTD, this.sDTDQuoted, this.sDTDOpenWaka, this.sDTDOpenWakaBang, this.sDTDComment, this.sDTDCommentEnding, this.sDTDCommentEnded, this.sDTDPI, this.sDTDPIEnding, this.sText, this.sEntity, this.sOpenWaka, this.sOpenWakaBang, this.sComment, this.sCommentEnding, this.sCommentEnded, this.sCData, this.sCDataEnding, this.sCDataEnding2, this.sPIFirstChar, this.sPIRest, this.sPIBody, this.sPIEnding, this.sXMLDeclNameStart, this.sXMLDeclName, this.sXMLDeclEq, this.sXMLDeclValueStart, this.sXMLDeclValue, this.sXMLDeclSeparator, this.sXMLDeclEnding, this.sOpenTag, this.sOpenTagSlash, this.sAttrib, this.sAttribName, this.sAttribNameSawWhite, this.sAttribValue, this.sAttribValueQuoted, this.sAttribValueClosed, this.sAttribValueUnquoted, this.sCloseTag, this.sCloseTagSawWhite];\n\n    this._init();\n  }\n  /**\n   * Indicates whether or not the parser is closed. If ``true``, wait for\n   * the ``ready`` event to write again.\n   */\n\n\n  get closed() {\n    return this._closed;\n  }\n\n  _init() {\n    var _a;\n\n    this.openWakaBang = \"\";\n    this.text = \"\";\n    this.name = \"\";\n    this.piTarget = \"\";\n    this.entity = \"\";\n    this.q = null;\n    this.tags = [];\n    this.tag = null;\n    this.topNS = null;\n    this.chunk = \"\";\n    this.chunkPosition = 0;\n    this.i = 0;\n    this.prevI = 0;\n    this.carriedFromPrevious = undefined;\n    this.forbiddenState = FORBIDDEN_START;\n    this.attribList = []; // The logic is organized so as to minimize the need to check\n    // this.opt.fragment while parsing.\n\n    const {\n      fragmentOpt\n    } = this;\n    this.state = fragmentOpt ? S_TEXT : S_BEGIN; // We want these to be all true if we are dealing with a fragment.\n\n    this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt; // An XML declaration is intially possible only when parsing whole\n    // documents.\n\n    this.xmlDeclPossible = !fragmentOpt;\n    this.xmlDeclExpects = [\"version\"];\n    this.entityReturnState = undefined;\n    let {\n      defaultXMLVersion\n    } = this.opt;\n\n    if (defaultXMLVersion === undefined) {\n      if (this.opt.forceXMLVersion === true) {\n        throw new Error(\"forceXMLVersion set but defaultXMLVersion is not set\");\n      }\n\n      defaultXMLVersion = \"1.0\";\n    }\n\n    this.setXMLVersion(defaultXMLVersion);\n    this.positionAtNewLine = 0;\n    this.doctype = false;\n    this._closed = false;\n    this.xmlDecl = {\n      version: undefined,\n      encoding: undefined,\n      standalone: undefined\n    };\n    this.line = 1;\n    this.column = 0;\n    this.ENTITIES = Object.create(XML_ENTITIES); // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);\n  }\n  /**\n   * The stream position the parser is currently looking at. This field is\n   * zero-based.\n   *\n   * This field is not based on counting Unicode characters but is to be\n   * interpreted as a plain index into a JavaScript string.\n   */\n\n\n  get position() {\n    return this.chunkPosition + this.i;\n  }\n  /**\n   * The column number of the next character to be read by the parser.  *\n   * This field is zero-based. (The first column in a line is 0.)\n   *\n   * This field reports the index at which the next character would be in the\n   * line if the line were represented as a JavaScript string.  Note that this\n   * *can* be different to a count based on the number of *Unicode characters*\n   * due to how JavaScript handles astral plane characters.\n   *\n   * See [[column]] for a number that corresponds to a count of Unicode\n   * characters.\n   */\n\n\n  get columnIndex() {\n    return this.position - this.positionAtNewLine;\n  }\n  /**\n   * Set an event listener on an event. The parser supports one handler per\n   * event type. If you try to set an event handler over an existing handler,\n   * the old handler is silently overwritten.\n   *\n   * @param name The event to listen to.\n   *\n   * @param handler The handler to set.\n   */\n\n\n  on(name, handler) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;\n  }\n  /**\n   * Unset an event handler.\n   *\n   * @parma name The event to stop listening to.\n   */\n\n\n  off(name) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;\n  }\n  /**\n   * Make an error object. The error object will have a message that contains\n   * the ``fileName`` option passed at the creation of the parser. If position\n   * tracking was turned on, it will also have line and column number\n   * information.\n   *\n   * @param message The message describing the error to report.\n   *\n   * @returns An error object with a properly formatted message.\n   */\n\n\n  makeError(message) {\n    var _a;\n\n    let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : \"\";\n\n    if (this.trackPosition) {\n      if (msg.length > 0) {\n        msg += \":\";\n      }\n\n      msg += `${this.line}:${this.column}`;\n    }\n\n    if (msg.length > 0) {\n      msg += \": \";\n    }\n\n    return new Error(msg + message);\n  }\n  /**\n   * Report a parsing error. This method is made public so that client code may\n   * check for issues that are outside the scope of this project and can report\n   * errors.\n   *\n   * @param message The error to report.\n   *\n   * @returns this\n   */\n\n\n  fail(message) {\n    const err = this.makeError(message);\n    const handler = this.errorHandler;\n\n    if (handler === undefined) {\n      throw err;\n    } else {\n      handler(err);\n    }\n\n    return this;\n  }\n  /**\n   * Write a XML data to the parser.\n   *\n   * @param chunk The XML data to write.\n   *\n   * @returns this\n   */\n\n\n  write(chunk) {\n    if (this.closed) {\n      return this.fail(\"cannot write after close; assign an onready handler.\");\n    }\n\n    let end = false;\n\n    if (chunk === null) {\n      // We cannot return immediately because carriedFromPrevious may need\n      // processing.\n      end = true;\n      chunk = \"\";\n    } else if (typeof chunk === \"object\") {\n      chunk = chunk.toString();\n    } // We checked if performing a pre-decomposition of the string into an array\n    // of single complete characters (``Array.from(chunk)``) would be faster\n    // than the current repeated calls to ``charCodeAt``. As of August 2018, it\n    // isn't. (There may be Node-specific code that would perform faster than\n    // ``Array.from`` but don't want to be dependent on Node.)\n\n\n    if (this.carriedFromPrevious !== undefined) {\n      // The previous chunk had char we must carry over.\n      chunk = `${this.carriedFromPrevious}${chunk}`;\n      this.carriedFromPrevious = undefined;\n    }\n\n    let limit = chunk.length;\n    const lastCode = chunk.charCodeAt(limit - 1);\n\n    if (!end && ( // A trailing CR or surrogate must be carried over to the next\n    // chunk.\n    lastCode === CR || lastCode >= 0xD800 && lastCode <= 0xDBFF)) {\n      // The chunk ends with a character that must be carried over. We cannot\n      // know how to handle it until we get the next chunk or the end of the\n      // stream. So save it for later.\n      this.carriedFromPrevious = chunk[limit - 1];\n      limit--;\n      chunk = chunk.slice(0, limit);\n    }\n\n    const {\n      stateTable\n    } = this;\n    this.chunk = chunk;\n    this.i = 0;\n\n    while (this.i < limit) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      stateTable[this.state].call(this);\n    }\n\n    this.chunkPosition += limit;\n    return end ? this.end() : this;\n  }\n  /**\n   * Close the current stream. Perform final well-formedness checks and reset\n   * the parser tstate.\n   *\n   * @returns this\n   */\n\n\n  close() {\n    return this.write(null);\n  }\n  /**\n   * Get a single code point out of the current chunk. This updates the current\n   * position if we do position tracking.\n   *\n   * This is the algorithm to use for XML 1.0.\n   *\n   * @returns The character read.\n   */\n\n\n  getCode10() {\n    const {\n      chunk,\n      i\n    } = this;\n    this.prevI = i; // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n    // read this.i again, which is a bit faster.\n\n    this.i = i + 1;\n\n    if (i >= chunk.length) {\n      return EOC;\n    } // Using charCodeAt and handling the surrogates ourselves is faster\n    // than using codePointAt.\n\n\n    const code = chunk.charCodeAt(i);\n    this.column++;\n\n    if (code < 0xD800) {\n      if (code >= SPACE || code === TAB) {\n        return code;\n      }\n\n      switch (code) {\n        case NL:\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL;\n\n        case CR:\n          // We may get NaN if we read past the end of the chunk, which is fine.\n          if (chunk.charCodeAt(i + 1) === NL) {\n            // A \\r\\n sequence is converted to \\n so we have to skip over the\n            // next character. We already know it has a size of 1 so ++ is fine\n            // here.\n            this.i = i + 2;\n          } // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n          // ahead.\n          // In either case, \\r becomes \\n.\n\n\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL_LIKE;\n\n        default:\n          // If we get here, then code < SPACE and it is not NL CR or TAB.\n          this.fail(\"disallowed character.\");\n          return code;\n      }\n    }\n\n    if (code > 0xDBFF) {\n      // This is a specialized version of isChar10 that takes into account\n      // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not\n      // test cases that don't need testing.\n      if (!(code >= 0xE000 && code <= 0xFFFD)) {\n        this.fail(\"disallowed character.\");\n      }\n\n      return code;\n    }\n\n    const final = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);\n    this.i = i + 2; // This is a specialized version of isChar10 that takes into account that in\n    // this context necessarily final >= 0x10000.\n\n    if (final > 0x10FFFF) {\n      this.fail(\"disallowed character.\");\n    }\n\n    return final;\n  }\n  /**\n   * Get a single code point out of the current chunk. This updates the current\n   * position if we do position tracking.\n   *\n   * This is the algorithm to use for XML 1.1.\n   *\n   * @returns {number} The character read.\n   */\n\n\n  getCode11() {\n    const {\n      chunk,\n      i\n    } = this;\n    this.prevI = i; // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n    // read this.i again, which is a bit faster.\n\n    this.i = i + 1;\n\n    if (i >= chunk.length) {\n      return EOC;\n    } // Using charCodeAt and handling the surrogates ourselves is faster\n    // than using codePointAt.\n\n\n    const code = chunk.charCodeAt(i);\n    this.column++;\n\n    if (code < 0xD800) {\n      if (code > 0x1F && code < 0x7F || code > 0x9F && code !== LS || code === TAB) {\n        return code;\n      }\n\n      switch (code) {\n        case NL:\n          // 0xA\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL;\n\n        case CR:\n          {\n            // 0xD\n            // We may get NaN if we read past the end of the chunk, which is\n            // fine.\n            const next = chunk.charCodeAt(i + 1);\n\n            if (next === NL || next === NEL) {\n              // A CR NL or CR NEL sequence is converted to NL so we have to skip\n              // over the next character. We already know it has a size of 1.\n              this.i = i + 2;\n            } // Otherwise, a CR is just converted to NL, no skip.\n\n          }\n\n        /* yes, fall through */\n\n        case NEL: // 0x85\n\n        case LS:\n          // Ox2028\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL_LIKE;\n\n        default:\n          this.fail(\"disallowed character.\");\n          return code;\n      }\n    }\n\n    if (code > 0xDBFF) {\n      // This is a specialized version of isCharAndNotRestricted that takes into\n      // account that in this context code > 0xDBFF and code <= 0xFFFF. So it\n      // does not test cases that don't need testing.\n      if (!(code >= 0xE000 && code <= 0xFFFD)) {\n        this.fail(\"disallowed character.\");\n      }\n\n      return code;\n    }\n\n    const final = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);\n    this.i = i + 2; // This is a specialized version of isCharAndNotRestricted that takes into\n    // account that in this context necessarily final >= 0x10000.\n\n    if (final > 0x10FFFF) {\n      this.fail(\"disallowed character.\");\n    }\n\n    return final;\n  }\n  /**\n   * Like ``getCode`` but with the return value normalized so that ``NL`` is\n   * returned for ``NL_LIKE``.\n   */\n\n\n  getCodeNorm() {\n    const c = this.getCode();\n    return c === NL_LIKE ? NL : c;\n  }\n\n  unget() {\n    this.i = this.prevI;\n    this.column--;\n  }\n  /**\n   * Capture characters into a buffer until encountering one of a set of\n   * characters.\n   *\n   * @param chars An array of codepoints. Encountering a character in the array\n   * ends the capture. (``chars`` may safely contain ``NL``.)\n   *\n   * @return The character code that made the capture end, or ``EOC`` if we hit\n   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n   * instead.\n   */\n\n\n  captureTo(chars) {\n    let {\n      i: start\n    } = this;\n    const {\n      chunk\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      const c = this.getCode();\n      const isNLLike = c === NL_LIKE;\n      const final = isNLLike ? NL : c;\n\n      if (final === EOC || chars.includes(final)) {\n        this.text += chunk.slice(start, this.prevI);\n        return final;\n      }\n\n      if (isNLLike) {\n        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n        start = this.i;\n      }\n    }\n  }\n  /**\n   * Capture characters into a buffer until encountering a character.\n   *\n   * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT\n   * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.\n   *\n   * @return ``true`` if we ran into the character. Otherwise, we ran into the\n   * end of the current chunk.\n   */\n\n\n  captureToChar(char) {\n    let {\n      i: start\n    } = this;\n    const {\n      chunk\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      let c = this.getCode();\n\n      switch (c) {\n        case NL_LIKE:\n          this.text += `${chunk.slice(start, this.prevI)}\\n`;\n          start = this.i;\n          c = NL;\n          break;\n\n        case EOC:\n          this.text += chunk.slice(start);\n          return false;\n\n        default:\n      }\n\n      if (c === char) {\n        this.text += chunk.slice(start, this.prevI);\n        return true;\n      }\n    }\n  }\n  /**\n   * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n   * this parser.\n   *\n   * @return The character code that made the test fail, or ``EOC`` if we hit\n   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n   * instead.\n   */\n\n\n  captureNameChars() {\n    const {\n      chunk,\n      i: start\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      const c = this.getCode();\n\n      if (c === EOC) {\n        this.name += chunk.slice(start);\n        return EOC;\n      } // NL is not a name char so we don't have to test specifically for it.\n\n\n      if (!isNameChar(c)) {\n        this.name += chunk.slice(start, this.prevI);\n        return c === NL_LIKE ? NL : c;\n      }\n    }\n  }\n  /**\n   * Skip white spaces.\n   *\n   * @return The character that ended the skip, or ``EOC`` if we hit\n   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n   * instead.\n   */\n\n\n  skipSpaces() {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const c = this.getCodeNorm();\n\n      if (c === EOC || !isS(c)) {\n        return c;\n      }\n    }\n  }\n\n  setXMLVersion(version) {\n    this.currentXMLVersion = version;\n    /*  eslint-disable @typescript-eslint/unbound-method */\n\n    if (version === \"1.0\") {\n      this.isChar = isChar10;\n      this.getCode = this.getCode10;\n    } else {\n      this.isChar = isChar11;\n      this.getCode = this.getCode11;\n    }\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n  } // STATE ENGINE METHODS\n  // This needs to be a state separate from S_BEGIN_WHITESPACE because we want\n  // to be sure never to come back to this state later.\n\n\n  sBegin() {\n    // We are essentially peeking at the first character of the chunk. Since\n    // S_BEGIN can be in effect only when we start working on the first chunk,\n    // the index at which we must look is necessarily 0. Note also that the\n    // following test does not depend on decoding surrogates.\n    // If the initial character is 0xFEFF, ignore it.\n    if (this.chunk.charCodeAt(0) === 0xFEFF) {\n      this.i++;\n      this.column++;\n    }\n\n    this.state = S_BEGIN_WHITESPACE;\n  }\n\n  sBeginWhitespace() {\n    // We need to know whether we've encountered spaces or not because as soon\n    // as we run into a space, an XML declaration is no longer possible. Rather\n    // than slow down skipSpaces even in places where we don't care whether it\n    // skipped anything or not, we check whether prevI is equal to the value of\n    // i from before we skip spaces.\n    const iBefore = this.i;\n    const c = this.skipSpaces();\n\n    if (this.prevI !== iBefore) {\n      this.xmlDeclPossible = false;\n    }\n\n    switch (c) {\n      case LESS:\n        this.state = S_OPEN_WAKA; // We could naively call closeText but in this state, it is not normal\n        // to have text be filled with any data.\n\n        if (this.text.length !== 0) {\n          throw new Error(\"no-empty text at start\");\n        }\n\n        break;\n\n      case EOC:\n        break;\n\n      default:\n        this.unget();\n        this.state = S_TEXT;\n        this.xmlDeclPossible = false;\n    }\n  }\n\n  sDoctype() {\n    var _a;\n\n    const c = this.captureTo(DOCTYPE_TERMINATOR);\n\n    switch (c) {\n      case GREATER:\n        {\n          // eslint-disable-next-line no-unused-expressions\n          (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n          this.text = \"\";\n          this.state = S_TEXT;\n          this.doctype = true; // just remember that we saw it.\n\n          break;\n        }\n\n      case EOC:\n        break;\n\n      default:\n        this.text += String.fromCodePoint(c);\n\n        if (c === OPEN_BRACKET) {\n          this.state = S_DTD;\n        } else if (isQuote(c)) {\n          this.state = S_DOCTYPE_QUOTE;\n          this.q = c;\n        }\n\n    }\n  }\n\n  sDoctypeQuote() {\n    const q = this.q;\n\n    if (this.captureToChar(q)) {\n      this.text += String.fromCodePoint(q);\n      this.q = null;\n      this.state = S_DOCTYPE;\n    }\n  }\n\n  sDTD() {\n    const c = this.captureTo(DTD_TERMINATOR);\n\n    if (c === EOC) {\n      return;\n    }\n\n    this.text += String.fromCodePoint(c);\n\n    if (c === CLOSE_BRACKET) {\n      this.state = S_DOCTYPE;\n    } else if (c === LESS) {\n      this.state = S_DTD_OPEN_WAKA;\n    } else if (isQuote(c)) {\n      this.state = S_DTD_QUOTED;\n      this.q = c;\n    }\n  }\n\n  sDTDQuoted() {\n    const q = this.q;\n\n    if (this.captureToChar(q)) {\n      this.text += String.fromCodePoint(q);\n      this.state = S_DTD;\n      this.q = null;\n    }\n  }\n\n  sDTDOpenWaka() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n\n    switch (c) {\n      case BANG:\n        this.state = S_DTD_OPEN_WAKA_BANG;\n        this.openWakaBang = \"\";\n        break;\n\n      case QUESTION:\n        this.state = S_DTD_PI;\n        break;\n\n      default:\n        this.state = S_DTD;\n    }\n  }\n\n  sDTDOpenWakaBang() {\n    const char = String.fromCodePoint(this.getCodeNorm());\n    const owb = this.openWakaBang += char;\n    this.text += char;\n\n    if (owb !== \"-\") {\n      this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n      this.openWakaBang = \"\";\n    }\n  }\n\n  sDTDComment() {\n    if (this.captureToChar(MINUS)) {\n      this.text += \"-\";\n      this.state = S_DTD_COMMENT_ENDING;\n    }\n  }\n\n  sDTDCommentEnding() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n    this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n  }\n\n  sDTDCommentEnded() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n\n    if (c === GREATER) {\n      this.state = S_DTD;\n    } else {\n      this.fail(\"malformed comment.\"); // <!-- blah -- bloo --> will be recorded as\n      // a comment of \" blah -- bloo \"\n\n      this.state = S_DTD_COMMENT;\n    }\n  }\n\n  sDTDPI() {\n    if (this.captureToChar(QUESTION)) {\n      this.text += \"?\";\n      this.state = S_DTD_PI_ENDING;\n    }\n  }\n\n  sDTDPIEnding() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n\n    if (c === GREATER) {\n      this.state = S_DTD;\n    }\n  }\n\n  sText() {\n    //\n    // We did try a version of saxes where the S_TEXT state was split in two\n    // states: one for text inside the root element, and one for text\n    // outside. This was avoiding having to test this.tags.length to decide\n    // what implementation to actually use.\n    //\n    // Peformance testing on gigabyte-size files did not show any advantage to\n    // using the two states solution instead of the current one. Conversely, it\n    // made the code a bit more complicated elsewhere. For instance, a comment\n    // can appear before the root element so when a comment ended it was\n    // necessary to determine whether to return to the S_TEXT state or to the\n    // new text-outside-root state.\n    //\n    if (this.tags.length !== 0) {\n      this.handleTextInRoot();\n    } else {\n      this.handleTextOutsideRoot();\n    }\n  }\n\n  sEntity() {\n    // This is essentially a specialized version of captureToChar(SEMICOLON...)\n    let {\n      i: start\n    } = this;\n    const {\n      chunk\n    } = this; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n    loop: // eslint-disable-next-line no-constant-condition\n    while (true) {\n      switch (this.getCode()) {\n        case NL_LIKE:\n          this.entity += `${chunk.slice(start, this.prevI)}\\n`;\n          start = this.i;\n          break;\n\n        case SEMICOLON:\n          {\n            const {\n              entityReturnState\n            } = this;\n            const entity = this.entity + chunk.slice(start, this.prevI);\n            this.state = entityReturnState;\n            let parsed;\n\n            if (entity === \"\") {\n              this.fail(\"empty entity name.\");\n              parsed = \"&;\";\n            } else {\n              parsed = this.parseEntity(entity);\n              this.entity = \"\";\n            }\n\n            if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {\n              this.text += parsed;\n            } // eslint-disable-next-line no-labels\n\n\n            break loop;\n          }\n\n        case EOC:\n          this.entity += chunk.slice(start); // eslint-disable-next-line no-labels\n\n          break loop;\n\n        default:\n      }\n    }\n  }\n\n  sOpenWaka() {\n    // Reminder: a state handler is called with at least one character\n    // available in the current chunk. So the first call to get code inside of\n    // a state handler cannot return ``EOC``. That's why we don't test\n    // for it.\n    const c = this.getCode(); // either a /, ?, !, or text is coming next.\n\n    if (isNameStartChar(c)) {\n      this.state = S_OPEN_TAG;\n      this.unget();\n      this.xmlDeclPossible = false;\n    } else {\n      switch (c) {\n        case FORWARD_SLASH:\n          this.state = S_CLOSE_TAG;\n          this.xmlDeclPossible = false;\n          break;\n\n        case BANG:\n          this.state = S_OPEN_WAKA_BANG;\n          this.openWakaBang = \"\";\n          this.xmlDeclPossible = false;\n          break;\n\n        case QUESTION:\n          this.state = S_PI_FIRST_CHAR;\n          break;\n\n        default:\n          this.fail(\"disallowed character in tag name\");\n          this.state = S_TEXT;\n          this.xmlDeclPossible = false;\n      }\n    }\n  }\n\n  sOpenWakaBang() {\n    this.openWakaBang += String.fromCodePoint(this.getCodeNorm());\n\n    switch (this.openWakaBang) {\n      case \"[CDATA[\":\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextBeforeRoot = true;\n        }\n\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextAfterRoot = true;\n        }\n\n        this.state = S_CDATA;\n        this.openWakaBang = \"\";\n        break;\n\n      case \"--\":\n        this.state = S_COMMENT;\n        this.openWakaBang = \"\";\n        break;\n\n      case \"DOCTYPE\":\n        this.state = S_DOCTYPE;\n\n        if (this.doctype || this.sawRoot) {\n          this.fail(\"inappropriately located doctype declaration.\");\n        }\n\n        this.openWakaBang = \"\";\n        break;\n\n      default:\n        // 7 happens to be the maximum length of the string that can possibly\n        // match one of the cases above.\n        if (this.openWakaBang.length >= 7) {\n          this.fail(\"incorrect syntax.\");\n        }\n\n    }\n  }\n\n  sComment() {\n    if (this.captureToChar(MINUS)) {\n      this.state = S_COMMENT_ENDING;\n    }\n  }\n\n  sCommentEnding() {\n    var _a;\n\n    const c = this.getCodeNorm();\n\n    if (c === MINUS) {\n      this.state = S_COMMENT_ENDED; // eslint-disable-next-line no-unused-expressions\n\n      (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n      this.text = \"\";\n    } else {\n      this.text += `-${String.fromCodePoint(c)}`;\n      this.state = S_COMMENT;\n    }\n  }\n\n  sCommentEnded() {\n    const c = this.getCodeNorm();\n\n    if (c !== GREATER) {\n      this.fail(\"malformed comment.\"); // <!-- blah -- bloo --> will be recorded as\n      // a comment of \" blah -- bloo \"\n\n      this.text += `--${String.fromCodePoint(c)}`;\n      this.state = S_COMMENT;\n    } else {\n      this.state = S_TEXT;\n    }\n  }\n\n  sCData() {\n    if (this.captureToChar(CLOSE_BRACKET)) {\n      this.state = S_CDATA_ENDING;\n    }\n  }\n\n  sCDataEnding() {\n    const c = this.getCodeNorm();\n\n    if (c === CLOSE_BRACKET) {\n      this.state = S_CDATA_ENDING_2;\n    } else {\n      this.text += `]${String.fromCodePoint(c)}`;\n      this.state = S_CDATA;\n    }\n  }\n\n  sCDataEnding2() {\n    var _a;\n\n    const c = this.getCodeNorm();\n\n    switch (c) {\n      case GREATER:\n        {\n          // eslint-disable-next-line no-unused-expressions\n          (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n          this.text = \"\";\n          this.state = S_TEXT;\n          break;\n        }\n\n      case CLOSE_BRACKET:\n        this.text += \"]\";\n        break;\n\n      default:\n        this.text += `]]${String.fromCodePoint(c)}`;\n        this.state = S_CDATA;\n    }\n  } // We need this separate state to check the first character fo the pi target\n  // with this.nameStartCheck which allows less characters than this.nameCheck.\n\n\n  sPIFirstChar() {\n    const c = this.getCodeNorm(); // This is first because in the case where the file is well-formed this is\n    // the branch taken. We optimize for well-formedness.\n\n    if (this.nameStartCheck(c)) {\n      this.piTarget += String.fromCodePoint(c);\n      this.state = S_PI_REST;\n    } else if (c === QUESTION || isS(c)) {\n      this.fail(\"processing instruction without a target.\");\n      this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n    } else {\n      this.fail(\"disallowed character in processing instruction name.\");\n      this.piTarget += String.fromCodePoint(c);\n      this.state = S_PI_REST;\n    }\n  }\n\n  sPIRest() {\n    // Capture characters into a piTarget while ``this.nameCheck`` run on the\n    // character read returns true.\n    const {\n      chunk,\n      i: start\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      const c = this.getCodeNorm();\n\n      if (c === EOC) {\n        this.piTarget += chunk.slice(start);\n        return;\n      } // NL cannot satisfy this.nameCheck so we don't have to test specifically\n      // for it.\n\n\n      if (!this.nameCheck(c)) {\n        this.piTarget += chunk.slice(start, this.prevI);\n        const isQuestion = c === QUESTION;\n\n        if (isQuestion || isS(c)) {\n          if (this.piTarget === \"xml\") {\n            if (!this.xmlDeclPossible) {\n              this.fail(\"an XML declaration must be at the start of the document.\");\n            }\n\n            this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;\n          } else {\n            this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;\n          }\n        } else {\n          this.fail(\"disallowed character in processing instruction name.\");\n          this.piTarget += String.fromCodePoint(c);\n        }\n\n        break;\n      }\n    }\n  }\n\n  sPIBody() {\n    if (this.text.length === 0) {\n      const c = this.getCodeNorm();\n\n      if (c === QUESTION) {\n        this.state = S_PI_ENDING;\n      } else if (!isS(c)) {\n        this.text = String.fromCodePoint(c);\n      }\n    } // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n    else if (this.captureToChar(QUESTION)) {\n        this.state = S_PI_ENDING;\n      }\n  }\n\n  sPIEnding() {\n    var _a;\n\n    const c = this.getCodeNorm();\n\n    if (c === GREATER) {\n      const {\n        piTarget\n      } = this;\n\n      if (piTarget.toLowerCase() === \"xml\") {\n        this.fail(\"the XML declaration must appear at the start of the document.\");\n      } // eslint-disable-next-line no-unused-expressions\n\n\n      (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {\n        target: piTarget,\n        body: this.text\n      });\n      this.piTarget = this.text = \"\";\n      this.state = S_TEXT;\n    } else if (c === QUESTION) {\n      // We ran into ?? as part of a processing instruction. We initially took\n      // the first ? as a sign that the PI was ending, but it is not. So we have\n      // to add it to the body but we take the new ? as a sign that the PI is\n      // ending.\n      this.text += \"?\";\n    } else {\n      this.text += `?${String.fromCodePoint(c)}`;\n      this.state = S_PI_BODY;\n    }\n\n    this.xmlDeclPossible = false;\n  }\n\n  sXMLDeclNameStart() {\n    const c = this.skipSpaces(); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      // It is valid to go to S_XML_DECL_ENDING from this state.\n      this.state = S_XML_DECL_ENDING;\n      return;\n    }\n\n    if (c !== EOC) {\n      this.state = S_XML_DECL_NAME;\n      this.name = String.fromCodePoint(c);\n    }\n  }\n\n  sXMLDeclName() {\n    const c = this.captureTo(XML_DECL_NAME_TERMINATOR); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.name += this.text;\n      this.text = \"\";\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n\n    if (!(isS(c) || c === EQUAL)) {\n      return;\n    }\n\n    this.name += this.text;\n    this.text = \"\";\n\n    if (!this.xmlDeclExpects.includes(this.name)) {\n      switch (this.name.length) {\n        case 0:\n          this.fail(\"did not expect any more name/value pairs.\");\n          break;\n\n        case 1:\n          this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n          break;\n\n        default:\n          this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n      }\n    }\n\n    this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n  }\n\n  sXMLDeclEq() {\n    const c = this.getCodeNorm(); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n\n    if (isS(c)) {\n      return;\n    }\n\n    if (c !== EQUAL) {\n      this.fail(\"value required.\");\n    }\n\n    this.state = S_XML_DECL_VALUE_START;\n  }\n\n  sXMLDeclValueStart() {\n    const c = this.getCodeNorm(); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n\n    if (isS(c)) {\n      return;\n    }\n\n    if (!isQuote(c)) {\n      this.fail(\"value must be quoted.\");\n      this.q = SPACE;\n    } else {\n      this.q = c;\n    }\n\n    this.state = S_XML_DECL_VALUE;\n  }\n\n  sXMLDeclValue() {\n    const c = this.captureTo([this.q, QUESTION]); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.text = \"\";\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n\n    if (c === EOC) {\n      return;\n    }\n\n    const value = this.text;\n    this.text = \"\";\n\n    switch (this.name) {\n      case \"version\":\n        {\n          this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n          const version = value;\n          this.xmlDecl.version = version; // This is the test specified by XML 1.0 but it is fine for XML 1.1.\n\n          if (!/^1\\.[0-9]+$/.test(version)) {\n            this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n          } // When forceXMLVersion is set, the XML declaration is ignored.\n          else if (!this.opt.forceXMLVersion) {\n              this.setXMLVersion(version);\n            }\n\n          break;\n        }\n\n      case \"encoding\":\n        if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {\n          this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n        }\n\n        this.xmlDeclExpects = [\"standalone\"];\n        this.xmlDecl.encoding = value;\n        break;\n\n      case \"standalone\":\n        if (value !== \"yes\" && value !== \"no\") {\n          this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n        }\n\n        this.xmlDeclExpects = [];\n        this.xmlDecl.standalone = value;\n        break;\n\n      default: // We don't need to raise an error here since we've already raised one\n      // when checking what name was expected.\n\n    }\n\n    this.name = \"\";\n    this.state = S_XML_DECL_SEPARATOR;\n  }\n\n  sXMLDeclSeparator() {\n    const c = this.getCodeNorm(); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      // It is valid to go to S_XML_DECL_ENDING from this state.\n      this.state = S_XML_DECL_ENDING;\n      return;\n    }\n\n    if (!isS(c)) {\n      this.fail(\"whitespace required.\");\n      this.unget();\n    }\n\n    this.state = S_XML_DECL_NAME_START;\n  }\n\n  sXMLDeclEnding() {\n    var _a;\n\n    const c = this.getCodeNorm();\n\n    if (c === GREATER) {\n      if (this.piTarget !== \"xml\") {\n        this.fail(\"processing instructions are not allowed before root.\");\n      } else if (this.name !== \"version\" && this.xmlDeclExpects.includes(\"version\")) {\n        this.fail(\"XML declaration must contain a version.\");\n      } // eslint-disable-next-line no-unused-expressions\n\n\n      (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);\n      this.name = \"\";\n      this.piTarget = this.text = \"\";\n      this.state = S_TEXT;\n    } else {\n      // We got here because the previous character was a ?, but the question\n      // mark character is not valid inside any of the XML declaration\n      // name/value pairs.\n      this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n    }\n\n    this.xmlDeclPossible = false;\n  }\n\n  sOpenTag() {\n    var _a;\n\n    const c = this.captureNameChars();\n\n    if (c === EOC) {\n      return;\n    }\n\n    const tag = this.tag = {\n      name: this.name,\n      attributes: Object.create(null)\n    };\n    this.name = \"\";\n\n    if (this.xmlnsOpt) {\n      this.topNS = tag.ns = Object.create(null);\n    } // eslint-disable-next-line no-unused-expressions\n\n\n    (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n    this.sawRoot = true;\n\n    if (!this.fragmentOpt && this.closedRoot) {\n      this.fail(\"documents may contain only one root.\");\n    }\n\n    switch (c) {\n      case GREATER:\n        this.openTag();\n        break;\n\n      case FORWARD_SLASH:\n        this.state = S_OPEN_TAG_SLASH;\n        break;\n\n      default:\n        if (!isS(c)) {\n          this.fail(\"disallowed character in tag name.\");\n        }\n\n        this.state = S_ATTRIB;\n    }\n  }\n\n  sOpenTagSlash() {\n    if (this.getCode() === GREATER) {\n      this.openSelfClosingTag();\n    } else {\n      this.fail(\"forward-slash in opening tag not followed by >.\");\n      this.state = S_ATTRIB;\n    }\n  }\n\n  sAttrib() {\n    const c = this.skipSpaces();\n\n    if (c === EOC) {\n      return;\n    }\n\n    if (isNameStartChar(c)) {\n      this.unget();\n      this.state = S_ATTRIB_NAME;\n    } else if (c === GREATER) {\n      this.openTag();\n    } else if (c === FORWARD_SLASH) {\n      this.state = S_OPEN_TAG_SLASH;\n    } else {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n\n  sAttribName() {\n    const c = this.captureNameChars();\n\n    if (c === EQUAL) {\n      this.state = S_ATTRIB_VALUE;\n    } else if (isS(c)) {\n      this.state = S_ATTRIB_NAME_SAW_WHITE;\n    } else if (c === GREATER) {\n      this.fail(\"attribute without value.\");\n      this.pushAttrib(this.name, this.name);\n      this.name = this.text = \"\";\n      this.openTag();\n    } else if (c !== EOC) {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n\n  sAttribNameSawWhite() {\n    const c = this.skipSpaces();\n\n    switch (c) {\n      case EOC:\n        return;\n\n      case EQUAL:\n        this.state = S_ATTRIB_VALUE;\n        break;\n\n      default:\n        this.fail(\"attribute without value.\"); // Should we do this???\n        // this.tag.attributes[this.name] = \"\";\n\n        this.text = \"\";\n        this.name = \"\";\n\n        if (c === GREATER) {\n          this.openTag();\n        } else if (isNameStartChar(c)) {\n          this.unget();\n          this.state = S_ATTRIB_NAME;\n        } else {\n          this.fail(\"disallowed character in attribute name.\");\n          this.state = S_ATTRIB;\n        }\n\n    }\n  }\n\n  sAttribValue() {\n    const c = this.getCodeNorm();\n\n    if (isQuote(c)) {\n      this.q = c;\n      this.state = S_ATTRIB_VALUE_QUOTED;\n    } else if (!isS(c)) {\n      this.fail(\"unquoted attribute value.\");\n      this.state = S_ATTRIB_VALUE_UNQUOTED;\n      this.unget();\n    }\n  }\n\n  sAttribValueQuoted() {\n    // We deliberately do not use captureTo here. The specialized code we use\n    // here is faster than using captureTo.\n    const {\n      q,\n      chunk\n    } = this;\n    let {\n      i: start\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      switch (this.getCode()) {\n        case q:\n          this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));\n          this.name = this.text = \"\";\n          this.q = null;\n          this.state = S_ATTRIB_VALUE_CLOSED;\n          return;\n\n        case AMP:\n          this.text += chunk.slice(start, this.prevI);\n          this.state = S_ENTITY;\n          this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n          return;\n\n        case NL:\n        case NL_LIKE:\n        case TAB:\n          this.text += `${chunk.slice(start, this.prevI)} `;\n          start = this.i;\n          break;\n\n        case LESS:\n          this.text += chunk.slice(start, this.prevI);\n          this.fail(\"disallowed character.\");\n          return;\n\n        case EOC:\n          this.text += chunk.slice(start);\n          return;\n\n        default:\n      }\n    }\n  }\n\n  sAttribValueClosed() {\n    const c = this.getCodeNorm();\n\n    if (isS(c)) {\n      this.state = S_ATTRIB;\n    } else if (c === GREATER) {\n      this.openTag();\n    } else if (c === FORWARD_SLASH) {\n      this.state = S_OPEN_TAG_SLASH;\n    } else if (isNameStartChar(c)) {\n      this.fail(\"no whitespace between attributes.\");\n      this.unget();\n      this.state = S_ATTRIB_NAME;\n    } else {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n\n  sAttribValueUnquoted() {\n    // We don't do anything regarding EOL or space handling for unquoted\n    // attributes. We already have failed by the time we get here, and the\n    // contract that saxes upholds states that upon failure, it is not safe to\n    // rely on the data passed to event handlers (other than\n    // ``onerror``). Passing \"bad\" data is not a problem.\n    const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);\n\n    switch (c) {\n      case AMP:\n        this.state = S_ENTITY;\n        this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n        break;\n\n      case LESS:\n        this.fail(\"disallowed character.\");\n        break;\n\n      case EOC:\n        break;\n\n      default:\n        if (this.text.includes(\"]]>\")) {\n          this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n        }\n\n        this.pushAttrib(this.name, this.text);\n        this.name = this.text = \"\";\n\n        if (c === GREATER) {\n          this.openTag();\n        } else {\n          this.state = S_ATTRIB;\n        }\n\n    }\n  }\n\n  sCloseTag() {\n    const c = this.captureNameChars();\n\n    if (c === GREATER) {\n      this.closeTag();\n    } else if (isS(c)) {\n      this.state = S_CLOSE_TAG_SAW_WHITE;\n    } else if (c !== EOC) {\n      this.fail(\"disallowed character in closing tag.\");\n    }\n  }\n\n  sCloseTagSawWhite() {\n    switch (this.skipSpaces()) {\n      case GREATER:\n        this.closeTag();\n        break;\n\n      case EOC:\n        break;\n\n      default:\n        this.fail(\"disallowed character in closing tag.\");\n    }\n  } // END OF STATE ENGINE METHODS\n\n\n  handleTextInRoot() {\n    // This is essentially a specialized version of captureTo which is optimized\n    // for performing the ]]> check. A previous version of this code, checked\n    // ``this.text`` for the presence of ]]>. It simplified the code but was\n    // very costly when character data contained a lot of entities to be parsed.\n    //\n    // Since we are using a specialized loop, we also keep track of the presence\n    // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n    //\n    let {\n      i: start,\n      forbiddenState\n    } = this;\n    const {\n      chunk,\n      textHandler: handler\n    } = this; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n    scanLoop: // eslint-disable-next-line no-constant-condition\n    while (true) {\n      switch (this.getCode()) {\n        case LESS:\n          {\n            this.state = S_OPEN_WAKA;\n\n            if (handler !== undefined) {\n              const {\n                text\n              } = this;\n              const slice = chunk.slice(start, this.prevI);\n\n              if (text.length !== 0) {\n                handler(text + slice);\n                this.text = \"\";\n              } else if (slice.length !== 0) {\n                handler(slice);\n              }\n            }\n\n            forbiddenState = FORBIDDEN_START; // eslint-disable-next-line no-labels\n\n            break scanLoop;\n          }\n\n        case AMP:\n          this.state = S_ENTITY;\n          this.entityReturnState = S_TEXT;\n\n          if (handler !== undefined) {\n            this.text += chunk.slice(start, this.prevI);\n          }\n\n          forbiddenState = FORBIDDEN_START; // eslint-disable-next-line no-labels\n\n          break scanLoop;\n\n        case CLOSE_BRACKET:\n          switch (forbiddenState) {\n            case FORBIDDEN_START:\n              forbiddenState = FORBIDDEN_BRACKET;\n              break;\n\n            case FORBIDDEN_BRACKET:\n              forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n              break;\n\n            case FORBIDDEN_BRACKET_BRACKET:\n              break;\n\n            default:\n              throw new Error(\"impossible state\");\n          }\n\n          break;\n\n        case GREATER:\n          if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n            this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n          }\n\n          forbiddenState = FORBIDDEN_START;\n          break;\n\n        case NL_LIKE:\n          if (handler !== undefined) {\n            this.text += `${chunk.slice(start, this.prevI)}\\n`;\n          }\n\n          start = this.i;\n          forbiddenState = FORBIDDEN_START;\n          break;\n\n        case EOC:\n          if (handler !== undefined) {\n            this.text += chunk.slice(start);\n          } // eslint-disable-next-line no-labels\n\n\n          break scanLoop;\n\n        default:\n          forbiddenState = FORBIDDEN_START;\n      }\n    }\n\n    this.forbiddenState = forbiddenState;\n  }\n\n  handleTextOutsideRoot() {\n    // This is essentially a specialized version of captureTo which is optimized\n    // for a specialized task. We keep track of the presence of non-space\n    // characters in the text since these are errors when appearing outside the\n    // document root element.\n    let {\n      i: start\n    } = this;\n    const {\n      chunk,\n      textHandler: handler\n    } = this;\n    let nonSpace = false; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n    outRootLoop: // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const code = this.getCode();\n\n      switch (code) {\n        case LESS:\n          {\n            this.state = S_OPEN_WAKA;\n\n            if (handler !== undefined) {\n              const {\n                text\n              } = this;\n              const slice = chunk.slice(start, this.prevI);\n\n              if (text.length !== 0) {\n                handler(text + slice);\n                this.text = \"\";\n              } else if (slice.length !== 0) {\n                handler(slice);\n              }\n            } // eslint-disable-next-line no-labels\n\n\n            break outRootLoop;\n          }\n\n        case AMP:\n          this.state = S_ENTITY;\n          this.entityReturnState = S_TEXT;\n\n          if (handler !== undefined) {\n            this.text += chunk.slice(start, this.prevI);\n          }\n\n          nonSpace = true; // eslint-disable-next-line no-labels\n\n          break outRootLoop;\n\n        case NL_LIKE:\n          if (handler !== undefined) {\n            this.text += `${chunk.slice(start, this.prevI)}\\n`;\n          }\n\n          start = this.i;\n          break;\n\n        case EOC:\n          if (handler !== undefined) {\n            this.text += chunk.slice(start);\n          } // eslint-disable-next-line no-labels\n\n\n          break outRootLoop;\n\n        default:\n          if (!isS(code)) {\n            nonSpace = true;\n          }\n\n      }\n    }\n\n    if (!nonSpace) {\n      return;\n    } // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n    // to avoid reporting errors for every single character that is out of\n    // place.\n\n\n    if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n      this.fail(\"text data outside of root node.\");\n      this.reportedTextBeforeRoot = true;\n    }\n\n    if (this.closedRoot && !this.reportedTextAfterRoot) {\n      this.fail(\"text data outside of root node.\");\n      this.reportedTextAfterRoot = true;\n    }\n  }\n\n  pushAttribNS(name, value) {\n    var _a;\n\n    const {\n      prefix,\n      local\n    } = this.qname(name);\n    const attr = {\n      name,\n      prefix,\n      local,\n      value\n    };\n    this.attribList.push(attr); // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n\n    if (prefix === \"xmlns\") {\n      const trimmed = value.trim();\n\n      if (this.currentXMLVersion === \"1.0\" && trimmed === \"\") {\n        this.fail(\"invalid attempt to undefine prefix in XML 1.0\");\n      }\n\n      this.topNS[local] = trimmed;\n      nsPairCheck(this, local, trimmed);\n    } else if (name === \"xmlns\") {\n      const trimmed = value.trim();\n      this.topNS[\"\"] = trimmed;\n      nsPairCheck(this, \"\", trimmed);\n    }\n  }\n\n  pushAttribPlain(name, value) {\n    var _a;\n\n    const attr = {\n      name,\n      value\n    };\n    this.attribList.push(attr); // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n  }\n  /**\n   * End parsing. This performs final well-formedness checks and resets the\n   * parser to a clean state.\n   *\n   * @returns this\n   */\n\n\n  end() {\n    var _a, _b;\n\n    if (!this.sawRoot) {\n      this.fail(\"document must contain a root element.\");\n    }\n\n    const {\n      tags\n    } = this;\n\n    while (tags.length > 0) {\n      const tag = tags.pop();\n      this.fail(`unclosed tag: ${tag.name}`);\n    }\n\n    if (this.state !== S_BEGIN && this.state !== S_TEXT) {\n      this.fail(\"unexpected end.\");\n    }\n\n    const {\n      text\n    } = this;\n\n    if (text.length !== 0) {\n      // eslint-disable-next-line no-unused-expressions\n      (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);\n      this.text = \"\";\n    }\n\n    this._closed = true; // eslint-disable-next-line no-unused-expressions\n\n    (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);\n\n    this._init();\n\n    return this;\n  }\n  /**\n   * Resolve a namespace prefix.\n   *\n   * @param prefix The prefix to resolve.\n   *\n   * @returns The namespace URI or ``undefined`` if the prefix is not defined.\n   */\n\n\n  resolve(prefix) {\n    var _a, _b;\n\n    let uri = this.topNS[prefix];\n\n    if (uri !== undefined) {\n      return uri;\n    }\n\n    const {\n      tags\n    } = this;\n\n    for (let index = tags.length - 1; index >= 0; index--) {\n      uri = tags[index].ns[prefix];\n\n      if (uri !== undefined) {\n        return uri;\n      }\n    }\n\n    uri = this.ns[prefix];\n\n    if (uri !== undefined) {\n      return uri;\n    }\n\n    return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);\n  }\n  /**\n   * Parse a qname into its prefix and local name parts.\n   *\n   * @param name The name to parse\n   *\n   * @returns\n   */\n\n\n  qname(name) {\n    // This is faster than using name.split(\":\").\n    const colon = name.indexOf(\":\");\n\n    if (colon === -1) {\n      return {\n        prefix: \"\",\n        local: name\n      };\n    }\n\n    const local = name.slice(colon + 1);\n    const prefix = name.slice(0, colon);\n\n    if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n      this.fail(`malformed name: ${name}.`);\n    }\n\n    return {\n      prefix,\n      local\n    };\n  }\n\n  processAttribsNS() {\n    var _a;\n\n    const {\n      attribList\n    } = this;\n    const tag = this.tag;\n    {\n      // add namespace info to tag\n      const {\n        prefix,\n        local\n      } = this.qname(tag.name);\n      tag.prefix = prefix;\n      tag.local = local;\n      const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : \"\";\n\n      if (prefix !== \"\") {\n        if (prefix === \"xmlns\") {\n          this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n        }\n\n        if (uri === \"\") {\n          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n          tag.uri = prefix;\n        }\n      }\n    }\n\n    if (attribList.length === 0) {\n      return;\n    }\n\n    const {\n      attributes\n    } = tag;\n    const seen = new Set(); // Note: do not apply default ns to attributes:\n    //   http://www.w3.org/TR/REC-xml-names/#defaulting\n\n    for (const attr of attribList) {\n      const {\n        name,\n        prefix,\n        local\n      } = attr;\n      let uri;\n      let eqname;\n\n      if (prefix === \"\") {\n        uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n        eqname = name;\n      } else {\n        uri = this.resolve(prefix); // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n\n        if (uri === undefined) {\n          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n          uri = prefix;\n        }\n\n        eqname = `{${uri}}${local}`;\n      }\n\n      if (seen.has(eqname)) {\n        this.fail(`duplicate attribute: ${eqname}.`);\n      }\n\n      seen.add(eqname);\n      attr.uri = uri;\n      attributes[name] = attr;\n    }\n\n    this.attribList = [];\n  }\n\n  processAttribsPlain() {\n    const {\n      attribList\n    } = this; // eslint-disable-next-line prefer-destructuring\n\n    const attributes = this.tag.attributes;\n\n    for (const {\n      name,\n      value\n    } of attribList) {\n      if (attributes[name] !== undefined) {\n        this.fail(`duplicate attribute: ${name}.`);\n      }\n\n      attributes[name] = value;\n    }\n\n    this.attribList = [];\n  }\n  /**\n   * Handle a complete open tag. This parser code calls this once it has seen\n   * the whole tag. This method checks for well-formeness and then emits\n   * ``onopentag``.\n   */\n\n\n  openTag() {\n    var _a;\n\n    this.processAttribs();\n    const {\n      tags\n    } = this;\n    const tag = this.tag;\n    tag.isSelfClosing = false; // There cannot be any pending text here due to the onopentagstart that was\n    // necessarily emitted before we get here. So we do not check text.\n    // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n    tags.push(tag);\n    this.state = S_TEXT;\n    this.name = \"\";\n  }\n  /**\n   * Handle a complete self-closing tag. This parser code calls this once it has\n   * seen the whole tag. This method checks for well-formeness and then emits\n   * ``onopentag`` and ``onclosetag``.\n   */\n\n\n  openSelfClosingTag() {\n    var _a, _b, _c;\n\n    this.processAttribs();\n    const {\n      tags\n    } = this;\n    const tag = this.tag;\n    tag.isSelfClosing = true; // There cannot be any pending text here due to the onopentagstart that was\n    // necessarily emitted before we get here. So we do not check text.\n    // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag); // eslint-disable-next-line no-unused-expressions\n\n    (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);\n    const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;\n\n    if (top === null) {\n      this.closedRoot = true;\n    }\n\n    this.state = S_TEXT;\n    this.name = \"\";\n  }\n  /**\n   * Handle a complete close tag. This parser code calls this once it has seen\n   * the whole tag. This method checks for well-formeness and then emits\n   * ``onclosetag``.\n   */\n\n\n  closeTag() {\n    const {\n      tags,\n      name\n    } = this; // Our state after this will be S_TEXT, no matter what, and we can clear\n    // tagName now.\n\n    this.state = S_TEXT;\n    this.name = \"\";\n\n    if (name === \"\") {\n      this.fail(\"weird empty close tag.\");\n      this.text += \"</>\";\n      return;\n    }\n\n    const handler = this.closeTagHandler;\n    let l = tags.length;\n\n    while (l-- > 0) {\n      const tag = this.tag = tags.pop();\n      this.topNS = tag.ns; // eslint-disable-next-line no-unused-expressions\n\n      handler === null || handler === void 0 ? void 0 : handler(tag);\n\n      if (tag.name === name) {\n        break;\n      }\n\n      this.fail(\"unexpected close tag.\");\n    }\n\n    if (l === 0) {\n      this.closedRoot = true;\n    } else if (l < 0) {\n      this.fail(`unmatched closing tag: ${name}.`);\n      this.text += `</${name}>`;\n    }\n  }\n  /**\n   * Resolves an entity. Makes any necessary well-formedness checks.\n   *\n   * @param entity The entity to resolve.\n   *\n   * @returns The parsed entity.\n   */\n\n\n  parseEntity(entity) {\n    // startsWith would be significantly slower for this test.\n    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n    if (entity[0] !== \"#\") {\n      const defined = this.ENTITIES[entity];\n\n      if (defined !== undefined) {\n        return defined;\n      }\n\n      this.fail(this.isName(entity) ? \"undefined entity.\" : \"disallowed character in entity name.\");\n      return `&${entity};`;\n    }\n\n    let num = NaN;\n\n    if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n      num = parseInt(entity.slice(2), 16);\n    } else if (/^#[0-9]+$/.test(entity)) {\n      num = parseInt(entity.slice(1), 10);\n    } // The character reference is required to match the CHAR production.\n\n\n    if (!this.isChar(num)) {\n      this.fail(\"malformed character entity.\");\n      return `&${entity};`;\n    }\n\n    return String.fromCodePoint(num);\n  }\n\n}\n\nexports.SaxesParser = SaxesParser;","map":{"version":3,"sources":["../../src/saxes.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ed5 = require(\"xmlchars/xml/1.0/ed5\");\nconst ed2 = require(\"xmlchars/xml/1.1/ed2\");\nconst NSed3 = require(\"xmlchars/xmlns/1.0/ed3\");\nvar isS = ed5.isS;\nvar isChar10 = ed5.isChar;\nvar isNameStartChar = ed5.isNameStartChar;\nvar isNameChar = ed5.isNameChar;\nvar S_LIST = ed5.S_LIST;\nvar NAME_RE = ed5.NAME_RE;\nvar isChar11 = ed2.isChar;\nvar isNCNameStartChar = NSed3.isNCNameStartChar;\nvar isNCNameChar = NSed3.isNCNameChar;\nvar NC_NAME_RE = NSed3.NC_NAME_RE;\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nconst rootNS = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    __proto__: null,\n    xml: XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE,\n};\nconst XML_ENTITIES = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    __proto__: null,\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: \"\\\"\",\n    apos: \"'\",\n};\n// EOC: end-of-chunk\nconst EOC = -1;\nconst NL_LIKE = -2;\nconst S_BEGIN = 0; // Initial state.\nconst S_BEGIN_WHITESPACE = 1; // leading whitespace\nconst S_DOCTYPE = 2; // <!DOCTYPE\nconst S_DOCTYPE_QUOTE = 3; // <!DOCTYPE \"//blah\nconst S_DTD = 4; // <!DOCTYPE \"//blah\" [ ...\nconst S_DTD_QUOTED = 5; // <!DOCTYPE \"//blah\" [ \"foo\nconst S_DTD_OPEN_WAKA = 6;\nconst S_DTD_OPEN_WAKA_BANG = 7;\nconst S_DTD_COMMENT = 8; // <!--\nconst S_DTD_COMMENT_ENDING = 9; // <!-- blah -\nconst S_DTD_COMMENT_ENDED = 10; // <!-- blah --\nconst S_DTD_PI = 11; // <?\nconst S_DTD_PI_ENDING = 12; // <?hi \"there\" ?\nconst S_TEXT = 13; // general stuff\nconst S_ENTITY = 14; // &amp and such\nconst S_OPEN_WAKA = 15; // <\nconst S_OPEN_WAKA_BANG = 16; // <!...\nconst S_COMMENT = 17; // <!--\nconst S_COMMENT_ENDING = 18; // <!-- blah -\nconst S_COMMENT_ENDED = 19; // <!-- blah --\nconst S_CDATA = 20; // <![CDATA[ something\nconst S_CDATA_ENDING = 21; // ]\nconst S_CDATA_ENDING_2 = 22; // ]]\nconst S_PI_FIRST_CHAR = 23; // <?hi, first char\nconst S_PI_REST = 24; // <?hi, rest of the name\nconst S_PI_BODY = 25; // <?hi there\nconst S_PI_ENDING = 26; // <?hi \"there\" ?\nconst S_XML_DECL_NAME_START = 27; // <?xml\nconst S_XML_DECL_NAME = 28; // <?xml foo\nconst S_XML_DECL_EQ = 29; // <?xml foo=\nconst S_XML_DECL_VALUE_START = 30; // <?xml foo=\nconst S_XML_DECL_VALUE = 31; // <?xml foo=\"bar\"\nconst S_XML_DECL_SEPARATOR = 32; // <?xml foo=\"bar\"\nconst S_XML_DECL_ENDING = 33; // <?xml ... ?\nconst S_OPEN_TAG = 34; // <strong\nconst S_OPEN_TAG_SLASH = 35; // <strong /\nconst S_ATTRIB = 36; // <a\nconst S_ATTRIB_NAME = 37; // <a foo\nconst S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _\nconst S_ATTRIB_VALUE = 39; // <a foo=\nconst S_ATTRIB_VALUE_QUOTED = 40; // <a foo=\"bar\nconst S_ATTRIB_VALUE_CLOSED = 41; // <a foo=\"bar\"\nconst S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar\nconst S_CLOSE_TAG = 43; // </a\nconst S_CLOSE_TAG_SAW_WHITE = 44; // </a   >\nconst TAB = 9;\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\nconst NEL = 0x85;\nconst LS = 0x2028; // Line Separator\nconst isQuote = (c) => c === DQUOTE || c === SQUOTE;\nconst QUOTES = [DQUOTE, SQUOTE];\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\nfunction nsPairCheck(parser, prefix, uri) {\n    switch (prefix) {\n        case \"xml\":\n            if (uri !== XML_NAMESPACE) {\n                parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n            }\n            break;\n        case \"xmlns\":\n            if (uri !== XMLNS_NAMESPACE) {\n                parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n            }\n            break;\n        default:\n    }\n    switch (uri) {\n        case XMLNS_NAMESPACE:\n            parser.fail(prefix === \"\" ?\n                `the default namespace may not be set to ${uri}.` :\n                `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n            break;\n        case XML_NAMESPACE:\n            switch (prefix) {\n                case \"xml\":\n                    // Assinging the XML namespace to \"xml\" is fine.\n                    break;\n                case \"\":\n                    parser.fail(`the default namespace may not be set to ${uri}.`);\n                    break;\n                default:\n                    parser.fail(\"may not assign the xml namespace to another prefix.\");\n            }\n            break;\n        default:\n    }\n}\nfunction nsMappingCheck(parser, mapping) {\n    for (const local of Object.keys(mapping)) {\n        nsPairCheck(parser, local, mapping[local]);\n    }\n}\nconst isNCName = (name) => NC_NAME_RE.test(name);\nconst isName = (name) => NAME_RE.test(name);\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n/**\n * The list of supported events.\n */\nexports.EVENTS = [\n    \"xmldecl\",\n    \"text\",\n    \"processinginstruction\",\n    \"doctype\",\n    \"comment\",\n    \"opentagstart\",\n    \"attribute\",\n    \"opentag\",\n    \"closetag\",\n    \"cdata\",\n    \"error\",\n    \"end\",\n    \"ready\",\n];\nconst EVENT_NAME_TO_HANDLER_NAME = {\n    xmldecl: \"xmldeclHandler\",\n    text: \"textHandler\",\n    processinginstruction: \"piHandler\",\n    doctype: \"doctypeHandler\",\n    comment: \"commentHandler\",\n    opentagstart: \"openTagStartHandler\",\n    attribute: \"attributeHandler\",\n    opentag: \"openTagHandler\",\n    closetag: \"closeTagHandler\",\n    cdata: \"cdataHandler\",\n    error: \"errorHandler\",\n    end: \"endHandler\",\n    ready: \"readyHandler\",\n};\nclass SaxesParser {\n    /**\n     * @param opt The parser options.\n     */\n    constructor(opt) {\n        this.opt = opt !== null && opt !== void 0 ? opt : {};\n        this.fragmentOpt = !!this.opt.fragment;\n        const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n        this.trackPosition = this.opt.position !== false;\n        this.fileName = this.opt.fileName;\n        if (xmlnsOpt) {\n            // This is the function we use to perform name checks on PIs and entities.\n            // When namespaces are used, colons are not allowed in PI target names or\n            // entity names. So the check depends on whether namespaces are used. See:\n            //\n            // https://www.w3.org/XML/xml-names-19990114-errata.html\n            // NE08\n            //\n            this.nameStartCheck = isNCNameStartChar;\n            this.nameCheck = isNCNameChar;\n            this.isName = isNCName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsNS;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribNS;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.ns = Object.assign({ __proto__: null }, rootNS);\n            const additional = this.opt.additionalNamespaces;\n            if (additional != null) {\n                nsMappingCheck(this, additional);\n                Object.assign(this.ns, additional);\n            }\n        }\n        else {\n            this.nameStartCheck = isNameStartChar;\n            this.nameCheck = isNameChar;\n            this.isName = isName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsPlain;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribPlain;\n        }\n        //\n        // The order of the members in this table needs to correspond to the state\n        // numbers given to the states that correspond to the methods being recorded\n        // here.\n        //\n        this.stateTable = [\n            /* eslint-disable @typescript-eslint/unbound-method */\n            this.sBegin,\n            this.sBeginWhitespace,\n            this.sDoctype,\n            this.sDoctypeQuote,\n            this.sDTD,\n            this.sDTDQuoted,\n            this.sDTDOpenWaka,\n            this.sDTDOpenWakaBang,\n            this.sDTDComment,\n            this.sDTDCommentEnding,\n            this.sDTDCommentEnded,\n            this.sDTDPI,\n            this.sDTDPIEnding,\n            this.sText,\n            this.sEntity,\n            this.sOpenWaka,\n            this.sOpenWakaBang,\n            this.sComment,\n            this.sCommentEnding,\n            this.sCommentEnded,\n            this.sCData,\n            this.sCDataEnding,\n            this.sCDataEnding2,\n            this.sPIFirstChar,\n            this.sPIRest,\n            this.sPIBody,\n            this.sPIEnding,\n            this.sXMLDeclNameStart,\n            this.sXMLDeclName,\n            this.sXMLDeclEq,\n            this.sXMLDeclValueStart,\n            this.sXMLDeclValue,\n            this.sXMLDeclSeparator,\n            this.sXMLDeclEnding,\n            this.sOpenTag,\n            this.sOpenTagSlash,\n            this.sAttrib,\n            this.sAttribName,\n            this.sAttribNameSawWhite,\n            this.sAttribValue,\n            this.sAttribValueQuoted,\n            this.sAttribValueClosed,\n            this.sAttribValueUnquoted,\n            this.sCloseTag,\n            this.sCloseTagSawWhite,\n        ];\n        this._init();\n    }\n    /**\n     * Indicates whether or not the parser is closed. If ``true``, wait for\n     * the ``ready`` event to write again.\n     */\n    get closed() {\n        return this._closed;\n    }\n    _init() {\n        var _a;\n        this.openWakaBang = \"\";\n        this.text = \"\";\n        this.name = \"\";\n        this.piTarget = \"\";\n        this.entity = \"\";\n        this.q = null;\n        this.tags = [];\n        this.tag = null;\n        this.topNS = null;\n        this.chunk = \"\";\n        this.chunkPosition = 0;\n        this.i = 0;\n        this.prevI = 0;\n        this.carriedFromPrevious = undefined;\n        this.forbiddenState = FORBIDDEN_START;\n        this.attribList = [];\n        // The logic is organized so as to minimize the need to check\n        // this.opt.fragment while parsing.\n        const { fragmentOpt } = this;\n        this.state = fragmentOpt ? S_TEXT : S_BEGIN;\n        // We want these to be all true if we are dealing with a fragment.\n        this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot =\n            this.sawRoot = fragmentOpt;\n        // An XML declaration is intially possible only when parsing whole\n        // documents.\n        this.xmlDeclPossible = !fragmentOpt;\n        this.xmlDeclExpects = [\"version\"];\n        this.entityReturnState = undefined;\n        let { defaultXMLVersion } = this.opt;\n        if (defaultXMLVersion === undefined) {\n            if (this.opt.forceXMLVersion === true) {\n                throw new Error(\"forceXMLVersion set but defaultXMLVersion is not set\");\n            }\n            defaultXMLVersion = \"1.0\";\n        }\n        this.setXMLVersion(defaultXMLVersion);\n        this.positionAtNewLine = 0;\n        this.doctype = false;\n        this._closed = false;\n        this.xmlDecl = {\n            version: undefined,\n            encoding: undefined,\n            standalone: undefined,\n        };\n        this.line = 1;\n        this.column = 0;\n        this.ENTITIES = Object.create(XML_ENTITIES);\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    /**\n     * The stream position the parser is currently looking at. This field is\n     * zero-based.\n     *\n     * This field is not based on counting Unicode characters but is to be\n     * interpreted as a plain index into a JavaScript string.\n     */\n    get position() {\n        return this.chunkPosition + this.i;\n    }\n    /**\n     * The column number of the next character to be read by the parser.  *\n     * This field is zero-based. (The first column in a line is 0.)\n     *\n     * This field reports the index at which the next character would be in the\n     * line if the line were represented as a JavaScript string.  Note that this\n     * *can* be different to a count based on the number of *Unicode characters*\n     * due to how JavaScript handles astral plane characters.\n     *\n     * See [[column]] for a number that corresponds to a count of Unicode\n     * characters.\n     */\n    get columnIndex() {\n        return this.position - this.positionAtNewLine;\n    }\n    /**\n     * Set an event listener on an event. The parser supports one handler per\n     * event type. If you try to set an event handler over an existing handler,\n     * the old handler is silently overwritten.\n     *\n     * @param name The event to listen to.\n     *\n     * @param handler The handler to set.\n     */\n    on(name, handler) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;\n    }\n    /**\n     * Unset an event handler.\n     *\n     * @parma name The event to stop listening to.\n     */\n    off(name) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;\n    }\n    /**\n     * Make an error object. The error object will have a message that contains\n     * the ``fileName`` option passed at the creation of the parser. If position\n     * tracking was turned on, it will also have line and column number\n     * information.\n     *\n     * @param message The message describing the error to report.\n     *\n     * @returns An error object with a properly formatted message.\n     */\n    makeError(message) {\n        var _a;\n        let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : \"\";\n        if (this.trackPosition) {\n            if (msg.length > 0) {\n                msg += \":\";\n            }\n            msg += `${this.line}:${this.column}`;\n        }\n        if (msg.length > 0) {\n            msg += \": \";\n        }\n        return new Error(msg + message);\n    }\n    /**\n     * Report a parsing error. This method is made public so that client code may\n     * check for issues that are outside the scope of this project and can report\n     * errors.\n     *\n     * @param message The error to report.\n     *\n     * @returns this\n     */\n    fail(message) {\n        const err = this.makeError(message);\n        const handler = this.errorHandler;\n        if (handler === undefined) {\n            throw err;\n        }\n        else {\n            handler(err);\n        }\n        return this;\n    }\n    /**\n     * Write a XML data to the parser.\n     *\n     * @param chunk The XML data to write.\n     *\n     * @returns this\n     */\n    write(chunk) {\n        if (this.closed) {\n            return this.fail(\"cannot write after close; assign an onready handler.\");\n        }\n        let end = false;\n        if (chunk === null) {\n            // We cannot return immediately because carriedFromPrevious may need\n            // processing.\n            end = true;\n            chunk = \"\";\n        }\n        else if (typeof chunk === \"object\") {\n            chunk = chunk.toString();\n        }\n        // We checked if performing a pre-decomposition of the string into an array\n        // of single complete characters (``Array.from(chunk)``) would be faster\n        // than the current repeated calls to ``charCodeAt``. As of August 2018, it\n        // isn't. (There may be Node-specific code that would perform faster than\n        // ``Array.from`` but don't want to be dependent on Node.)\n        if (this.carriedFromPrevious !== undefined) {\n            // The previous chunk had char we must carry over.\n            chunk = `${this.carriedFromPrevious}${chunk}`;\n            this.carriedFromPrevious = undefined;\n        }\n        let limit = chunk.length;\n        const lastCode = chunk.charCodeAt(limit - 1);\n        if (!end &&\n            // A trailing CR or surrogate must be carried over to the next\n            // chunk.\n            (lastCode === CR || (lastCode >= 0xD800 && lastCode <= 0xDBFF))) {\n            // The chunk ends with a character that must be carried over. We cannot\n            // know how to handle it until we get the next chunk or the end of the\n            // stream. So save it for later.\n            this.carriedFromPrevious = chunk[limit - 1];\n            limit--;\n            chunk = chunk.slice(0, limit);\n        }\n        const { stateTable } = this;\n        this.chunk = chunk;\n        this.i = 0;\n        while (this.i < limit) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            stateTable[this.state].call(this);\n        }\n        this.chunkPosition += limit;\n        return end ? this.end() : this;\n    }\n    /**\n     * Close the current stream. Perform final well-formedness checks and reset\n     * the parser tstate.\n     *\n     * @returns this\n     */\n    close() {\n        return this.write(null);\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.0.\n     *\n     * @returns The character read.\n     */\n    getCode10() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if (code >= SPACE || code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL:\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR:\n                    // We may get NaN if we read past the end of the chunk, which is fine.\n                    if (chunk.charCodeAt(i + 1) === NL) {\n                        // A \\r\\n sequence is converted to \\n so we have to skip over the\n                        // next character. We already know it has a size of 1 so ++ is fine\n                        // here.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n                    // ahead.\n                    // In either case, \\r becomes \\n.\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    // If we get here, then code < SPACE and it is not NL CR or TAB.\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isChar10 that takes into account\n            // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not\n            // test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isChar10 that takes into account that in\n        // this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.1.\n     *\n     * @returns {number} The character read.\n     */\n    getCode11() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if ((code > 0x1F && code < 0x7F) || (code > 0x9F && code !== LS) ||\n                code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL: // 0xA\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR: { // 0xD\n                    // We may get NaN if we read past the end of the chunk, which is\n                    // fine.\n                    const next = chunk.charCodeAt(i + 1);\n                    if (next === NL || next === NEL) {\n                        // A CR NL or CR NEL sequence is converted to NL so we have to skip\n                        // over the next character. We already know it has a size of 1.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a CR is just converted to NL, no skip.\n                }\n                /* yes, fall through */\n                case NEL: // 0x85\n                case LS: // Ox2028\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isCharAndNotRestricted that takes into\n            // account that in this context code > 0xDBFF and code <= 0xFFFF. So it\n            // does not test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isCharAndNotRestricted that takes into\n        // account that in this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Like ``getCode`` but with the return value normalized so that ``NL`` is\n     * returned for ``NL_LIKE``.\n     */\n    getCodeNorm() {\n        const c = this.getCode();\n        return c === NL_LIKE ? NL : c;\n    }\n    unget() {\n        this.i = this.prevI;\n        this.column--;\n    }\n    /**\n     * Capture characters into a buffer until encountering one of a set of\n     * characters.\n     *\n     * @param chars An array of codepoints. Encountering a character in the array\n     * ends the capture. (``chars`` may safely contain ``NL``.)\n     *\n     * @return The character code that made the capture end, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureTo(chars) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            const isNLLike = c === NL_LIKE;\n            const final = isNLLike ? NL : c;\n            if (final === EOC || chars.includes(final)) {\n                this.text += chunk.slice(start, this.prevI);\n                return final;\n            }\n            if (isNLLike) {\n                this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                start = this.i;\n            }\n        }\n    }\n    /**\n     * Capture characters into a buffer until encountering a character.\n     *\n     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT\n     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.\n     *\n     * @return ``true`` if we ran into the character. Otherwise, we ran into the\n     * end of the current chunk.\n     */\n    captureToChar(char) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            let c = this.getCode();\n            switch (c) {\n                case NL_LIKE:\n                    this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    c = NL;\n                    break;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return false;\n                default:\n            }\n            if (c === char) {\n                this.text += chunk.slice(start, this.prevI);\n                return true;\n            }\n        }\n    }\n    /**\n     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n     * this parser.\n     *\n     * @return The character code that made the test fail, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureNameChars() {\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            if (c === EOC) {\n                this.name += chunk.slice(start);\n                return EOC;\n            }\n            // NL is not a name char so we don't have to test specifically for it.\n            if (!isNameChar(c)) {\n                this.name += chunk.slice(start, this.prevI);\n                return c === NL_LIKE ? NL : c;\n            }\n        }\n    }\n    /**\n     * Skip white spaces.\n     *\n     * @return The character that ended the skip, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    skipSpaces() {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC || !isS(c)) {\n                return c;\n            }\n        }\n    }\n    setXMLVersion(version) {\n        this.currentXMLVersion = version;\n        /*  eslint-disable @typescript-eslint/unbound-method */\n        if (version === \"1.0\") {\n            this.isChar = isChar10;\n            this.getCode = this.getCode10;\n        }\n        else {\n            this.isChar = isChar11;\n            this.getCode = this.getCode11;\n        }\n        /* eslint-enable @typescript-eslint/unbound-method */\n    }\n    // STATE ENGINE METHODS\n    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want\n    // to be sure never to come back to this state later.\n    sBegin() {\n        // We are essentially peeking at the first character of the chunk. Since\n        // S_BEGIN can be in effect only when we start working on the first chunk,\n        // the index at which we must look is necessarily 0. Note also that the\n        // following test does not depend on decoding surrogates.\n        // If the initial character is 0xFEFF, ignore it.\n        if (this.chunk.charCodeAt(0) === 0xFEFF) {\n            this.i++;\n            this.column++;\n        }\n        this.state = S_BEGIN_WHITESPACE;\n    }\n    sBeginWhitespace() {\n        // We need to know whether we've encountered spaces or not because as soon\n        // as we run into a space, an XML declaration is no longer possible. Rather\n        // than slow down skipSpaces even in places where we don't care whether it\n        // skipped anything or not, we check whether prevI is equal to the value of\n        // i from before we skip spaces.\n        const iBefore = this.i;\n        const c = this.skipSpaces();\n        if (this.prevI !== iBefore) {\n            this.xmlDeclPossible = false;\n        }\n        switch (c) {\n            case LESS:\n                this.state = S_OPEN_WAKA;\n                // We could naively call closeText but in this state, it is not normal\n                // to have text be filled with any data.\n                if (this.text.length !== 0) {\n                    throw new Error(\"no-empty text at start\");\n                }\n                break;\n            case EOC:\n                break;\n            default:\n                this.unget();\n                this.state = S_TEXT;\n                this.xmlDeclPossible = false;\n        }\n    }\n    sDoctype() {\n        var _a;\n        const c = this.captureTo(DOCTYPE_TERMINATOR);\n        switch (c) {\n            case GREATER: {\n                // eslint-disable-next-line no-unused-expressions\n                (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                this.doctype = true; // just remember that we saw it.\n                break;\n            }\n            case EOC:\n                break;\n            default:\n                this.text += String.fromCodePoint(c);\n                if (c === OPEN_BRACKET) {\n                    this.state = S_DTD;\n                }\n                else if (isQuote(c)) {\n                    this.state = S_DOCTYPE_QUOTE;\n                    this.q = c;\n                }\n        }\n    }\n    sDoctypeQuote() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.q = null;\n            this.state = S_DOCTYPE;\n        }\n    }\n    sDTD() {\n        const c = this.captureTo(DTD_TERMINATOR);\n        if (c === EOC) {\n            return;\n        }\n        this.text += String.fromCodePoint(c);\n        if (c === CLOSE_BRACKET) {\n            this.state = S_DOCTYPE;\n        }\n        else if (c === LESS) {\n            this.state = S_DTD_OPEN_WAKA;\n        }\n        else if (isQuote(c)) {\n            this.state = S_DTD_QUOTED;\n            this.q = c;\n        }\n    }\n    sDTDQuoted() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.state = S_DTD;\n            this.q = null;\n        }\n    }\n    sDTDOpenWaka() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        switch (c) {\n            case BANG:\n                this.state = S_DTD_OPEN_WAKA_BANG;\n                this.openWakaBang = \"\";\n                break;\n            case QUESTION:\n                this.state = S_DTD_PI;\n                break;\n            default:\n                this.state = S_DTD;\n        }\n    }\n    sDTDOpenWakaBang() {\n        const char = String.fromCodePoint(this.getCodeNorm());\n        const owb = this.openWakaBang += char;\n        this.text += char;\n        if (owb !== \"-\") {\n            this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n            this.openWakaBang = \"\";\n        }\n    }\n    sDTDComment() {\n        if (this.captureToChar(MINUS)) {\n            this.text += \"-\";\n            this.state = S_DTD_COMMENT_ENDING;\n        }\n    }\n    sDTDCommentEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n    }\n    sDTDCommentEnded() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n        else {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.state = S_DTD_COMMENT;\n        }\n    }\n    sDTDPI() {\n        if (this.captureToChar(QUESTION)) {\n            this.text += \"?\";\n            this.state = S_DTD_PI_ENDING;\n        }\n    }\n    sDTDPIEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n    }\n    sText() {\n        //\n        // We did try a version of saxes where the S_TEXT state was split in two\n        // states: one for text inside the root element, and one for text\n        // outside. This was avoiding having to test this.tags.length to decide\n        // what implementation to actually use.\n        //\n        // Peformance testing on gigabyte-size files did not show any advantage to\n        // using the two states solution instead of the current one. Conversely, it\n        // made the code a bit more complicated elsewhere. For instance, a comment\n        // can appear before the root element so when a comment ended it was\n        // necessary to determine whether to return to the S_TEXT state or to the\n        // new text-outside-root state.\n        //\n        if (this.tags.length !== 0) {\n            this.handleTextInRoot();\n        }\n        else {\n            this.handleTextOutsideRoot();\n        }\n    }\n    sEntity() {\n        // This is essentially a specialized version of captureToChar(SEMICOLON...)\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        loop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case NL_LIKE:\n                    this.entity += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    break;\n                case SEMICOLON: {\n                    const { entityReturnState } = this;\n                    const entity = this.entity + chunk.slice(start, this.prevI);\n                    this.state = entityReturnState;\n                    let parsed;\n                    if (entity === \"\") {\n                        this.fail(\"empty entity name.\");\n                        parsed = \"&;\";\n                    }\n                    else {\n                        parsed = this.parseEntity(entity);\n                        this.entity = \"\";\n                    }\n                    if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {\n                        this.text += parsed;\n                    }\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                }\n                case EOC:\n                    this.entity += chunk.slice(start);\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                default:\n            }\n        }\n    }\n    sOpenWaka() {\n        // Reminder: a state handler is called with at least one character\n        // available in the current chunk. So the first call to get code inside of\n        // a state handler cannot return ``EOC``. That's why we don't test\n        // for it.\n        const c = this.getCode();\n        // either a /, ?, !, or text is coming next.\n        if (isNameStartChar(c)) {\n            this.state = S_OPEN_TAG;\n            this.unget();\n            this.xmlDeclPossible = false;\n        }\n        else {\n            switch (c) {\n                case FORWARD_SLASH:\n                    this.state = S_CLOSE_TAG;\n                    this.xmlDeclPossible = false;\n                    break;\n                case BANG:\n                    this.state = S_OPEN_WAKA_BANG;\n                    this.openWakaBang = \"\";\n                    this.xmlDeclPossible = false;\n                    break;\n                case QUESTION:\n                    this.state = S_PI_FIRST_CHAR;\n                    break;\n                default:\n                    this.fail(\"disallowed character in tag name\");\n                    this.state = S_TEXT;\n                    this.xmlDeclPossible = false;\n            }\n        }\n    }\n    sOpenWakaBang() {\n        this.openWakaBang += String.fromCodePoint(this.getCodeNorm());\n        switch (this.openWakaBang) {\n            case \"[CDATA[\":\n                if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextBeforeRoot = true;\n                }\n                if (this.closedRoot && !this.reportedTextAfterRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextAfterRoot = true;\n                }\n                this.state = S_CDATA;\n                this.openWakaBang = \"\";\n                break;\n            case \"--\":\n                this.state = S_COMMENT;\n                this.openWakaBang = \"\";\n                break;\n            case \"DOCTYPE\":\n                this.state = S_DOCTYPE;\n                if (this.doctype || this.sawRoot) {\n                    this.fail(\"inappropriately located doctype declaration.\");\n                }\n                this.openWakaBang = \"\";\n                break;\n            default:\n                // 7 happens to be the maximum length of the string that can possibly\n                // match one of the cases above.\n                if (this.openWakaBang.length >= 7) {\n                    this.fail(\"incorrect syntax.\");\n                }\n        }\n    }\n    sComment() {\n        if (this.captureToChar(MINUS)) {\n            this.state = S_COMMENT_ENDING;\n        }\n    }\n    sCommentEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === MINUS) {\n            this.state = S_COMMENT_ENDED;\n            // eslint-disable-next-line no-unused-expressions\n            (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n            this.text = \"\";\n        }\n        else {\n            this.text += `-${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n    }\n    sCommentEnded() {\n        const c = this.getCodeNorm();\n        if (c !== GREATER) {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.text += `--${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n        else {\n            this.state = S_TEXT;\n        }\n    }\n    sCData() {\n        if (this.captureToChar(CLOSE_BRACKET)) {\n            this.state = S_CDATA_ENDING;\n        }\n    }\n    sCDataEnding() {\n        const c = this.getCodeNorm();\n        if (c === CLOSE_BRACKET) {\n            this.state = S_CDATA_ENDING_2;\n        }\n        else {\n            this.text += `]${String.fromCodePoint(c)}`;\n            this.state = S_CDATA;\n        }\n    }\n    sCDataEnding2() {\n        var _a;\n        const c = this.getCodeNorm();\n        switch (c) {\n            case GREATER: {\n                // eslint-disable-next-line no-unused-expressions\n                (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                break;\n            }\n            case CLOSE_BRACKET:\n                this.text += \"]\";\n                break;\n            default:\n                this.text += `]]${String.fromCodePoint(c)}`;\n                this.state = S_CDATA;\n        }\n    }\n    // We need this separate state to check the first character fo the pi target\n    // with this.nameStartCheck which allows less characters than this.nameCheck.\n    sPIFirstChar() {\n        const c = this.getCodeNorm();\n        // This is first because in the case where the file is well-formed this is\n        // the branch taken. We optimize for well-formedness.\n        if (this.nameStartCheck(c)) {\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n        else if (c === QUESTION || isS(c)) {\n            this.fail(\"processing instruction without a target.\");\n            this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n        }\n        else {\n            this.fail(\"disallowed character in processing instruction name.\");\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n    }\n    sPIRest() {\n        // Capture characters into a piTarget while ``this.nameCheck`` run on the\n        // character read returns true.\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC) {\n                this.piTarget += chunk.slice(start);\n                return;\n            }\n            // NL cannot satisfy this.nameCheck so we don't have to test specifically\n            // for it.\n            if (!this.nameCheck(c)) {\n                this.piTarget += chunk.slice(start, this.prevI);\n                const isQuestion = c === QUESTION;\n                if (isQuestion || isS(c)) {\n                    if (this.piTarget === \"xml\") {\n                        if (!this.xmlDeclPossible) {\n                            this.fail(\"an XML declaration must be at the start of the document.\");\n                        }\n                        this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;\n                    }\n                    else {\n                        this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;\n                    }\n                }\n                else {\n                    this.fail(\"disallowed character in processing instruction name.\");\n                    this.piTarget += String.fromCodePoint(c);\n                }\n                break;\n            }\n        }\n    }\n    sPIBody() {\n        if (this.text.length === 0) {\n            const c = this.getCodeNorm();\n            if (c === QUESTION) {\n                this.state = S_PI_ENDING;\n            }\n            else if (!isS(c)) {\n                this.text = String.fromCodePoint(c);\n            }\n        }\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        else if (this.captureToChar(QUESTION)) {\n            this.state = S_PI_ENDING;\n        }\n    }\n    sPIEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            const { piTarget } = this;\n            if (piTarget.toLowerCase() === \"xml\") {\n                this.fail(\"the XML declaration must appear at the start of the document.\");\n            }\n            // eslint-disable-next-line no-unused-expressions\n            (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {\n                target: piTarget,\n                body: this.text,\n            });\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else if (c === QUESTION) {\n            // We ran into ?? as part of a processing instruction. We initially took\n            // the first ? as a sign that the PI was ending, but it is not. So we have\n            // to add it to the body but we take the new ? as a sign that the PI is\n            // ending.\n            this.text += \"?\";\n        }\n        else {\n            this.text += `?${String.fromCodePoint(c)}`;\n            this.state = S_PI_BODY;\n        }\n        this.xmlDeclPossible = false;\n    }\n    sXMLDeclNameStart() {\n        const c = this.skipSpaces();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (c !== EOC) {\n            this.state = S_XML_DECL_NAME;\n            this.name = String.fromCodePoint(c);\n        }\n    }\n    sXMLDeclName() {\n        const c = this.captureTo(XML_DECL_NAME_TERMINATOR);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.name += this.text;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (!(isS(c) || c === EQUAL)) {\n            return;\n        }\n        this.name += this.text;\n        this.text = \"\";\n        if (!this.xmlDeclExpects.includes(this.name)) {\n            switch (this.name.length) {\n                case 0:\n                    this.fail(\"did not expect any more name/value pairs.\");\n                    break;\n                case 1:\n                    this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n                    break;\n                default:\n                    this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n            }\n        }\n        this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n    }\n    sXMLDeclEq() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (c !== EQUAL) {\n            this.fail(\"value required.\");\n        }\n        this.state = S_XML_DECL_VALUE_START;\n    }\n    sXMLDeclValueStart() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (!isQuote(c)) {\n            this.fail(\"value must be quoted.\");\n            this.q = SPACE;\n        }\n        else {\n            this.q = c;\n        }\n        this.state = S_XML_DECL_VALUE;\n    }\n    sXMLDeclValue() {\n        const c = this.captureTo([this.q, QUESTION]);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (c === EOC) {\n            return;\n        }\n        const value = this.text;\n        this.text = \"\";\n        switch (this.name) {\n            case \"version\": {\n                this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n                const version = value;\n                this.xmlDecl.version = version;\n                // This is the test specified by XML 1.0 but it is fine for XML 1.1.\n                if (!/^1\\.[0-9]+$/.test(version)) {\n                    this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n                }\n                // When forceXMLVersion is set, the XML declaration is ignored.\n                else if (!this.opt.forceXMLVersion) {\n                    this.setXMLVersion(version);\n                }\n                break;\n            }\n            case \"encoding\":\n                if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {\n                    this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n                }\n                this.xmlDeclExpects = [\"standalone\"];\n                this.xmlDecl.encoding = value;\n                break;\n            case \"standalone\":\n                if (value !== \"yes\" && value !== \"no\") {\n                    this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n                }\n                this.xmlDeclExpects = [];\n                this.xmlDecl.standalone = value;\n                break;\n            default:\n            // We don't need to raise an error here since we've already raised one\n            // when checking what name was expected.\n        }\n        this.name = \"\";\n        this.state = S_XML_DECL_SEPARATOR;\n    }\n    sXMLDeclSeparator() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (!isS(c)) {\n            this.fail(\"whitespace required.\");\n            this.unget();\n        }\n        this.state = S_XML_DECL_NAME_START;\n    }\n    sXMLDeclEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            if (this.piTarget !== \"xml\") {\n                this.fail(\"processing instructions are not allowed before root.\");\n            }\n            else if (this.name !== \"version\" &&\n                this.xmlDeclExpects.includes(\"version\")) {\n                this.fail(\"XML declaration must contain a version.\");\n            }\n            // eslint-disable-next-line no-unused-expressions\n            (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);\n            this.name = \"\";\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else {\n            // We got here because the previous character was a ?, but the question\n            // mark character is not valid inside any of the XML declaration\n            // name/value pairs.\n            this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n        }\n        this.xmlDeclPossible = false;\n    }\n    sOpenTag() {\n        var _a;\n        const c = this.captureNameChars();\n        if (c === EOC) {\n            return;\n        }\n        const tag = this.tag = {\n            name: this.name,\n            attributes: Object.create(null),\n        };\n        this.name = \"\";\n        if (this.xmlnsOpt) {\n            this.topNS = tag.ns = Object.create(null);\n        }\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        this.sawRoot = true;\n        if (!this.fragmentOpt && this.closedRoot) {\n            this.fail(\"documents may contain only one root.\");\n        }\n        switch (c) {\n            case GREATER:\n                this.openTag();\n                break;\n            case FORWARD_SLASH:\n                this.state = S_OPEN_TAG_SLASH;\n                break;\n            default:\n                if (!isS(c)) {\n                    this.fail(\"disallowed character in tag name.\");\n                }\n                this.state = S_ATTRIB;\n        }\n    }\n    sOpenTagSlash() {\n        if (this.getCode() === GREATER) {\n            this.openSelfClosingTag();\n        }\n        else {\n            this.fail(\"forward-slash in opening tag not followed by >.\");\n            this.state = S_ATTRIB;\n        }\n    }\n    sAttrib() {\n        const c = this.skipSpaces();\n        if (c === EOC) {\n            return;\n        }\n        if (isNameStartChar(c)) {\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribName() {\n        const c = this.captureNameChars();\n        if (c === EQUAL) {\n            this.state = S_ATTRIB_VALUE;\n        }\n        else if (isS(c)) {\n            this.state = S_ATTRIB_NAME_SAW_WHITE;\n        }\n        else if (c === GREATER) {\n            this.fail(\"attribute without value.\");\n            this.pushAttrib(this.name, this.name);\n            this.name = this.text = \"\";\n            this.openTag();\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribNameSawWhite() {\n        const c = this.skipSpaces();\n        switch (c) {\n            case EOC:\n                return;\n            case EQUAL:\n                this.state = S_ATTRIB_VALUE;\n                break;\n            default:\n                this.fail(\"attribute without value.\");\n                // Should we do this???\n                // this.tag.attributes[this.name] = \"\";\n                this.text = \"\";\n                this.name = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else if (isNameStartChar(c)) {\n                    this.unget();\n                    this.state = S_ATTRIB_NAME;\n                }\n                else {\n                    this.fail(\"disallowed character in attribute name.\");\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sAttribValue() {\n        const c = this.getCodeNorm();\n        if (isQuote(c)) {\n            this.q = c;\n            this.state = S_ATTRIB_VALUE_QUOTED;\n        }\n        else if (!isS(c)) {\n            this.fail(\"unquoted attribute value.\");\n            this.state = S_ATTRIB_VALUE_UNQUOTED;\n            this.unget();\n        }\n    }\n    sAttribValueQuoted() {\n        // We deliberately do not use captureTo here. The specialized code we use\n        // here is faster than using captureTo.\n        const { q, chunk } = this;\n        let { i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case q:\n                    this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));\n                    this.name = this.text = \"\";\n                    this.q = null;\n                    this.state = S_ATTRIB_VALUE_CLOSED;\n                    return;\n                case AMP:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n                    return;\n                case NL:\n                case NL_LIKE:\n                case TAB:\n                    this.text += `${chunk.slice(start, this.prevI)} `;\n                    start = this.i;\n                    break;\n                case LESS:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.fail(\"disallowed character.\");\n                    return;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return;\n                default:\n            }\n        }\n    }\n    sAttribValueClosed() {\n        const c = this.getCodeNorm();\n        if (isS(c)) {\n            this.state = S_ATTRIB;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else if (isNameStartChar(c)) {\n            this.fail(\"no whitespace between attributes.\");\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribValueUnquoted() {\n        // We don't do anything regarding EOL or space handling for unquoted\n        // attributes. We already have failed by the time we get here, and the\n        // contract that saxes upholds states that upon failure, it is not safe to\n        // rely on the data passed to event handlers (other than\n        // ``onerror``). Passing \"bad\" data is not a problem.\n        const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);\n        switch (c) {\n            case AMP:\n                this.state = S_ENTITY;\n                this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n                break;\n            case LESS:\n                this.fail(\"disallowed character.\");\n                break;\n            case EOC:\n                break;\n            default:\n                if (this.text.includes(\"]]>\")) {\n                    this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                }\n                this.pushAttrib(this.name, this.text);\n                this.name = this.text = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else {\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sCloseTag() {\n        const c = this.captureNameChars();\n        if (c === GREATER) {\n            this.closeTag();\n        }\n        else if (isS(c)) {\n            this.state = S_CLOSE_TAG_SAW_WHITE;\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    sCloseTagSawWhite() {\n        switch (this.skipSpaces()) {\n            case GREATER:\n                this.closeTag();\n                break;\n            case EOC:\n                break;\n            default:\n                this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    // END OF STATE ENGINE METHODS\n    handleTextInRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for performing the ]]> check. A previous version of this code, checked\n        // ``this.text`` for the presence of ]]>. It simplified the code but was\n        // very costly when character data contained a lot of entities to be parsed.\n        //\n        // Since we are using a specialized loop, we also keep track of the presence\n        // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n        //\n        let { i: start, forbiddenState } = this;\n        const { chunk, textHandler: handler } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        scanLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                case CLOSE_BRACKET:\n                    switch (forbiddenState) {\n                        case FORBIDDEN_START:\n                            forbiddenState = FORBIDDEN_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET:\n                            forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET_BRACKET:\n                            break;\n                        default:\n                            throw new Error(\"impossible state\");\n                    }\n                    break;\n                case GREATER:\n                    if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n                        this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                default:\n                    forbiddenState = FORBIDDEN_START;\n            }\n        }\n        this.forbiddenState = forbiddenState;\n    }\n    handleTextOutsideRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for a specialized task. We keep track of the presence of non-space\n        // characters in the text since these are errors when appearing outside the\n        // document root element.\n        let { i: start } = this;\n        const { chunk, textHandler: handler } = this;\n        let nonSpace = false;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        outRootLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const code = this.getCode();\n            switch (code) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    nonSpace = true;\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                default:\n                    if (!isS(code)) {\n                        nonSpace = true;\n                    }\n            }\n        }\n        if (!nonSpace) {\n            return;\n        }\n        // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n        // to avoid reporting errors for every single character that is out of\n        // place.\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextBeforeRoot = true;\n        }\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextAfterRoot = true;\n        }\n    }\n    pushAttribNS(name, value) {\n        var _a;\n        const { prefix, local } = this.qname(name);\n        const attr = { name, prefix, local, value };\n        this.attribList.push(attr);\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n        if (prefix === \"xmlns\") {\n            const trimmed = value.trim();\n            if (this.currentXMLVersion === \"1.0\" && trimmed === \"\") {\n                this.fail(\"invalid attempt to undefine prefix in XML 1.0\");\n            }\n            this.topNS[local] = trimmed;\n            nsPairCheck(this, local, trimmed);\n        }\n        else if (name === \"xmlns\") {\n            const trimmed = value.trim();\n            this.topNS[\"\"] = trimmed;\n            nsPairCheck(this, \"\", trimmed);\n        }\n    }\n    pushAttribPlain(name, value) {\n        var _a;\n        const attr = { name, value };\n        this.attribList.push(attr);\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n    }\n    /**\n     * End parsing. This performs final well-formedness checks and resets the\n     * parser to a clean state.\n     *\n     * @returns this\n     */\n    end() {\n        var _a, _b;\n        if (!this.sawRoot) {\n            this.fail(\"document must contain a root element.\");\n        }\n        const { tags } = this;\n        while (tags.length > 0) {\n            const tag = tags.pop();\n            this.fail(`unclosed tag: ${tag.name}`);\n        }\n        if ((this.state !== S_BEGIN) && (this.state !== S_TEXT)) {\n            this.fail(\"unexpected end.\");\n        }\n        const { text } = this;\n        if (text.length !== 0) {\n            // eslint-disable-next-line no-unused-expressions\n            (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);\n            this.text = \"\";\n        }\n        this._closed = true;\n        // eslint-disable-next-line no-unused-expressions\n        (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);\n        this._init();\n        return this;\n    }\n    /**\n     * Resolve a namespace prefix.\n     *\n     * @param prefix The prefix to resolve.\n     *\n     * @returns The namespace URI or ``undefined`` if the prefix is not defined.\n     */\n    resolve(prefix) {\n        var _a, _b;\n        let uri = this.topNS[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        const { tags } = this;\n        for (let index = tags.length - 1; index >= 0; index--) {\n            uri = tags[index].ns[prefix];\n            if (uri !== undefined) {\n                return uri;\n            }\n        }\n        uri = this.ns[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);\n    }\n    /**\n     * Parse a qname into its prefix and local name parts.\n     *\n     * @param name The name to parse\n     *\n     * @returns\n     */\n    qname(name) {\n        // This is faster than using name.split(\":\").\n        const colon = name.indexOf(\":\");\n        if (colon === -1) {\n            return { prefix: \"\", local: name };\n        }\n        const local = name.slice(colon + 1);\n        const prefix = name.slice(0, colon);\n        if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n            this.fail(`malformed name: ${name}.`);\n        }\n        return { prefix, local };\n    }\n    processAttribsNS() {\n        var _a;\n        const { attribList } = this;\n        const tag = this.tag;\n        {\n            // add namespace info to tag\n            const { prefix, local } = this.qname(tag.name);\n            tag.prefix = prefix;\n            tag.local = local;\n            const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : \"\";\n            if (prefix !== \"\") {\n                if (prefix === \"xmlns\") {\n                    this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n                }\n                if (uri === \"\") {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    tag.uri = prefix;\n                }\n            }\n        }\n        if (attribList.length === 0) {\n            return;\n        }\n        const { attributes } = tag;\n        const seen = new Set();\n        // Note: do not apply default ns to attributes:\n        //   http://www.w3.org/TR/REC-xml-names/#defaulting\n        for (const attr of attribList) {\n            const { name, prefix, local } = attr;\n            let uri;\n            let eqname;\n            if (prefix === \"\") {\n                uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n                eqname = name;\n            }\n            else {\n                uri = this.resolve(prefix);\n                // if there's any attributes with an undefined namespace,\n                // then fail on them now.\n                if (uri === undefined) {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    uri = prefix;\n                }\n                eqname = `{${uri}}${local}`;\n            }\n            if (seen.has(eqname)) {\n                this.fail(`duplicate attribute: ${eqname}.`);\n            }\n            seen.add(eqname);\n            attr.uri = uri;\n            attributes[name] = attr;\n        }\n        this.attribList = [];\n    }\n    processAttribsPlain() {\n        const { attribList } = this;\n        // eslint-disable-next-line prefer-destructuring\n        const attributes = this.tag.attributes;\n        for (const { name, value } of attribList) {\n            if (attributes[name] !== undefined) {\n                this.fail(`duplicate attribute: ${name}.`);\n            }\n            attributes[name] = value;\n        }\n        this.attribList = [];\n    }\n    /**\n     * Handle a complete open tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag``.\n     */\n    openTag() {\n        var _a;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = false;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        tags.push(tag);\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete self-closing tag. This parser code calls this once it has\n     * seen the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag`` and ``onclosetag``.\n     */\n    openSelfClosingTag() {\n        var _a, _b, _c;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = true;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        // eslint-disable-next-line no-unused-expressions\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        // eslint-disable-next-line no-unused-expressions\n        (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);\n        const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;\n        if (top === null) {\n            this.closedRoot = true;\n        }\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete close tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onclosetag``.\n     */\n    closeTag() {\n        const { tags, name } = this;\n        // Our state after this will be S_TEXT, no matter what, and we can clear\n        // tagName now.\n        this.state = S_TEXT;\n        this.name = \"\";\n        if (name === \"\") {\n            this.fail(\"weird empty close tag.\");\n            this.text += \"</>\";\n            return;\n        }\n        const handler = this.closeTagHandler;\n        let l = tags.length;\n        while (l-- > 0) {\n            const tag = this.tag = tags.pop();\n            this.topNS = tag.ns;\n            // eslint-disable-next-line no-unused-expressions\n            handler === null || handler === void 0 ? void 0 : handler(tag);\n            if (tag.name === name) {\n                break;\n            }\n            this.fail(\"unexpected close tag.\");\n        }\n        if (l === 0) {\n            this.closedRoot = true;\n        }\n        else if (l < 0) {\n            this.fail(`unmatched closing tag: ${name}.`);\n            this.text += `</${name}>`;\n        }\n    }\n    /**\n     * Resolves an entity. Makes any necessary well-formedness checks.\n     *\n     * @param entity The entity to resolve.\n     *\n     * @returns The parsed entity.\n     */\n    parseEntity(entity) {\n        // startsWith would be significantly slower for this test.\n        // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n        if (entity[0] !== \"#\") {\n            const defined = this.ENTITIES[entity];\n            if (defined !== undefined) {\n                return defined;\n            }\n            this.fail(this.isName(entity) ? \"undefined entity.\" :\n                \"disallowed character in entity name.\");\n            return `&${entity};`;\n        }\n        let num = NaN;\n        if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n            num = parseInt(entity.slice(2), 16);\n        }\n        else if (/^#[0-9]+$/.test(entity)) {\n            num = parseInt(entity.slice(1), 10);\n        }\n        // The character reference is required to match the CHAR production.\n        if (!this.isChar(num)) {\n            this.fail(\"malformed character entity.\");\n            return `&${entity};`;\n        }\n        return String.fromCodePoint(num);\n    }\n}\nexports.SaxesParser = SaxesParser;\n//# sourceMappingURL=saxes.js.map"]},"metadata":{},"sourceType":"script"}