{"ast":null,"code":"\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst {\n  filter,\n  FILTER_ACCEPT,\n  FILTER_REJECT,\n  FILTER_SKIP\n} = require(\"./helpers\");\n\nconst FIRST = false;\nconst LAST = true;\nconst NEXT = false;\nconst PREVIOUS = true;\nexports.implementation = class TreeWalkerImpl {\n  constructor(globalObject, args, privateData) {\n    this._active = false;\n    this.root = privateData.root;\n    this.currentNode = this.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n    this._globalObject = globalObject;\n  }\n\n  get currentNode() {\n    return this._currentNode;\n  }\n\n  set currentNode(node) {\n    if (node === null) {\n      throw DOMException.create(this._globalObject, [\"Cannot set currentNode to null\", \"NotSupportedError\"]);\n    }\n\n    this._currentNode = node;\n  }\n\n  parentNode() {\n    let node = this._currentNode;\n\n    while (node !== null && node !== this.root) {\n      node = node.parentNode;\n\n      if (node !== null && filter(this, node) === FILTER_ACCEPT) {\n        return this._currentNode = node;\n      }\n    }\n\n    return null;\n  }\n\n  firstChild() {\n    return this._traverseChildren(FIRST);\n  }\n\n  lastChild() {\n    return this._traverseChildren(LAST);\n  }\n\n  previousSibling() {\n    return this._traverseSiblings(PREVIOUS);\n  }\n\n  nextSibling() {\n    return this._traverseSiblings(NEXT);\n  }\n\n  previousNode() {\n    let node = this._currentNode;\n\n    while (node !== this.root) {\n      let sibling = node.previousSibling;\n\n      while (sibling !== null) {\n        node = sibling;\n        let result = filter(this, node);\n\n        while (result !== FILTER_REJECT && node.hasChildNodes()) {\n          node = node.lastChild;\n          result = filter(this, node);\n        }\n\n        if (result === FILTER_ACCEPT) {\n          return this._currentNode = node;\n        }\n\n        sibling = node.previousSibling;\n      }\n\n      if (node === this.root || node.parentNode === null) {\n        return null;\n      }\n\n      node = node.parentNode;\n\n      if (filter(this, node) === FILTER_ACCEPT) {\n        return this._currentNode = node;\n      }\n    }\n\n    return null;\n  }\n\n  nextNode() {\n    let node = this._currentNode;\n    let result = FILTER_ACCEPT;\n\n    for (;;) {\n      while (result !== FILTER_REJECT && node.hasChildNodes()) {\n        node = node.firstChild;\n        result = filter(this, node);\n\n        if (result === FILTER_ACCEPT) {\n          return this._currentNode = node;\n        }\n      }\n\n      do {\n        if (node === this.root) {\n          return null;\n        }\n\n        const sibling = node.nextSibling;\n\n        if (sibling !== null) {\n          node = sibling;\n          break;\n        }\n\n        node = node.parentNode;\n      } while (node !== null);\n\n      if (node === null) {\n        return null;\n      }\n\n      result = filter(this, node);\n\n      if (result === FILTER_ACCEPT) {\n        return this._currentNode = node;\n      }\n    }\n  }\n\n  _traverseChildren(type) {\n    let node = this._currentNode;\n    node = type === FIRST ? node.firstChild : node.lastChild;\n\n    if (node === null) {\n      return null;\n    }\n\n    main: for (;;) {\n      const result = filter(this, node);\n\n      if (result === FILTER_ACCEPT) {\n        return this._currentNode = node;\n      }\n\n      if (result === FILTER_SKIP) {\n        const child = type === FIRST ? node.firstChild : node.lastChild;\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      for (;;) {\n        const sibling = type === FIRST ? node.nextSibling : node.previousSibling;\n\n        if (sibling !== null) {\n          node = sibling;\n          continue main;\n        }\n\n        const parent = node.parentNode;\n\n        if (parent === null || parent === this.root || parent === this._currentNode) {\n          return null;\n        }\n\n        node = parent;\n      }\n    }\n  }\n\n  _traverseSiblings(type) {\n    let node = this._currentNode;\n\n    if (node === this.root) {\n      return null;\n    }\n\n    for (;;) {\n      let sibling = type === NEXT ? node.nextSibling : node.previousSibling;\n\n      while (sibling !== null) {\n        node = sibling;\n        const result = filter(this, node);\n\n        if (result === FILTER_ACCEPT) {\n          return this._currentNode = node;\n        }\n\n        sibling = type === NEXT ? node.firstChild : node.lastChild;\n\n        if (result === FILTER_REJECT || sibling === null) {\n          sibling = type === NEXT ? node.nextSibling : node.previousSibling;\n        }\n      }\n\n      node = node.parentNode;\n\n      if (node === null || node === this.root) {\n        return null;\n      }\n\n      if (filter(this, node) === FILTER_ACCEPT) {\n        return null;\n      }\n    }\n  }\n\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/jsdom/lib/jsdom/living/traversal/TreeWalker-impl.js"],"names":["DOMException","require","filter","FILTER_ACCEPT","FILTER_REJECT","FILTER_SKIP","FIRST","LAST","NEXT","PREVIOUS","exports","implementation","TreeWalkerImpl","constructor","globalObject","args","privateData","_active","root","currentNode","whatToShow","_globalObject","_currentNode","node","create","parentNode","firstChild","_traverseChildren","lastChild","previousSibling","_traverseSiblings","nextSibling","previousNode","sibling","result","hasChildNodes","nextNode","type","main","child","parent"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst { filter, FILTER_ACCEPT, FILTER_REJECT, FILTER_SKIP } = require(\"./helpers\");\n\nconst FIRST = false;\nconst LAST = true;\nconst NEXT = false;\nconst PREVIOUS = true;\n\nexports.implementation = class TreeWalkerImpl {\n  constructor(globalObject, args, privateData) {\n    this._active = false;\n    this.root = privateData.root;\n    this.currentNode = this.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n\n    this._globalObject = globalObject;\n  }\n\n  get currentNode() {\n    return this._currentNode;\n  }\n\n  set currentNode(node) {\n    if (node === null) {\n      throw DOMException.create(this._globalObject, [\"Cannot set currentNode to null\", \"NotSupportedError\"]);\n    }\n\n    this._currentNode = node;\n  }\n\n  parentNode() {\n    let node = this._currentNode;\n    while (node !== null && node !== this.root) {\n      node = node.parentNode;\n\n      if (node !== null && filter(this, node) === FILTER_ACCEPT) {\n        return (this._currentNode = node);\n      }\n    }\n    return null;\n  }\n\n  firstChild() {\n    return this._traverseChildren(FIRST);\n  }\n\n  lastChild() {\n    return this._traverseChildren(LAST);\n  }\n\n  previousSibling() {\n    return this._traverseSiblings(PREVIOUS);\n  }\n\n  nextSibling() {\n    return this._traverseSiblings(NEXT);\n  }\n\n  previousNode() {\n    let node = this._currentNode;\n\n    while (node !== this.root) {\n      let sibling = node.previousSibling;\n\n      while (sibling !== null) {\n        node = sibling;\n        let result = filter(this, node);\n\n        while (result !== FILTER_REJECT && node.hasChildNodes()) {\n          node = node.lastChild;\n          result = filter(this, node);\n        }\n\n        if (result === FILTER_ACCEPT) {\n          return (this._currentNode = node);\n        }\n\n        sibling = node.previousSibling;\n      }\n\n      if (node === this.root || node.parentNode === null) {\n        return null;\n      }\n\n      node = node.parentNode;\n\n      if (filter(this, node) === FILTER_ACCEPT) {\n        return (this._currentNode = node);\n      }\n    }\n\n    return null;\n  }\n\n  nextNode() {\n    let node = this._currentNode;\n    let result = FILTER_ACCEPT;\n\n    for (;;) {\n      while (result !== FILTER_REJECT && node.hasChildNodes()) {\n        node = node.firstChild;\n        result = filter(this, node);\n        if (result === FILTER_ACCEPT) {\n          return (this._currentNode = node);\n        }\n      }\n\n      do {\n        if (node === this.root) {\n          return null;\n        }\n\n        const sibling = node.nextSibling;\n\n        if (sibling !== null) {\n          node = sibling;\n          break;\n        }\n\n        node = node.parentNode;\n      } while (node !== null);\n\n      if (node === null) {\n        return null;\n      }\n\n      result = filter(this, node);\n\n      if (result === FILTER_ACCEPT) {\n        return (this._currentNode = node);\n      }\n    }\n  }\n\n  _traverseChildren(type) {\n    let node = this._currentNode;\n    node = type === FIRST ? node.firstChild : node.lastChild;\n\n    if (node === null) {\n      return null;\n    }\n\n    main: for (;;) {\n      const result = filter(this, node);\n\n      if (result === FILTER_ACCEPT) {\n        return (this._currentNode = node);\n      }\n\n      if (result === FILTER_SKIP) {\n        const child = type === FIRST ? node.firstChild : node.lastChild;\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      for (;;) {\n        const sibling = type === FIRST ? node.nextSibling : node.previousSibling;\n\n        if (sibling !== null) {\n          node = sibling;\n          continue main;\n        }\n\n        const parent = node.parentNode;\n\n        if (parent === null || parent === this.root || parent === this._currentNode) {\n          return null;\n        }\n\n        node = parent;\n      }\n    }\n  }\n\n  _traverseSiblings(type) {\n    let node = this._currentNode;\n\n    if (node === this.root) {\n      return null;\n    }\n\n    for (;;) {\n      let sibling = type === NEXT ? node.nextSibling : node.previousSibling;\n\n      while (sibling !== null) {\n        node = sibling;\n        const result = filter(this, node);\n\n        if (result === FILTER_ACCEPT) {\n          return (this._currentNode = node);\n        }\n\n        sibling = type === NEXT ? node.firstChild : node.lastChild;\n\n        if (result === FILTER_REJECT || sibling === null) {\n          sibling = type === NEXT ? node.nextSibling : node.previousSibling;\n        }\n      }\n\n      node = node.parentNode;\n\n      if (node === null || node === this.root) {\n        return null;\n      }\n\n      if (filter(this, node) === FILTER_ACCEPT) {\n        return null;\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}