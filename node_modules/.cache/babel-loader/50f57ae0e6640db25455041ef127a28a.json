{"ast":null,"code":"\"use strict\"; // https://infra.spec.whatwg.org/#ascii-whitespace\n\nconst asciiWhitespaceRe = /^[\\t\\n\\f\\r ]$/;\nexports.asciiWhitespaceRe = asciiWhitespaceRe; // https://infra.spec.whatwg.org/#ascii-lowercase\n\nexports.asciiLowercase = s => {\n  return s.replace(/[A-Z]/g, l => l.toLowerCase());\n}; // https://infra.spec.whatwg.org/#ascii-uppercase\n\n\nexports.asciiUppercase = s => {\n  return s.replace(/[a-z]/g, l => l.toUpperCase());\n}; // https://infra.spec.whatwg.org/#strip-newlines\n\n\nexports.stripNewlines = s => {\n  return s.replace(/[\\n\\r]+/g, \"\");\n}; // https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n\n\nexports.stripLeadingAndTrailingASCIIWhitespace = s => {\n  return s.replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\n}; // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\n\nexports.stripAndCollapseASCIIWhitespace = s => {\n  return s.replace(/[ \\t\\n\\f\\r]+/g, \" \").replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\n}; // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-simple-colour\n\n\nexports.isValidSimpleColor = s => {\n  return /^#[a-fA-F\\d]{6}$/.test(s);\n}; // https://infra.spec.whatwg.org/#ascii-case-insensitive\n\n\nexports.asciiCaseInsensitiveMatch = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n\n  return true;\n}; // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-integers\n// Error is represented as null.\n\n\nconst parseInteger = exports.parseInteger = input => {\n  // The implementation here is slightly different from the spec's. We want to use parseInt(), but parseInt() trims\n  // Unicode whitespace in addition to just ASCII ones, so we make sure that the trimmed prefix contains only ASCII\n  // whitespace ourselves.\n  const numWhitespace = input.length - input.trimStart().length;\n\n  if (/[^\\t\\n\\f\\r ]/.test(input.slice(0, numWhitespace))) {\n    return null;\n  } // We don't allow hexadecimal numbers here.\n  // eslint-disable-next-line radix\n\n\n  const value = parseInt(input, 10);\n\n  if (Number.isNaN(value)) {\n    return null;\n  } // parseInt() returns -0 for \"-0\". Normalize that here.\n\n\n  return value === 0 ? 0 : value;\n}; // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-non-negative-integers\n// Error is represented as null.\n\n\nexports.parseNonNegativeInteger = input => {\n  const value = parseInteger(input);\n\n  if (value === null) {\n    return null;\n  }\n\n  if (value < 0) {\n    return null;\n  }\n\n  return value;\n}; // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#valid-floating-point-number\n\n\nconst floatingPointNumRe = /^-?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?$/;\n\nexports.isValidFloatingPointNumber = str => floatingPointNumRe.test(str); // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-floating-point-number-values\n// Error is represented as null.\n\n\nexports.parseFloatingPointNumber = str => {\n  // The implementation here is slightly different from the spec's. We need to use parseFloat() in order to retain\n  // accuracy, but parseFloat() trims Unicode whitespace in addition to just ASCII ones, so we make sure that the\n  // trimmed prefix contains only ASCII whitespace ourselves.\n  const numWhitespace = str.length - str.trimStart().length;\n\n  if (/[^\\t\\n\\f\\r ]/.test(str.slice(0, numWhitespace))) {\n    return null;\n  }\n\n  const parsed = parseFloat(str);\n  return isFinite(parsed) ? parsed : null;\n}; // https://infra.spec.whatwg.org/#split-on-ascii-whitespace\n\n\nexports.splitOnASCIIWhitespace = str => {\n  let position = 0;\n  const tokens = [];\n\n  while (position < str.length && asciiWhitespaceRe.test(str[position])) {\n    position++;\n  }\n\n  if (position === str.length) {\n    return tokens;\n  }\n\n  while (position < str.length) {\n    const start = position;\n\n    while (position < str.length && !asciiWhitespaceRe.test(str[position])) {\n      position++;\n    }\n\n    tokens.push(str.slice(start, position));\n\n    while (position < str.length && asciiWhitespaceRe.test(str[position])) {\n      position++;\n    }\n  }\n\n  return tokens;\n}; // https://infra.spec.whatwg.org/#split-on-commas\n\n\nexports.splitOnCommas = str => {\n  let position = 0;\n  const tokens = [];\n\n  while (position < str.length) {\n    let start = position;\n\n    while (position < str.length && str[position] !== \",\") {\n      position++;\n    }\n\n    let end = position;\n\n    while (start < str.length && asciiWhitespaceRe.test(str[start])) {\n      start++;\n    }\n\n    while (end > start && asciiWhitespaceRe.test(str[end - 1])) {\n      end--;\n    }\n\n    tokens.push(str.slice(start, end));\n\n    if (position < str.length) {\n      position++;\n    }\n  }\n\n  return tokens;\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/jsdom/lib/jsdom/living/helpers/strings.js"],"names":["asciiWhitespaceRe","exports","asciiLowercase","s","replace","l","toLowerCase","asciiUppercase","toUpperCase","stripNewlines","stripLeadingAndTrailingASCIIWhitespace","stripAndCollapseASCIIWhitespace","isValidSimpleColor","test","asciiCaseInsensitiveMatch","a","b","length","i","charCodeAt","parseInteger","input","numWhitespace","trimStart","slice","value","parseInt","Number","isNaN","parseNonNegativeInteger","floatingPointNumRe","isValidFloatingPointNumber","str","parseFloatingPointNumber","parsed","parseFloat","isFinite","splitOnASCIIWhitespace","position","tokens","start","push","splitOnCommas","end"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// https://infra.spec.whatwg.org/#ascii-whitespace\nconst asciiWhitespaceRe = /^[\\t\\n\\f\\r ]$/;\nexports.asciiWhitespaceRe = asciiWhitespaceRe;\n\n// https://infra.spec.whatwg.org/#ascii-lowercase\nexports.asciiLowercase = s => {\n  return s.replace(/[A-Z]/g, l => l.toLowerCase());\n};\n\n// https://infra.spec.whatwg.org/#ascii-uppercase\nexports.asciiUppercase = s => {\n  return s.replace(/[a-z]/g, l => l.toUpperCase());\n};\n\n// https://infra.spec.whatwg.org/#strip-newlines\nexports.stripNewlines = s => {\n  return s.replace(/[\\n\\r]+/g, \"\");\n};\n\n// https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\nexports.stripLeadingAndTrailingASCIIWhitespace = s => {\n  return s.replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\n};\n\n// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\nexports.stripAndCollapseASCIIWhitespace = s => {\n  return s.replace(/[ \\t\\n\\f\\r]+/g, \" \").replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\n};\n\n// https://html.spec.whatwg.org/multipage/infrastructure.html#valid-simple-colour\nexports.isValidSimpleColor = s => {\n  return /^#[a-fA-F\\d]{6}$/.test(s);\n};\n\n// https://infra.spec.whatwg.org/#ascii-case-insensitive\nexports.asciiCaseInsensitiveMatch = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n// https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-integers\n// Error is represented as null.\nconst parseInteger = exports.parseInteger = input => {\n  // The implementation here is slightly different from the spec's. We want to use parseInt(), but parseInt() trims\n  // Unicode whitespace in addition to just ASCII ones, so we make sure that the trimmed prefix contains only ASCII\n  // whitespace ourselves.\n  const numWhitespace = input.length - input.trimStart().length;\n  if (/[^\\t\\n\\f\\r ]/.test(input.slice(0, numWhitespace))) {\n    return null;\n  }\n  // We don't allow hexadecimal numbers here.\n  // eslint-disable-next-line radix\n  const value = parseInt(input, 10);\n  if (Number.isNaN(value)) {\n    return null;\n  }\n  // parseInt() returns -0 for \"-0\". Normalize that here.\n  return value === 0 ? 0 : value;\n};\n\n// https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-non-negative-integers\n// Error is represented as null.\nexports.parseNonNegativeInteger = input => {\n  const value = parseInteger(input);\n  if (value === null) {\n    return null;\n  }\n  if (value < 0) {\n    return null;\n  }\n  return value;\n};\n\n// https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#valid-floating-point-number\nconst floatingPointNumRe = /^-?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?$/;\nexports.isValidFloatingPointNumber = str => floatingPointNumRe.test(str);\n\n// https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-floating-point-number-values\n// Error is represented as null.\nexports.parseFloatingPointNumber = str => {\n  // The implementation here is slightly different from the spec's. We need to use parseFloat() in order to retain\n  // accuracy, but parseFloat() trims Unicode whitespace in addition to just ASCII ones, so we make sure that the\n  // trimmed prefix contains only ASCII whitespace ourselves.\n  const numWhitespace = str.length - str.trimStart().length;\n  if (/[^\\t\\n\\f\\r ]/.test(str.slice(0, numWhitespace))) {\n    return null;\n  }\n  const parsed = parseFloat(str);\n  return isFinite(parsed) ? parsed : null;\n};\n\n// https://infra.spec.whatwg.org/#split-on-ascii-whitespace\nexports.splitOnASCIIWhitespace = str => {\n  let position = 0;\n  const tokens = [];\n  while (position < str.length && asciiWhitespaceRe.test(str[position])) {\n    position++;\n  }\n  if (position === str.length) {\n    return tokens;\n  }\n  while (position < str.length) {\n    const start = position;\n    while (position < str.length && !asciiWhitespaceRe.test(str[position])) {\n      position++;\n    }\n    tokens.push(str.slice(start, position));\n    while (position < str.length && asciiWhitespaceRe.test(str[position])) {\n      position++;\n    }\n  }\n  return tokens;\n};\n\n// https://infra.spec.whatwg.org/#split-on-commas\nexports.splitOnCommas = str => {\n  let position = 0;\n  const tokens = [];\n  while (position < str.length) {\n    let start = position;\n    while (position < str.length && str[position] !== \",\") {\n      position++;\n    }\n    let end = position;\n    while (start < str.length && asciiWhitespaceRe.test(str[start])) {\n      start++;\n    }\n    while (end > start && asciiWhitespaceRe.test(str[end - 1])) {\n      end--;\n    }\n    tokens.push(str.slice(start, end));\n    if (position < str.length) {\n      position++;\n    }\n  }\n  return tokens;\n};\n"]},"metadata":{},"sourceType":"script"}