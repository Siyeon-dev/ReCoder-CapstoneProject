{"ast":null,"code":"\"use strict\";\n\nconst parse5 = require(\"parse5\");\n\nconst {\n  createElement\n} = require(\"../../living/helpers/create-element\");\n\nconst DocumentType = require(\"../../living/generated/DocumentType\");\n\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\n\nconst Text = require(\"../../living/generated/Text\");\n\nconst Comment = require(\"../../living/generated/Comment\");\n\nconst attributes = require(\"../../living/attributes\");\n\nconst nodeTypes = require(\"../../living/node-type\");\n\nconst serializationAdapter = require(\"../../living/domparsing/parse5-adapter-serialization\");\n\nconst {\n  customElementReactionsStack,\n  invokeCEReactions,\n  lookupCEDefinition\n} = require(\"../../living/helpers/custom-elements\"); // Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237 and\n// https://github.com/inikulin/parse5/issues/285.\n\n\nconst OpenElementStack = require(\"parse5/lib/parser/open-element-stack\");\n\nconst openElementStackOriginalPush = OpenElementStack.prototype.push;\n\nOpenElementStack.prototype.push = function (...args) {\n  openElementStackOriginalPush.apply(this, args);\n  this.treeAdapter._currentElement = this.current;\n  const after = this.items[this.stackTop];\n\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\n\nconst openElementStackOriginalPop = OpenElementStack.prototype.pop;\n\nOpenElementStack.prototype.pop = function (...args) {\n  const before = this.items[this.stackTop];\n  openElementStackOriginalPop.apply(this, args);\n  this.treeAdapter._currentElement = this.current;\n\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\n\nclass JSDOMParse5Adapter {\n  constructor(documentImpl, options = {}) {\n    this._documentImpl = documentImpl;\n    this._globalObject = documentImpl._globalObject;\n    this._fragment = options.fragment || false; // Since the createElement hook doesn't provide the parent element, we keep track of this using _currentElement:\n    // https://github.com/inikulin/parse5/issues/285. See above horrible monkey-patch for how this is maintained.\n\n    this._currentElement = undefined;\n  }\n\n  _ownerDocument() {\n    const {\n      _currentElement\n    } = this; // The _currentElement is undefined when parsing elements at the root of the document.\n\n    if (_currentElement) {\n      return _currentElement.localName === \"template\" ? _currentElement.content._ownerDocument : _currentElement._ownerDocument;\n    }\n\n    return this._documentImpl;\n  }\n\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n\n  createDocumentFragment() {\n    const ownerDocument = this._ownerDocument();\n\n    return DocumentFragment.createImpl(this._globalObject, [], {\n      ownerDocument\n    });\n  } // https://html.spec.whatwg.org/#create-an-element-for-the-token\n\n\n  createElement(localName, namespace, attrs) {\n    const ownerDocument = this._ownerDocument();\n\n    const isAttribute = attrs.find(attr => attr.name === \"is\");\n    const isValue = isAttribute ? isAttribute.value : null;\n    const definition = lookupCEDefinition(ownerDocument, namespace, localName);\n    let willExecuteScript = false;\n\n    if (definition !== null && !this._fragment) {\n      willExecuteScript = true;\n    }\n\n    if (willExecuteScript) {\n      ownerDocument._throwOnDynamicMarkupInsertionCounter++;\n      customElementReactionsStack.push([]);\n    }\n\n    const element = createElement(ownerDocument, localName, namespace, null, isValue, willExecuteScript);\n    this.adoptAttributes(element, attrs);\n\n    if (willExecuteScript) {\n      const queue = customElementReactionsStack.pop();\n      invokeCEReactions(queue);\n      ownerDocument._throwOnDynamicMarkupInsertionCounter--;\n    }\n\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n\n    return element;\n  }\n\n  createCommentNode(data) {\n    const ownerDocument = this._ownerDocument();\n\n    return Comment.createImpl(this._globalObject, [], {\n      data,\n      ownerDocument\n    });\n  }\n\n  appendChild(parentNode, newNode) {\n    parentNode._append(newNode);\n  }\n\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode._insert(newNode, referenceNode);\n  }\n\n  setTemplateContent(templateElement, contentFragment) {\n    // This code makes the glue between jsdom and parse5 HTMLTemplateElement parsing:\n    //\n    // * jsdom during the construction of the HTMLTemplateElement (for example when create via\n    //   `document.createElement(\"template\")`), creates a DocumentFragment and set it into _templateContents.\n    // * parse5 when parsing a <template> tag creates an HTMLTemplateElement (`createElement` adapter hook) and also\n    //   create a DocumentFragment (`createDocumentFragment` adapter hook).\n    //\n    // At this point we now have to replace the one created in jsdom with one created by parse5.\n    const {\n      _ownerDocument,\n      _host\n    } = templateElement._templateContents;\n    contentFragment._ownerDocument = _ownerDocument;\n    contentFragment._host = _host;\n    templateElement._templateContents = contentFragment;\n  }\n\n  setDocumentType(document, name, publicId, systemId) {\n    const ownerDocument = this._ownerDocument();\n\n    const documentType = DocumentType.createImpl(this._globalObject, [], {\n      name,\n      publicId,\n      systemId,\n      ownerDocument\n    });\n\n    document._append(documentType);\n  }\n\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n\n  detachNode(node) {\n    node.remove();\n  }\n\n  insertText(parentNode, text) {\n    const {\n      lastChild\n    } = parentNode;\n\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n\n      const textNode = Text.createImpl(this._globalObject, [], {\n        data: text,\n        ownerDocument\n      });\n\n      parentNode._append(textNode);\n    }\n  }\n\n  insertTextBefore(parentNode, text, referenceNode) {\n    const {\n      previousSibling\n    } = referenceNode;\n\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n\n      const textNode = Text.createImpl(this._globalObject, [], {\n        data: text,\n        ownerDocument\n      });\n\n      parentNode._append(textNode, referenceNode);\n    }\n  }\n\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n\n} // Assign shared adapters with serializer.\n\n\nObject.assign(JSDOMParse5Adapter.prototype, serializationAdapter);\n\nfunction parseFragment(markup, contextElement) {\n  const ownerDocument = contextElement.localName === \"template\" ? contextElement.content._ownerDocument : contextElement._ownerDocument;\n  const config = Object.assign({}, ownerDocument._parseOptions, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument, {\n      fragment: true\n    })\n  });\n  return parse5.parseFragment(contextElement, markup, config);\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  const config = Object.assign({}, ownerDocument._parseOptions, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  });\n  return parse5.parse(markup, config);\n}\n\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/jsdom/lib/jsdom/browser/parser/html.js"],"names":["parse5","require","createElement","DocumentType","DocumentFragment","Text","Comment","attributes","nodeTypes","serializationAdapter","customElementReactionsStack","invokeCEReactions","lookupCEDefinition","OpenElementStack","openElementStackOriginalPush","prototype","push","args","apply","treeAdapter","_currentElement","current","after","items","stackTop","_pushedOnStackOfOpenElements","openElementStackOriginalPop","pop","before","_poppedOffStackOfOpenElements","JSDOMParse5Adapter","constructor","documentImpl","options","_documentImpl","_globalObject","_fragment","fragment","undefined","_ownerDocument","localName","content","createDocument","createDocumentFragment","ownerDocument","createImpl","namespace","attrs","isAttribute","find","attr","name","isValue","value","definition","willExecuteScript","_throwOnDynamicMarkupInsertionCounter","element","adoptAttributes","queue","_parserInserted","createCommentNode","data","appendChild","parentNode","newNode","_append","insertBefore","referenceNode","_insert","setTemplateContent","templateElement","contentFragment","_host","_templateContents","setDocumentType","document","publicId","systemId","documentType","setDocumentMode","mode","_mode","detachNode","node","remove","insertText","text","lastChild","nodeType","TEXT_NODE","textNode","insertTextBefore","previousSibling","prefix","setAttributeValue","Object","assign","parseFragment","markup","contextElement","config","_parseOptions","parseIntoDocument","parse","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst parse5 = require(\"parse5\");\n\nconst { createElement } = require(\"../../living/helpers/create-element\");\n\nconst DocumentType = require(\"../../living/generated/DocumentType\");\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\nconst Text = require(\"../../living/generated/Text\");\nconst Comment = require(\"../../living/generated/Comment\");\n\nconst attributes = require(\"../../living/attributes\");\nconst nodeTypes = require(\"../../living/node-type\");\n\nconst serializationAdapter = require(\"../../living/domparsing/parse5-adapter-serialization\");\nconst {\n  customElementReactionsStack, invokeCEReactions, lookupCEDefinition\n} = require(\"../../living/helpers/custom-elements\");\n\n// Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237 and\n// https://github.com/inikulin/parse5/issues/285.\nconst OpenElementStack = require(\"parse5/lib/parser/open-element-stack\");\n\nconst openElementStackOriginalPush = OpenElementStack.prototype.push;\nOpenElementStack.prototype.push = function (...args) {\n  openElementStackOriginalPush.apply(this, args);\n  this.treeAdapter._currentElement = this.current;\n\n  const after = this.items[this.stackTop];\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\n\nconst openElementStackOriginalPop = OpenElementStack.prototype.pop;\nOpenElementStack.prototype.pop = function (...args) {\n  const before = this.items[this.stackTop];\n\n  openElementStackOriginalPop.apply(this, args);\n  this.treeAdapter._currentElement = this.current;\n\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\n\nclass JSDOMParse5Adapter {\n  constructor(documentImpl, options = {}) {\n    this._documentImpl = documentImpl;\n    this._globalObject = documentImpl._globalObject;\n    this._fragment = options.fragment || false;\n\n    // Since the createElement hook doesn't provide the parent element, we keep track of this using _currentElement:\n    // https://github.com/inikulin/parse5/issues/285. See above horrible monkey-patch for how this is maintained.\n    this._currentElement = undefined;\n  }\n\n  _ownerDocument() {\n    const { _currentElement } = this;\n\n    // The _currentElement is undefined when parsing elements at the root of the document.\n    if (_currentElement) {\n      return _currentElement.localName === \"template\" ?\n        _currentElement.content._ownerDocument :\n        _currentElement._ownerDocument;\n    }\n\n    return this._documentImpl;\n  }\n\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n\n  createDocumentFragment() {\n    const ownerDocument = this._ownerDocument();\n    return DocumentFragment.createImpl(this._globalObject, [], { ownerDocument });\n  }\n\n  // https://html.spec.whatwg.org/#create-an-element-for-the-token\n  createElement(localName, namespace, attrs) {\n    const ownerDocument = this._ownerDocument();\n\n    const isAttribute = attrs.find(attr => attr.name === \"is\");\n    const isValue = isAttribute ? isAttribute.value : null;\n\n    const definition = lookupCEDefinition(ownerDocument, namespace, localName);\n\n    let willExecuteScript = false;\n    if (definition !== null && !this._fragment) {\n      willExecuteScript = true;\n    }\n\n    if (willExecuteScript) {\n      ownerDocument._throwOnDynamicMarkupInsertionCounter++;\n      customElementReactionsStack.push([]);\n    }\n\n    const element = createElement(ownerDocument, localName, namespace, null, isValue, willExecuteScript);\n    this.adoptAttributes(element, attrs);\n\n    if (willExecuteScript) {\n      const queue = customElementReactionsStack.pop();\n      invokeCEReactions(queue);\n      ownerDocument._throwOnDynamicMarkupInsertionCounter--;\n    }\n\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n\n    return element;\n  }\n\n  createCommentNode(data) {\n    const ownerDocument = this._ownerDocument();\n    return Comment.createImpl(this._globalObject, [], { data, ownerDocument });\n  }\n\n  appendChild(parentNode, newNode) {\n    parentNode._append(newNode);\n  }\n\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode._insert(newNode, referenceNode);\n  }\n\n  setTemplateContent(templateElement, contentFragment) {\n    // This code makes the glue between jsdom and parse5 HTMLTemplateElement parsing:\n    //\n    // * jsdom during the construction of the HTMLTemplateElement (for example when create via\n    //   `document.createElement(\"template\")`), creates a DocumentFragment and set it into _templateContents.\n    // * parse5 when parsing a <template> tag creates an HTMLTemplateElement (`createElement` adapter hook) and also\n    //   create a DocumentFragment (`createDocumentFragment` adapter hook).\n    //\n    // At this point we now have to replace the one created in jsdom with one created by parse5.\n    const { _ownerDocument, _host } = templateElement._templateContents;\n    contentFragment._ownerDocument = _ownerDocument;\n    contentFragment._host = _host;\n\n    templateElement._templateContents = contentFragment;\n  }\n\n  setDocumentType(document, name, publicId, systemId) {\n    const ownerDocument = this._ownerDocument();\n    const documentType = DocumentType.createImpl(this._globalObject, [], { name, publicId, systemId, ownerDocument });\n\n    document._append(documentType);\n  }\n\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n\n  detachNode(node) {\n    node.remove();\n  }\n\n  insertText(parentNode, text) {\n    const { lastChild } = parentNode;\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n      const textNode = Text.createImpl(this._globalObject, [], { data: text, ownerDocument });\n      parentNode._append(textNode);\n    }\n  }\n\n  insertTextBefore(parentNode, text, referenceNode) {\n    const { previousSibling } = referenceNode;\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n      const textNode = Text.createImpl(this._globalObject, [], { data: text, ownerDocument });\n      parentNode._append(textNode, referenceNode);\n    }\n  }\n\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n}\n\n// Assign shared adapters with serializer.\nObject.assign(JSDOMParse5Adapter.prototype, serializationAdapter);\n\nfunction parseFragment(markup, contextElement) {\n  const ownerDocument = contextElement.localName === \"template\" ?\n    contextElement.content._ownerDocument :\n    contextElement._ownerDocument;\n\n  const config = Object.assign({}, ownerDocument._parseOptions, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument, {\n      fragment: true\n    })\n  });\n\n  return parse5.parseFragment(contextElement, markup, config);\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  const config = Object.assign({}, ownerDocument._parseOptions, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  });\n\n  return parse5.parse(markup, config);\n}\n\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};\n"]},"metadata":{},"sourceType":"script"}