{"ast":null,"code":"'use strict';\n\nvar isNative = /\\.node$/;\n\nfunction forEach(obj, callback) {\n  for (var key in obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n      continue;\n    }\n\n    callback(key);\n  }\n}\n\nfunction assign(target, source) {\n  forEach(source, function (key) {\n    target[key] = source[key];\n  });\n  return target;\n}\n\nfunction clearCache(requireCache) {\n  forEach(requireCache, function (resolvedPath) {\n    if (!isNative.test(resolvedPath)) {\n      delete requireCache[resolvedPath];\n    }\n  });\n}\n\nmodule.exports = function (requireCache, callback, callbackForModulesToKeep, module) {\n  var originalCache = assign({}, requireCache);\n  clearCache(requireCache);\n\n  if (callbackForModulesToKeep) {\n    var originalModuleChildren = module.children ? module.children.slice() : false; // Creates a shallow copy of module.children\n\n    callbackForModulesToKeep(); // Lists the cache entries made by callbackForModulesToKeep()\n\n    var modulesToKeep = [];\n    forEach(requireCache, function (key) {\n      modulesToKeep.push(key);\n    }); // Discards the modules required in callbackForModulesToKeep()\n\n    clearCache(requireCache);\n\n    if (module.children) {\n      // Only true for node.js\n      module.children = originalModuleChildren; // Removes last references to modules required in callbackForModulesToKeep() -> No memory leak\n    } // Takes the cache entries of the original cache in case the modules where required before\n\n\n    for (var i = 0; i < modulesToKeep.length; i += 1) {\n      if (originalCache[modulesToKeep[i]]) {\n        requireCache[modulesToKeep[i]] = originalCache[modulesToKeep[i]];\n      }\n    }\n  }\n\n  var freshModule = callback();\n  var stealthCache = callbackForModulesToKeep ? assign({}, requireCache) : false;\n  clearCache(requireCache);\n\n  if (callbackForModulesToKeep) {\n    // In case modules to keep were required inside the stealthy require for the first time, copy them to the restored cache\n    for (var k = 0; k < modulesToKeep.length; k += 1) {\n      if (stealthCache[modulesToKeep[k]]) {\n        requireCache[modulesToKeep[k]] = stealthCache[modulesToKeep[k]];\n      }\n    }\n  }\n\n  assign(requireCache, originalCache);\n  return freshModule;\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/stealthy-require/lib/index.js"],"names":["isNative","forEach","obj","callback","key","Object","prototype","hasOwnProperty","call","assign","target","source","clearCache","requireCache","resolvedPath","test","module","exports","callbackForModulesToKeep","originalCache","originalModuleChildren","children","slice","modulesToKeep","push","i","length","freshModule","stealthCache","k"],"mappings":"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","sourcesContent":["'use strict';\n\nvar isNative = /\\.node$/;\n\nfunction forEach(obj, callback) {\n    for ( var key in obj ) {\n        if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n            continue;\n        }\n        callback(key);\n    }\n}\n\nfunction assign(target, source) {\n    forEach(source, function (key) {\n        target[key] = source[key];\n    });\n    return target;\n}\n\nfunction clearCache(requireCache) {\n    forEach(requireCache, function (resolvedPath) {\n        if (!isNative.test(resolvedPath)) {\n            delete requireCache[resolvedPath];\n        }\n    });\n}\n\nmodule.exports = function (requireCache, callback, callbackForModulesToKeep, module) {\n\n    var originalCache = assign({}, requireCache);\n    clearCache(requireCache);\n\n    if (callbackForModulesToKeep) {\n\n        var originalModuleChildren = module.children ? module.children.slice() : false; // Creates a shallow copy of module.children\n\n        callbackForModulesToKeep();\n\n        // Lists the cache entries made by callbackForModulesToKeep()\n        var modulesToKeep = [];\n        forEach(requireCache, function (key) {\n            modulesToKeep.push(key);\n        });\n\n        // Discards the modules required in callbackForModulesToKeep()\n        clearCache(requireCache);\n\n        if (module.children) { // Only true for node.js\n            module.children = originalModuleChildren; // Removes last references to modules required in callbackForModulesToKeep() -> No memory leak\n        }\n\n        // Takes the cache entries of the original cache in case the modules where required before\n        for ( var i = 0; i < modulesToKeep.length; i+=1 ) {\n            if (originalCache[modulesToKeep[i]]) {\n                requireCache[modulesToKeep[i]] = originalCache[modulesToKeep[i]];\n            }\n        }\n\n    }\n\n    var freshModule = callback();\n\n    var stealthCache = callbackForModulesToKeep ? assign({}, requireCache) : false;\n\n    clearCache(requireCache);\n\n    if (callbackForModulesToKeep) {\n        // In case modules to keep were required inside the stealthy require for the first time, copy them to the restored cache\n        for ( var k = 0; k < modulesToKeep.length; k+=1 ) {\n            if (stealthCache[modulesToKeep[k]]) {\n                requireCache[modulesToKeep[k]] = stealthCache[modulesToKeep[k]];\n            }\n        }\n    }\n\n    assign(requireCache, originalCache);\n\n    return freshModule;\n\n};\n"]},"metadata":{},"sourceType":"script"}