{"ast":null,"code":"\"use strict\";\n\nconst xnv = require(\"xml-name-validator\");\n\nconst attributeUtils = require(\"./attributes\");\n\nconst {\n  NAMESPACES,\n  VOID_ELEMENTS,\n  NODE_TYPES\n} = require(\"./constants\");\n\nconst XML_CHAR = /^(\\x09|\\x0A|\\x0D|[\\x20-\\uD7FF]|[\\uE000-\\uFFFD]|(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]))*$/;\nconst PUBID_CHAR = /^(\\x20|\\x0D|\\x0A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/;\n\nfunction asciiCaseInsensitiveMatch(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction recordNamespaceInformation(element, map, prefixMap) {\n  let defaultNamespaceAttrValue = null;\n\n  for (let i = 0; i < element.attributes.length; ++i) {\n    const attr = element.attributes[i];\n\n    if (attr.namespaceURI === NAMESPACES.XMLNS) {\n      if (attr.prefix === null) {\n        defaultNamespaceAttrValue = attr.value;\n        continue;\n      }\n\n      let namespaceDefinition = attr.value;\n\n      if (namespaceDefinition === NAMESPACES.XML) {\n        continue;\n      } // This is exactly the other way than the spec says, but that's intended.\n      // All the maps coalesce null to the empty string (explained in the\n      // spec), so instead of doing that every time, just do it once here.\n\n\n      if (namespaceDefinition === null) {\n        namespaceDefinition = \"\";\n      }\n\n      if (namespaceDefinition in map && map[namespaceDefinition].includes(attr.localName)) {\n        continue;\n      }\n\n      if (!(namespaceDefinition in map)) {\n        map[namespaceDefinition] = [];\n      }\n\n      map[namespaceDefinition].push(attr.localName);\n      prefixMap[attr.localName] = namespaceDefinition;\n    }\n  }\n\n  return defaultNamespaceAttrValue;\n}\n\nfunction serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !PUBID_CHAR.test(node.publicId)) {\n    throw new Error(\"Failed to serialize XML: document type node publicId is not well-formed.\");\n  }\n\n  if (requireWellFormed && (!XML_CHAR.test(node.systemId) || node.systemId.includes('\"') && node.systemId.includes(\"'\"))) {\n    throw new Error(\"Failed to serialize XML: document type node systemId is not well-formed.\");\n  }\n\n  let markup = `<!DOCTYPE ${node.name}`;\n\n  if (node.publicId !== \"\") {\n    markup += ` PUBLIC \"${node.publicId}\"`;\n  } else if (node.systemId !== \"\") {\n    markup += \" SYSTEM\";\n  }\n\n  if (node.systemId !== \"\") {\n    markup += ` \"${node.systemId}\"`;\n  }\n\n  return markup + \">\";\n}\n\nfunction serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && (node.target.includes(\":\") || asciiCaseInsensitiveMatch(node.target, \"xml\"))) {\n    throw new Error(\"Failed to serialize XML: processing instruction node target is not well-formed.\");\n  }\n\n  if (requireWellFormed && (!XML_CHAR.test(node.data) || node.data.includes(\"?>\"))) {\n    throw new Error(\"Failed to serialize XML: processing instruction node data is not well-formed.\");\n  }\n\n  return `<?${node.target} ${node.data}?>`;\n}\n\nfunction serializeDocument(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (requireWellFormed && node.documentElement === null) {\n    throw new Error(\"Failed to serialize XML: document does not have a document element.\");\n  }\n\n  let serializedDocument = \"\";\n\n  for (const child of node.childNodes) {\n    serializedDocument += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);\n  }\n\n  return serializedDocument;\n}\n\nfunction serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs) {\n  let markup = \"\";\n\n  for (const child of node.childNodes) {\n    markup += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);\n  }\n\n  return markup;\n}\n\nfunction serializeText(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: text node data is not well-formed.\");\n  }\n\n  return node.data.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\n\nfunction serializeComment(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: comment node data is not well-formed.\");\n  }\n\n  if (requireWellFormed && (node.data.includes(\"--\") || node.data.endsWith(\"-\"))) {\n    throw new Error(\"Failed to serialize XML: found hyphens in illegal places in comment node data.\");\n  }\n\n  return `<!--${node.data}-->`;\n}\n\nfunction serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (requireWellFormed && (node.localName.includes(\":\") || !xnv.name(node.localName))) {\n    throw new Error(\"Failed to serialize XML: element node localName is not a valid XML name.\");\n  }\n\n  let markup = \"<\";\n  let qualifiedName = \"\";\n  let skipEndTag = false;\n  let ignoreNamespaceDefinitionAttr = false;\n  const map = Object.assign({}, prefixMap);\n  const localPrefixesMap = Object.create(null);\n  const localDefaultNamespace = recordNamespaceInformation(node, map, localPrefixesMap);\n  let inheritedNs = namespace;\n  const ns = node.namespaceURI;\n\n  if (inheritedNs === ns) {\n    if (localDefaultNamespace !== null) {\n      ignoreNamespaceDefinitionAttr = true;\n    }\n\n    if (ns === NAMESPACES.XML) {\n      qualifiedName = \"xml:\" + node.localName;\n    } else {\n      qualifiedName = node.localName;\n    }\n\n    markup += qualifiedName;\n  } else {\n    let {\n      prefix\n    } = node;\n    let candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);\n\n    if (prefix === \"xmlns\") {\n      if (requireWellFormed) {\n        throw new Error(\"Failed to serialize XML: element nodes can't have a prefix of \\\"xmlns\\\".\");\n      }\n\n      candidatePrefix = \"xmlns\";\n    }\n\n    if (candidatePrefix !== null) {\n      qualifiedName = candidatePrefix + \":\" + node.localName;\n\n      if (localDefaultNamespace !== null && localDefaultNamespace !== NAMESPACES.XML) {\n        inheritedNs = localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n\n      markup += qualifiedName;\n    } else if (prefix !== null) {\n      if (prefix in localPrefixesMap) {\n        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);\n      }\n\n      if (map[ns]) {\n        map[ns].push(prefix);\n      } else {\n        map[ns] = [prefix];\n      }\n\n      qualifiedName = prefix + \":\" + node.localName;\n      markup += `${qualifiedName} xmlns:${prefix}=\"${attributeUtils.serializeAttributeValue(ns, requireWellFormed)}\"`;\n\n      if (localDefaultNamespace !== null) {\n        inheritedNs = localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {\n      ignoreNamespaceDefinitionAttr = true;\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += `${qualifiedName} xmlns=\"${attributeUtils.serializeAttributeValue(ns, requireWellFormed)}\"`;\n    } else {\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += qualifiedName;\n    }\n  }\n\n  markup += attributeUtils.serializeAttributes(node, map, localPrefixesMap, ignoreNamespaceDefinitionAttr, requireWellFormed, refs);\n\n  if (ns === NAMESPACES.HTML && node.childNodes.length === 0 && VOID_ELEMENTS.has(node.localName)) {\n    markup += \" /\";\n    skipEndTag = true;\n  } else if (ns !== NAMESPACES.HTML && node.childNodes.length === 0) {\n    markup += \"/\";\n    skipEndTag = true;\n  }\n\n  markup += \">\";\n\n  if (skipEndTag) {\n    return markup;\n  }\n\n  if (ns === NAMESPACES.HTML && node.localName === \"template\") {\n    markup += xmlSerialization(node.content, inheritedNs, map, requireWellFormed, refs);\n  } else {\n    for (const child of node.childNodes) {\n      markup += xmlSerialization(child, inheritedNs, map, requireWellFormed, refs);\n    }\n  }\n\n  markup += `</${qualifiedName}>`;\n  return markup;\n}\n\nfunction serializeCDATASection(node) {\n  return \"<![CDATA[\" + node.data + \"]]>\";\n}\n/**\n * @param {{prefixIndex: number}} refs\n */\n\n\nfunction xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {\n  switch (node.nodeType) {\n    case NODE_TYPES.ELEMENT_NODE:\n      return serializeElement(node, namespace, prefixMap, requireWellFormed, refs);\n\n    case NODE_TYPES.DOCUMENT_NODE:\n      return serializeDocument(node, namespace, prefixMap, requireWellFormed, refs);\n\n    case NODE_TYPES.COMMENT_NODE:\n      return serializeComment(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.TEXT_NODE:\n      return serializeText(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs);\n\n    case NODE_TYPES.DOCUMENT_TYPE_NODE:\n      return serializeDocumentType(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:\n      return serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.ATTRIBUTE_NODE:\n      return \"\";\n\n    case NODE_TYPES.CDATA_SECTION_NODE:\n      return serializeCDATASection(node);\n\n    default:\n      throw new TypeError(\"Failed to serialize XML: only Nodes can be serialized.\");\n  }\n}\n\nmodule.exports = (root, {\n  requireWellFormed = false\n} = {}) => {\n  const namespacePrefixMap = Object.create(null);\n  namespacePrefixMap[\"http://www.w3.org/XML/1998/namespace\"] = [\"xml\"];\n  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {\n    prefixIndex: 1\n  });\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/w3c-xmlserializer/lib/serialize.js"],"names":["xnv","require","attributeUtils","NAMESPACES","VOID_ELEMENTS","NODE_TYPES","XML_CHAR","PUBID_CHAR","asciiCaseInsensitiveMatch","a","b","length","i","charCodeAt","recordNamespaceInformation","element","map","prefixMap","defaultNamespaceAttrValue","attributes","attr","namespaceURI","XMLNS","prefix","value","namespaceDefinition","XML","includes","localName","push","serializeDocumentType","node","namespace","requireWellFormed","test","publicId","Error","systemId","markup","name","serializeProcessingInstruction","target","data","serializeDocument","refs","documentElement","serializedDocument","child","childNodes","xmlSerialization","serializeDocumentFragment","serializeText","replace","serializeComment","endsWith","serializeElement","qualifiedName","skipEndTag","ignoreNamespaceDefinitionAttr","Object","assign","localPrefixesMap","create","localDefaultNamespace","inheritedNs","ns","candidatePrefix","preferredPrefixString","generatePrefix","prefixIndex","serializeAttributeValue","serializeAttributes","HTML","has","content","serializeCDATASection","nodeType","ELEMENT_NODE","DOCUMENT_NODE","COMMENT_NODE","TEXT_NODE","DOCUMENT_FRAGMENT_NODE","DOCUMENT_TYPE_NODE","PROCESSING_INSTRUCTION_NODE","ATTRIBUTE_NODE","CDATA_SECTION_NODE","TypeError","module","exports","root","namespacePrefixMap"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst xnv = require(\"xml-name-validator\");\n\nconst attributeUtils = require(\"./attributes\");\nconst { NAMESPACES, VOID_ELEMENTS, NODE_TYPES } = require(\"./constants\");\n\nconst XML_CHAR = /^(\\x09|\\x0A|\\x0D|[\\x20-\\uD7FF]|[\\uE000-\\uFFFD]|(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]))*$/;\nconst PUBID_CHAR = /^(\\x20|\\x0D|\\x0A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/;\n\nfunction asciiCaseInsensitiveMatch(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction recordNamespaceInformation(element, map, prefixMap) {\n  let defaultNamespaceAttrValue = null;\n  for (let i = 0; i < element.attributes.length; ++i) {\n    const attr = element.attributes[i];\n    if (attr.namespaceURI === NAMESPACES.XMLNS) {\n      if (attr.prefix === null) {\n        defaultNamespaceAttrValue = attr.value;\n        continue;\n      }\n      let namespaceDefinition = attr.value;\n      if (namespaceDefinition === NAMESPACES.XML) {\n        continue;\n      }\n      // This is exactly the other way than the spec says, but that's intended.\n      // All the maps coalesce null to the empty string (explained in the\n      // spec), so instead of doing that every time, just do it once here.\n      if (namespaceDefinition === null) {\n        namespaceDefinition = \"\";\n      }\n\n      if (\n        namespaceDefinition in map &&\n        map[namespaceDefinition].includes(attr.localName)\n      ) {\n        continue;\n      }\n      if (!(namespaceDefinition in map)) {\n        map[namespaceDefinition] = [];\n      }\n      map[namespaceDefinition].push(attr.localName);\n      prefixMap[attr.localName] = namespaceDefinition;\n    }\n  }\n  return defaultNamespaceAttrValue;\n}\n\nfunction serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !PUBID_CHAR.test(node.publicId)) {\n    throw new Error(\"Failed to serialize XML: document type node publicId is not well-formed.\");\n  }\n\n  if (\n    requireWellFormed &&\n    (!XML_CHAR.test(node.systemId) ||\n      (node.systemId.includes('\"') && node.systemId.includes(\"'\")))\n  ) {\n    throw new Error(\"Failed to serialize XML: document type node systemId is not well-formed.\");\n  }\n\n  let markup = `<!DOCTYPE ${node.name}`;\n  if (node.publicId !== \"\") {\n    markup += ` PUBLIC \"${node.publicId}\"`;\n  } else if (node.systemId !== \"\") {\n    markup += \" SYSTEM\";\n  }\n  if (node.systemId !== \"\") {\n    markup += ` \"${node.systemId}\"`;\n  }\n  return markup + \">\";\n}\n\nfunction serializeProcessingInstruction(\n  node,\n  namespace,\n  prefixMap,\n  requireWellFormed\n) {\n  if (\n    requireWellFormed &&\n    (node.target.includes(\":\") || asciiCaseInsensitiveMatch(node.target, \"xml\"))\n  ) {\n    throw new Error(\"Failed to serialize XML: processing instruction node target is not well-formed.\");\n  }\n  if (\n    requireWellFormed &&\n    (!XML_CHAR.test(node.data) || node.data.includes(\"?>\"))\n  ) {\n    throw new Error(\"Failed to serialize XML: processing instruction node data is not well-formed.\");\n  }\n  return `<?${node.target} ${node.data}?>`;\n}\n\nfunction serializeDocument(\n  node,\n  namespace,\n  prefixMap,\n  requireWellFormed,\n  refs\n) {\n  if (requireWellFormed && node.documentElement === null) {\n    throw new Error(\"Failed to serialize XML: document does not have a document element.\");\n  }\n  let serializedDocument = \"\";\n  for (const child of node.childNodes) {\n    serializedDocument += xmlSerialization(\n      child,\n      namespace,\n      prefixMap,\n      requireWellFormed,\n      refs\n    );\n  }\n  return serializedDocument;\n}\n\nfunction serializeDocumentFragment(\n  node,\n  namespace,\n  prefixMap,\n  requireWellFormed,\n  refs\n) {\n  let markup = \"\";\n  for (const child of node.childNodes) {\n    markup += xmlSerialization(\n      child,\n      namespace,\n      prefixMap,\n      requireWellFormed,\n      refs\n    );\n  }\n  return markup;\n}\n\nfunction serializeText(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: text node data is not well-formed.\");\n  }\n\n  return node.data\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n}\n\nfunction serializeComment(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: comment node data is not well-formed.\");\n  }\n\n  if (\n    requireWellFormed &&\n    (node.data.includes(\"--\") || node.data.endsWith(\"-\"))\n  ) {\n    throw new Error(\"Failed to serialize XML: found hyphens in illegal places in comment node data.\");\n  }\n  return `<!--${node.data}-->`;\n}\n\nfunction serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (\n    requireWellFormed &&\n    (node.localName.includes(\":\") || !xnv.name(node.localName))\n  ) {\n    throw new Error(\"Failed to serialize XML: element node localName is not a valid XML name.\");\n  }\n  let markup = \"<\";\n  let qualifiedName = \"\";\n  let skipEndTag = false;\n  let ignoreNamespaceDefinitionAttr = false;\n  const map = Object.assign({}, prefixMap);\n  const localPrefixesMap = Object.create(null);\n  const localDefaultNamespace = recordNamespaceInformation(\n    node,\n    map,\n    localPrefixesMap\n  );\n  let inheritedNs = namespace;\n  const ns = node.namespaceURI;\n  if (inheritedNs === ns) {\n    if (localDefaultNamespace !== null) {\n      ignoreNamespaceDefinitionAttr = true;\n    }\n    if (ns === NAMESPACES.XML) {\n      qualifiedName = \"xml:\" + node.localName;\n    } else {\n      qualifiedName = node.localName;\n    }\n    markup += qualifiedName;\n  } else {\n    let { prefix } = node;\n    let candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);\n    if (prefix === \"xmlns\") {\n      if (requireWellFormed) {\n        throw new Error(\"Failed to serialize XML: element nodes can't have a prefix of \\\"xmlns\\\".\");\n      }\n      candidatePrefix = \"xmlns\";\n    }\n    if (candidatePrefix !== null) {\n      qualifiedName = candidatePrefix + \":\" + node.localName;\n      if (\n        localDefaultNamespace !== null &&\n        localDefaultNamespace !== NAMESPACES.XML\n      ) {\n        inheritedNs =\n          localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n      markup += qualifiedName;\n    } else if (prefix !== null) {\n      if (prefix in localPrefixesMap) {\n        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);\n      }\n      if (map[ns]) {\n        map[ns].push(prefix);\n      } else {\n        map[ns] = [prefix];\n      }\n      qualifiedName = prefix + \":\" + node.localName;\n      markup += `${qualifiedName} xmlns:${prefix}=\"${attributeUtils.serializeAttributeValue(\n        ns,\n        requireWellFormed\n      )}\"`;\n      if (localDefaultNamespace !== null) {\n        inheritedNs =\n          localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {\n      ignoreNamespaceDefinitionAttr = true;\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += `${qualifiedName} xmlns=\"${attributeUtils.serializeAttributeValue(\n        ns,\n        requireWellFormed\n      )}\"`;\n    } else {\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += qualifiedName;\n    }\n  }\n\n  markup += attributeUtils.serializeAttributes(\n    node,\n    map,\n    localPrefixesMap,\n    ignoreNamespaceDefinitionAttr,\n    requireWellFormed,\n    refs\n  );\n\n  if (\n    ns === NAMESPACES.HTML &&\n    node.childNodes.length === 0 &&\n    VOID_ELEMENTS.has(node.localName)\n  ) {\n    markup += \" /\";\n    skipEndTag = true;\n  } else if (ns !== NAMESPACES.HTML && node.childNodes.length === 0) {\n    markup += \"/\";\n    skipEndTag = true;\n  }\n  markup += \">\";\n  if (skipEndTag) {\n    return markup;\n  }\n\n  if (ns === NAMESPACES.HTML && node.localName === \"template\") {\n    markup += xmlSerialization(\n      node.content,\n      inheritedNs,\n      map,\n      requireWellFormed,\n      refs\n    );\n  } else {\n    for (const child of node.childNodes) {\n      markup += xmlSerialization(\n        child,\n        inheritedNs,\n        map,\n        requireWellFormed,\n        refs\n      );\n    }\n  }\n  markup += `</${qualifiedName}>`;\n  return markup;\n}\n\nfunction serializeCDATASection(node) {\n  return \"<![CDATA[\" + node.data + \"]]>\";\n}\n\n/**\n * @param {{prefixIndex: number}} refs\n */\nfunction xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {\n  switch (node.nodeType) {\n    case NODE_TYPES.ELEMENT_NODE:\n      return serializeElement(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed,\n        refs\n      );\n    case NODE_TYPES.DOCUMENT_NODE:\n      return serializeDocument(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed,\n        refs\n      );\n    case NODE_TYPES.COMMENT_NODE:\n      return serializeComment(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.TEXT_NODE:\n      return serializeText(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragment(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed,\n        refs\n      );\n    case NODE_TYPES.DOCUMENT_TYPE_NODE:\n      return serializeDocumentType(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed\n      );\n    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:\n      return serializeProcessingInstruction(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed\n      );\n    case NODE_TYPES.ATTRIBUTE_NODE:\n      return \"\";\n    case NODE_TYPES.CDATA_SECTION_NODE:\n      return serializeCDATASection(node);\n    default:\n      throw new TypeError(\"Failed to serialize XML: only Nodes can be serialized.\");\n  }\n}\n\nmodule.exports = (root, { requireWellFormed = false } = {}) => {\n  const namespacePrefixMap = Object.create(null);\n  namespacePrefixMap[\"http://www.w3.org/XML/1998/namespace\"] = [\"xml\"];\n  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {\n    prefixIndex: 1\n  });\n};\n"]},"metadata":{},"sourceType":"script"}