{"ast":null,"code":"\"use strict\";\n\nconst HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\n\nconst {\n  spawnSync\n} = require(\"child_process\");\n\nconst {\n  URL\n} = require(\"whatwg-url\");\n\nconst whatwgEncoding = require(\"whatwg-encoding\");\n\nconst tough = require(\"tough-cookie\");\n\nconst MIMEType = require(\"whatwg-mimetype\");\n\nconst xhrUtils = require(\"./xhr-utils\");\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst {\n  documentBaseURLSerialized\n} = require(\"../helpers/document-base-url\");\n\nconst {\n  asciiCaseInsensitiveMatch\n} = require(\"../helpers/strings\");\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst Document = require(\"../generated/Document\");\n\nconst Blob = require(\"../generated/Blob\");\n\nconst FormData = require(\"../generated/FormData\");\n\nconst XMLHttpRequestEventTargetImpl = require(\"./XMLHttpRequestEventTarget-impl\").implementation;\n\nconst XMLHttpRequestUpload = require(\"../generated/XMLHttpRequestUpload\");\n\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\n\nconst {\n  isArrayBuffer\n} = require(\"../generated/utils\");\n\nconst {\n  parseIntoDocument\n} = require(\"../../browser/parser\");\n\nconst {\n  fragmentSerialization\n} = require(\"../domparsing/serialization\");\n\nconst {\n  setupForSimpleEventAccessors\n} = require(\"../helpers/create-event-accessor\");\n\nconst {\n  parseJSONFromBytes\n} = require(\"../helpers/json\");\n\nconst {\n  fireAnEvent\n} = require(\"../helpers/events\");\n\nconst {\n  copyToArrayBufferInNewRealm\n} = require(\"../helpers/binary-data\");\n\nconst {\n  READY_STATES\n} = xhrUtils;\nconst syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\nconst forbiddenRequestHeaders = new Set([\"accept-charset\", \"accept-encoding\", \"access-control-request-headers\", \"access-control-request-method\", \"connection\", \"content-length\", \"cookie\", \"cookie2\", \"date\", \"dnt\", \"expect\", \"host\", \"keep-alive\", \"origin\", \"referer\", \"te\", \"trailer\", \"transfer-encoding\", \"upgrade\", \"via\"]);\nconst forbiddenResponseHeaders = new Set([\"set-cookie\", \"set-cookie2\"]);\nconst uniqueResponseHeaders = new Set([\"content-type\", \"content-length\", \"user-agent\", \"referer\", \"host\", \"authorization\", \"proxy-authorization\", \"if-modified-since\", \"if-unmodified-since\", \"from\", \"location\", \"max-forwards\"]);\nconst corsSafeResponseHeaders = new Set([\"cache-control\", \"content-language\", \"content-type\", \"expires\", \"last-modified\", \"pragma\"]);\nconst allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nconst forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\n\nclass XMLHttpRequestImpl extends XMLHttpRequestEventTargetImpl {\n  constructor(window) {\n    super(window); // Avoid running `_ownerDocument` getter multiple times in the constructor:\n\n    const {\n      _ownerDocument\n    } = this;\n    this.upload = XMLHttpRequestUpload.createImpl(window);\n    this.readyState = READY_STATES.UNSENT;\n    this.responseURL = \"\";\n    this.status = 0;\n    this.statusText = \"\";\n    this.flag = {\n      synchronous: false,\n      withCredentials: false,\n      mimeType: null,\n      auth: null,\n      method: undefined,\n      responseType: \"\",\n      requestHeaders: {},\n      referrer: _ownerDocument.URL,\n      uri: \"\",\n      timeout: 0,\n      body: undefined,\n      formData: false,\n      preflight: false,\n      requestManager: _ownerDocument._requestManager,\n      strictSSL: window._resourceLoader._strictSSL,\n      proxy: window._resourceLoader._proxy,\n      cookieJar: _ownerDocument._cookieJar,\n      encoding: _ownerDocument._encoding,\n      origin: window._origin,\n      userAgent: window.navigator.userAgent\n    };\n    this.properties = {\n      beforeSend: false,\n      send: false,\n      client: null,\n      timeoutStart: 0,\n      timeoutId: 0,\n      timeoutFn: null,\n      responseBuffer: null,\n      responseCache: null,\n      responseTextCache: null,\n      responseXMLCache: null,\n      responseHeaders: {},\n      filteredResponseHeaders: [],\n      error: \"\",\n      uploadComplete: false,\n      uploadListener: false,\n      // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.\n      // In that case the termination reason is \"fatal\", not \"end-user abort\".\n      abortError: false,\n      cookieJar: _ownerDocument._cookieJar,\n      bufferStepSize: 1 * 1024 * 1024,\n      // pre-allocate buffer increase step size. init value is 1MB\n      totalReceivedChunkSize: 0\n    };\n  }\n\n  get responseType() {\n    return this.flag.responseType;\n  }\n\n  set responseType(responseType) {\n    const {\n      flag\n    } = this;\n\n    if (this.readyState === READY_STATES.LOADING || this.readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (this.readyState === READY_STATES.OPENED && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n    }\n\n    flag.responseType = responseType;\n  }\n\n  get response() {\n    const {\n      properties\n    } = this;\n\n    if (properties.responseCache) {\n      // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n      return idlUtils.tryWrapperForImpl(properties.responseCache);\n    }\n\n    let res;\n    const responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n    switch (this.responseType) {\n      case \"\":\n      case \"text\":\n        {\n          res = this.responseText;\n          break;\n        }\n\n      case \"arraybuffer\":\n        {\n          if (!responseBuffer) {\n            return null;\n          }\n\n          res = copyToArrayBufferInNewRealm(responseBuffer, this._globalObject);\n          break;\n        }\n\n      case \"blob\":\n        {\n          if (!responseBuffer) {\n            return null;\n          }\n\n          const contentType = finalMIMEType(this);\n          res = Blob.createImpl(this._globalObject, [[new Uint8Array(responseBuffer)], {\n            type: contentType || \"\"\n          }]);\n          break;\n        }\n\n      case \"document\":\n        {\n          res = this.responseXML;\n          break;\n        }\n\n      case \"json\":\n        {\n          if (this.readyState !== READY_STATES.DONE || !responseBuffer) {\n            res = null;\n          }\n\n          try {\n            res = parseJSONFromBytes(responseBuffer);\n          } catch (e) {\n            res = null;\n          }\n\n          break;\n        }\n    }\n\n    properties.responseCache = res; // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n\n    return idlUtils.tryWrapperForImpl(res);\n  }\n\n  get responseText() {\n    const {\n      properties\n    } = this;\n\n    if (this.responseType !== \"\" && this.responseType !== \"text\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (this.readyState !== READY_STATES.LOADING && this.readyState !== READY_STATES.DONE) {\n      return \"\";\n    }\n\n    if (properties.responseTextCache) {\n      return properties.responseTextCache;\n    }\n\n    const responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n    if (!responseBuffer) {\n      return \"\";\n    }\n\n    const fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n    properties.responseTextCache = res;\n    return res;\n  }\n\n  get responseXML() {\n    const {\n      flag,\n      properties\n    } = this;\n\n    if (this.responseType !== \"\" && this.responseType !== \"document\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (this.readyState !== READY_STATES.DONE) {\n      return null;\n    }\n\n    if (properties.responseXMLCache) {\n      return properties.responseXMLCache;\n    }\n\n    const responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n    if (!responseBuffer) {\n      return null;\n    }\n\n    const contentType = finalMIMEType(this);\n    let isHTML = false;\n    let isXML = false;\n    const parsed = MIMEType.parse(contentType);\n\n    if (parsed) {\n      isHTML = parsed.isHTML();\n      isXML = parsed.isXML();\n\n      if (!isXML && !isHTML) {\n        return null;\n      }\n    }\n\n    if (this.responseType === \"\" && isHTML) {\n      return null;\n    }\n\n    const encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n    if (!resText) {\n      return null;\n    }\n\n    const res = Document.createImpl(this._globalObject, [], {\n      options: {\n        url: flag.uri,\n        lastModified: new Date(getResponseHeader(this, \"last-modified\")),\n        parsingMode: isHTML ? \"html\" : \"xml\",\n        cookieJar: {\n          setCookieSync: () => undefined,\n          getCookieStringSync: () => \"\"\n        },\n        encoding,\n        parseOptions: this._ownerDocument._parseOptions\n      }\n    });\n\n    try {\n      parseIntoDocument(resText, res);\n    } catch (e) {\n      properties.responseXMLCache = null;\n      return null;\n    }\n\n    res.close();\n    properties.responseXMLCache = res;\n    return res;\n  }\n\n  get timeout() {\n    return this.flag.timeout;\n  }\n\n  set timeout(val) {\n    const {\n      flag,\n      properties\n    } = this;\n\n    if (flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n    }\n\n    flag.timeout = val;\n    clearTimeout(properties.timeoutId);\n\n    if (val > 0 && properties.timeoutFn) {\n      properties.timeoutId = setTimeout(properties.timeoutFn, Math.max(0, val - (new Date().getTime() - properties.timeoutStart)));\n    } else {\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n    }\n  }\n\n  get withCredentials() {\n    return this.flag.withCredentials;\n  }\n\n  set withCredentials(val) {\n    const {\n      flag,\n      properties\n    } = this;\n\n    if (!(this.readyState === READY_STATES.UNSENT || this.readyState === READY_STATES.OPENED)) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    flag.withCredentials = val;\n  }\n\n  abort() {\n    const {\n      properties\n    } = this; // Terminate the request\n\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n    const {\n      client\n    } = properties;\n\n    if (client) {\n      client.abort();\n      properties.client = null;\n    }\n\n    if (properties.abortError) {\n      // Special case that ideally shouldn't be going through the public API at all.\n      // Run the https://xhr.spec.whatwg.org/#handle-errors \"fatal\" steps.\n      this.readyState = READY_STATES.DONE;\n      properties.send = false;\n      xhrUtils.setResponseToNetworkError(this);\n      return;\n    }\n\n    if (this.readyState === READY_STATES.OPENED && properties.send || this.readyState === READY_STATES.HEADERS_RECEIVED || this.readyState === READY_STATES.LOADING) {\n      xhrUtils.requestErrorSteps(this, \"abort\");\n    }\n\n    if (this.readyState === READY_STATES.DONE) {\n      this.readyState = READY_STATES.UNSENT;\n      xhrUtils.setResponseToNetworkError(this);\n    }\n  }\n\n  getAllResponseHeaders() {\n    const {\n      properties,\n      readyState\n    } = this;\n\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return \"\";\n    }\n\n    return Object.keys(properties.responseHeaders).filter(key => properties.filteredResponseHeaders.indexOf(key) === -1).map(key => [key.toLowerCase(), properties.responseHeaders[key]].join(\": \")).join(\"\\r\\n\");\n  }\n\n  getResponseHeader(header) {\n    const {\n      properties,\n      readyState\n    } = this;\n\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return null;\n    }\n\n    const lcHeader = header.toLowerCase();\n\n    if (properties.filteredResponseHeaders.find(filtered => lcHeader === filtered.toLowerCase())) {\n      return null;\n    }\n\n    return getResponseHeader(this, lcHeader);\n  }\n\n  open(method, uri, asynchronous, user, password) {\n    const {\n      flag,\n      properties,\n      _ownerDocument\n    } = this;\n\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (!tokenRegexp.test(method)) {\n      throw DOMException.create(this._globalObject, [\"The string did not match the expected pattern.\", \"SyntaxError\"]);\n    }\n\n    const upperCaseMethod = method.toUpperCase();\n\n    if (forbiddenRequestMethods.has(upperCaseMethod)) {\n      throw DOMException.create(this._globalObject, [\"The operation is insecure.\", \"SecurityError\"]);\n    }\n\n    const {\n      client\n    } = properties;\n\n    if (client && typeof client.abort === \"function\") {\n      client.abort();\n    }\n\n    if (allowedRequestMethods.has(upperCaseMethod)) {\n      method = upperCaseMethod;\n    }\n\n    if (typeof asynchronous !== \"undefined\") {\n      flag.synchronous = !asynchronous;\n    } else {\n      flag.synchronous = false;\n    }\n\n    if (flag.responseType && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n    }\n\n    if (flag.synchronous && flag.timeout) {\n      throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n    }\n\n    flag.method = method;\n    let urlObj;\n\n    try {\n      urlObj = new URL(uri, documentBaseURLSerialized(_ownerDocument));\n    } catch (e) {\n      throw DOMException.create(this._globalObject, [\"The string did not match the expected pattern.\", \"SyntaxError\"]);\n    }\n\n    if (user || password && !urlObj.username) {\n      flag.auth = {\n        user,\n        pass: password\n      };\n      urlObj.username = \"\";\n      urlObj.password = \"\";\n    }\n\n    flag.uri = urlObj.href;\n    flag.requestHeaders = {};\n    flag.preflight = false;\n    properties.send = false;\n    properties.uploadListener = false;\n    properties.abortError = false;\n    this.responseURL = \"\";\n    readyStateChange(this, READY_STATES.OPENED);\n  }\n\n  overrideMimeType(mime) {\n    const {\n      readyState\n    } = this;\n\n    if (readyState === READY_STATES.LOADING || readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    this.flag.overrideMIMEType = \"application/octet-stream\"; // Waiting for better spec: https://github.com/whatwg/xhr/issues/157\n\n    const parsed = MIMEType.parse(mime);\n\n    if (parsed) {\n      this.flag.overrideMIMEType = parsed.essence;\n      const charset = parsed.parameters.get(\"charset\");\n\n      if (charset) {\n        this.flag.overrideCharset = whatwgEncoding.labelToName(charset);\n      }\n    }\n  } // TODO: Add support for URLSearchParams and ReadableStream\n\n\n  send(body) {\n    const {\n      flag,\n      properties,\n      upload,\n      _ownerDocument\n    } = this; // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65\n\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    properties.beforeSend = true;\n\n    try {\n      if (flag.method === \"GET\" || flag.method === \"HEAD\") {\n        body = null;\n      }\n\n      if (body !== null) {\n        let encoding = null;\n        let mimeType = null;\n\n        if (Document.isImpl(body)) {\n          encoding = \"UTF-8\";\n          mimeType = (body._parsingMode === \"html\" ? \"text/html\" : \"application/xml\") + \";charset=UTF-8\";\n          flag.body = fragmentSerialization(body, {\n            requireWellFormed: false\n          });\n        } else {\n          if (typeof body === \"string\") {\n            encoding = \"UTF-8\";\n          }\n\n          const {\n            buffer,\n            formData,\n            contentType\n          } = extractBody(body);\n          mimeType = contentType;\n          flag.body = buffer || formData;\n          flag.formData = Boolean(formData);\n        }\n\n        const existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n\n        if (mimeType !== null && existingContentType === null) {\n          flag.requestHeaders[\"Content-Type\"] = mimeType;\n        } else if (existingContentType !== null && encoding !== null) {\n          // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what\n          // the spec will be, in the meantime.\n          const parsed = MIMEType.parse(existingContentType);\n\n          if (parsed) {\n            const charset = parsed.parameters.get(\"charset\");\n\n            if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {\n              parsed.parameters.set(\"charset\", encoding);\n              xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n            }\n          }\n        }\n      }\n    } finally {\n      if (properties.beforeSend) {\n        properties.beforeSend = false;\n      } else {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n    }\n\n    if (Object.keys(upload._eventListeners).length > 0) {\n      properties.uploadListener = true;\n    } // request doesn't like zero-length bodies\n\n\n    if (flag.body && flag.body.byteLength === 0) {\n      flag.body = null;\n    }\n\n    if (flag.synchronous) {\n      const flagStr = JSON.stringify(flag, function (k, v) {\n        if (this === flag && k === \"requestManager\") {\n          return null;\n        }\n\n        if (this === flag && k === \"pool\" && v) {\n          return {\n            maxSockets: v.maxSockets\n          };\n        }\n\n        return v;\n      });\n      const res = spawnSync(process.execPath, [syncWorkerFile], {\n        input: flagStr,\n        maxBuffer: Infinity\n      });\n\n      if (res.status !== 0) {\n        throw new Error(res.stderr.toString());\n      }\n\n      if (res.error) {\n        if (typeof res.error === \"string\") {\n          res.error = new Error(res.error);\n        }\n\n        throw res.error;\n      }\n\n      const response = JSON.parse(res.stdout.toString());\n      const resProp = response.properties;\n\n      if (resProp.responseBuffer && resProp.responseBuffer.data) {\n        resProp.responseBuffer = Buffer.from(resProp.responseBuffer.data);\n      }\n\n      if (resProp.cookieJar) {\n        resProp.cookieJar = tough.CookieJar.deserializeSync(resProp.cookieJar, _ownerDocument._cookieJar.store);\n      }\n\n      this.readyState = READY_STATES.LOADING;\n      this.status = response.status;\n      this.statusText = response.statusText;\n      this.responseURL = response.responseURL;\n      Object.assign(this.properties, response.properties);\n\n      if (resProp.error) {\n        xhrUtils.dispatchError(this);\n        throw DOMException.create(this._globalObject, [resProp.error, \"NetworkError\"]);\n      } else {\n        const {\n          responseBuffer\n        } = properties;\n        const contentLength = getResponseHeader(this, \"content-length\") || \"0\";\n        const bufferLength = parseInt(contentLength) || responseBuffer.length;\n        const progressObj = {\n          lengthComputable: false\n        };\n\n        if (bufferLength !== 0) {\n          progressObj.total = bufferLength;\n          progressObj.loaded = bufferLength;\n          progressObj.lengthComputable = true;\n        }\n\n        fireAnEvent(\"progress\", this, ProgressEvent, progressObj);\n        readyStateChange(this, READY_STATES.DONE);\n        fireAnEvent(\"load\", this, ProgressEvent, progressObj);\n        fireAnEvent(\"loadend\", this, ProgressEvent, progressObj);\n      }\n    } else {\n      properties.send = true;\n      fireAnEvent(\"loadstart\", this, ProgressEvent);\n      const client = xhrUtils.createClient(this);\n      properties.client = client; // For new client, reset totalReceivedChunkSize and bufferStepSize\n\n      properties.totalReceivedChunkSize = 0;\n      properties.bufferStepSize = 1 * 1024 * 1024;\n      properties.origin = flag.origin;\n      client.on(\"error\", err => {\n        client.removeAllListeners();\n        properties.error = err;\n        xhrUtils.dispatchError(this);\n      });\n      client.on(\"response\", res => receiveResponse(this, res));\n      client.on(\"redirect\", () => {\n        const {\n          response\n        } = client;\n        const destUrlObj = new URL(response.request.headers.Referer);\n        const urlObj = new URL(response.request.uri.href);\n\n        if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n          properties.origin = \"null\";\n        }\n\n        response.request.headers.Origin = properties.origin;\n\n        if (flag.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n          if (!xhrUtils.validCORSHeaders(this, response, flag, properties, flag.origin)) {\n            return;\n          }\n\n          if (urlObj.username || urlObj.password) {\n            properties.error = \"Userinfo forbidden in cors redirect\";\n            xhrUtils.dispatchError(this);\n          }\n        }\n      });\n\n      if (body !== null && body !== \"\") {\n        properties.uploadComplete = false;\n        setDispatchProgressEvents(this);\n      } else {\n        properties.uploadComplete = true;\n      }\n\n      if (this.timeout > 0) {\n        properties.timeoutStart = new Date().getTime();\n\n        properties.timeoutFn = () => {\n          client.abort();\n\n          if (!(this.readyState === READY_STATES.UNSENT || this.readyState === READY_STATES.OPENED && !properties.send || this.readyState === READY_STATES.DONE)) {\n            properties.send = false;\n            let stateChanged = false;\n\n            if (!properties.uploadComplete) {\n              fireAnEvent(\"progress\", upload, ProgressEvent);\n              readyStateChange(this, READY_STATES.DONE);\n              fireAnEvent(\"timeout\", upload, ProgressEvent);\n              fireAnEvent(\"loadend\", upload, ProgressEvent);\n              stateChanged = true;\n            }\n\n            fireAnEvent(\"progress\", this, ProgressEvent);\n\n            if (!stateChanged) {\n              readyStateChange(this, READY_STATES.DONE);\n            }\n\n            fireAnEvent(\"timeout\", this, ProgressEvent);\n            fireAnEvent(\"loadend\", this, ProgressEvent);\n          }\n\n          this.readyState = READY_STATES.UNSENT;\n        };\n\n        properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n      }\n    }\n  }\n\n  setRequestHeader(header, value) {\n    const {\n      flag,\n      properties\n    } = this;\n\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    value = normalizeHeaderValue(value);\n\n    if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n      throw DOMException.create(this._globalObject, [\"The string did not match the expected pattern.\", \"SyntaxError\"]);\n    }\n\n    const lcHeader = header.toLowerCase();\n\n    if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n      return;\n    }\n\n    const keys = Object.keys(flag.requestHeaders);\n    let n = keys.length;\n\n    while (n--) {\n      const key = keys[n];\n\n      if (key.toLowerCase() === lcHeader) {\n        flag.requestHeaders[key] += \", \" + value;\n        return;\n      }\n    }\n\n    flag.requestHeaders[header] = value;\n  }\n\n}\n\nsetupForSimpleEventAccessors(XMLHttpRequestImpl.prototype, [\"readystatechange\"]);\n\nfunction readyStateChange(xhr, readyState) {\n  if (xhr.readyState === readyState) {\n    return;\n  }\n\n  xhr.readyState = readyState;\n  fireAnEvent(\"readystatechange\", xhr);\n}\n\nfunction receiveResponse(xhr, response) {\n  const {\n    flag,\n    properties\n  } = xhr;\n  const {\n    statusCode\n  } = response;\n  let byteOffset = 0;\n  const headers = {};\n  const filteredResponseHeaders = [];\n  const headerMap = {};\n  const {\n    rawHeaders\n  } = response;\n  const n = Number(rawHeaders.length);\n\n  for (let i = 0; i < n; i += 2) {\n    const k = rawHeaders[i];\n    const kl = k.toLowerCase();\n    const v = rawHeaders[i + 1];\n\n    if (uniqueResponseHeaders.has(kl)) {\n      if (headerMap[kl] !== undefined) {\n        delete headers[headerMap[kl]];\n      }\n\n      headers[k] = v;\n    } else if (headerMap[kl] !== undefined) {\n      headers[headerMap[kl]] += \", \" + v;\n    } else {\n      headers[k] = v;\n    }\n\n    headerMap[kl] = k;\n  }\n\n  const destUrlObj = new URL(response.request.uri.href);\n\n  if (properties.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n    if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n      return;\n    }\n\n    const acehStr = response.headers[\"access-control-expose-headers\"];\n    const aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);\n\n    for (const header in headers) {\n      const lcHeader = header.toLowerCase();\n\n      if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n        filteredResponseHeaders.push(header);\n      }\n    }\n  }\n\n  for (const header in headers) {\n    const lcHeader = header.toLowerCase();\n\n    if (forbiddenResponseHeaders.has(lcHeader)) {\n      filteredResponseHeaders.push(header);\n    }\n  }\n\n  xhr.responseURL = destUrlObj.href;\n  xhr.status = statusCode;\n  xhr.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n  properties.responseHeaders = headers;\n  properties.filteredResponseHeaders = filteredResponseHeaders;\n  const contentLength = getResponseHeader(xhr, \"content-length\") || \"0\";\n  const bufferLength = parseInt(contentLength) || 0;\n  const progressObj = {\n    lengthComputable: false\n  };\n  let lastProgressReported;\n\n  if (bufferLength !== 0) {\n    progressObj.total = bufferLength;\n    progressObj.loaded = 0;\n    progressObj.lengthComputable = true;\n  } // pre-allocate buffer.\n\n\n  properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);\n  properties.responseCache = null;\n  properties.responseTextCache = null;\n  properties.responseXMLCache = null;\n  readyStateChange(xhr, READY_STATES.HEADERS_RECEIVED);\n\n  if (!properties.client) {\n    // The request was aborted in reaction to the readystatechange event.\n    return;\n  } // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n  // Content-Length).\n\n\n  response.on(\"data\", chunk => {\n    byteOffset += chunk.length;\n    progressObj.loaded = byteOffset;\n  });\n  properties.client.on(\"data\", chunk => {\n    properties.totalReceivedChunkSize += chunk.length;\n\n    if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n      properties.bufferStepSize *= 2;\n\n      while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n        properties.bufferStepSize *= 2;\n      }\n\n      const tmpBuf = Buffer.alloc(properties.bufferStepSize);\n      properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);\n      properties.responseBuffer = tmpBuf;\n    }\n\n    chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n\n    if (xhr.readyState === READY_STATES.HEADERS_RECEIVED) {\n      xhr.readyState = READY_STATES.LOADING;\n    }\n\n    fireAnEvent(\"readystatechange\", xhr);\n\n    if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {\n      if (lastProgressReported !== progressObj.loaded) {\n        // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n        // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n        lastProgressReported = progressObj.loaded;\n        fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n      }\n    }\n  });\n  properties.client.on(\"end\", () => {\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n    properties.client = null;\n    fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n    readyStateChange(xhr, READY_STATES.DONE);\n    fireAnEvent(\"load\", xhr, ProgressEvent, progressObj);\n    fireAnEvent(\"loadend\", xhr, ProgressEvent, progressObj);\n  });\n}\n\nfunction setDispatchProgressEvents(xhr) {\n  const {\n    properties,\n    upload\n  } = xhr;\n  const {\n    client\n  } = properties;\n  let total = 0;\n  let lengthComputable = false;\n  const length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n\n  if (length) {\n    total = length;\n    lengthComputable = true;\n  }\n\n  const initProgress = {\n    lengthComputable,\n    total,\n    loaded: 0\n  };\n\n  if (properties.uploadListener) {\n    fireAnEvent(\"loadstart\", upload, ProgressEvent, initProgress);\n  }\n\n  client.on(\"request\", req => {\n    req.on(\"response\", () => {\n      properties.uploadComplete = true;\n\n      if (!properties.uploadListener) {\n        return;\n      }\n\n      const progress = {\n        lengthComputable,\n        total,\n        loaded: total\n      };\n      fireAnEvent(\"progress\", upload, ProgressEvent, progress);\n      fireAnEvent(\"load\", upload, ProgressEvent, progress);\n      fireAnEvent(\"loadend\", upload, ProgressEvent, progress);\n    });\n  });\n}\n\nfunction finalMIMEType(xhr) {\n  const {\n    flag\n  } = xhr;\n  return flag.overrideMIMEType || getResponseHeader(xhr, \"content-type\");\n}\n\nfunction finalCharset(xhr) {\n  const {\n    flag\n  } = xhr;\n\n  if (flag.overrideCharset) {\n    return flag.overrideCharset;\n  }\n\n  const parsedContentType = MIMEType.parse(getResponseHeader(xhr, \"content-type\"));\n\n  if (parsedContentType) {\n    return whatwgEncoding.labelToName(parsedContentType.parameters.get(\"charset\"));\n  }\n\n  return null;\n}\n\nfunction getResponseHeader(xhr, lcHeader) {\n  const {\n    properties\n  } = xhr;\n  const keys = Object.keys(properties.responseHeaders);\n  let n = keys.length;\n\n  while (n--) {\n    const key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      return properties.responseHeaders[key];\n    }\n  }\n\n  return null;\n}\n\nfunction normalizeHeaderValue(value) {\n  return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n}\n\nfunction extractBody(bodyInit) {\n  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n  // except we represent the body as a Node.js Buffer instead,\n  // or a special case for FormData since we want request to handle that. Probably it would be\n  // cleaner (and allow a future without request) if we did the form encoding ourself.\n  if (Blob.isImpl(bodyInit)) {\n    return {\n      buffer: bodyInit._buffer,\n      contentType: bodyInit.type === \"\" ? null : bodyInit.type\n    };\n  } else if (isArrayBuffer(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit),\n      contentType: null\n    };\n  } else if (ArrayBuffer.isView(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),\n      contentType: null\n    };\n  } else if (FormData.isImpl(bodyInit)) {\n    const formData = [];\n\n    for (const entry of bodyInit._entries) {\n      let val;\n\n      if (Blob.isImpl(entry.value)) {\n        const blob = entry.value;\n        val = {\n          name: entry.name,\n          value: blob._buffer,\n          options: {\n            filename: blob.name,\n            contentType: blob.type,\n            knownLength: blob.size\n          }\n        };\n      } else {\n        val = entry;\n      }\n\n      formData.push(val);\n    }\n\n    return {\n      formData\n    };\n  } // Must be a string\n\n\n  return {\n    buffer: Buffer.from(bodyInit, \"utf-8\"),\n    contentType: \"text/plain;charset=UTF-8\"\n  };\n}\n\nexports.implementation = XMLHttpRequestImpl;","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/jsdom/lib/jsdom/living/xhr/XMLHttpRequest-impl.js"],"names":["HTTP_STATUS_CODES","require","STATUS_CODES","spawnSync","URL","whatwgEncoding","tough","MIMEType","xhrUtils","DOMException","documentBaseURLSerialized","asciiCaseInsensitiveMatch","idlUtils","Document","Blob","FormData","XMLHttpRequestEventTargetImpl","implementation","XMLHttpRequestUpload","ProgressEvent","isArrayBuffer","parseIntoDocument","fragmentSerialization","setupForSimpleEventAccessors","parseJSONFromBytes","fireAnEvent","copyToArrayBufferInNewRealm","READY_STATES","syncWorkerFile","resolve","tokenRegexp","fieldValueRegexp","forbiddenRequestHeaders","Set","forbiddenResponseHeaders","uniqueResponseHeaders","corsSafeResponseHeaders","allowedRequestMethods","forbiddenRequestMethods","XMLHttpRequestImpl","constructor","window","_ownerDocument","upload","createImpl","readyState","UNSENT","responseURL","status","statusText","flag","synchronous","withCredentials","mimeType","auth","method","undefined","responseType","requestHeaders","referrer","uri","timeout","body","formData","preflight","requestManager","_requestManager","strictSSL","_resourceLoader","_strictSSL","proxy","_proxy","cookieJar","_cookieJar","encoding","_encoding","origin","_origin","userAgent","navigator","properties","beforeSend","send","client","timeoutStart","timeoutId","timeoutFn","responseBuffer","responseCache","responseTextCache","responseXMLCache","responseHeaders","filteredResponseHeaders","error","uploadComplete","uploadListener","abortError","bufferStepSize","totalReceivedChunkSize","LOADING","DONE","create","_globalObject","OPENED","response","tryWrapperForImpl","res","slice","responseText","contentType","finalMIMEType","Uint8Array","type","responseXML","e","fallbackEncoding","finalCharset","getBOMEncoding","decode","isHTML","isXML","parsed","parse","resText","options","url","lastModified","Date","getResponseHeader","parsingMode","setCookieSync","getCookieStringSync","parseOptions","_parseOptions","close","val","clearTimeout","setTimeout","Math","max","getTime","abort","setResponseToNetworkError","HEADERS_RECEIVED","requestErrorSteps","getAllResponseHeaders","Object","keys","filter","key","indexOf","map","toLowerCase","join","header","lcHeader","find","filtered","open","asynchronous","user","password","test","upperCaseMethod","toUpperCase","has","urlObj","username","pass","href","readyStateChange","overrideMimeType","mime","overrideMIMEType","essence","charset","parameters","get","overrideCharset","labelToName","isImpl","_parsingMode","requireWellFormed","buffer","extractBody","Boolean","existingContentType","getRequestHeader","set","updateRequestHeader","toString","_eventListeners","length","byteLength","flagStr","JSON","stringify","k","v","maxSockets","process","execPath","input","maxBuffer","Infinity","Error","stderr","stdout","resProp","data","Buffer","from","CookieJar","deserializeSync","store","assign","dispatchError","contentLength","bufferLength","parseInt","progressObj","lengthComputable","total","loaded","createClient","on","err","removeAllListeners","receiveResponse","destUrlObj","request","headers","Referer","Origin","protocol","validCORSHeaders","setDispatchProgressEvents","stateChanged","setRequestHeader","value","normalizeHeaderValue","startsWith","n","prototype","xhr","statusCode","byteOffset","headerMap","rawHeaders","Number","i","kl","acehStr","aceh","trim","split","headerListSeparatorRegexp","push","statusMessage","lastProgressReported","alloc","chunk","tmpBuf","copy","initProgress","req","progress","parsedContentType","replace","bodyInit","_buffer","ArrayBuffer","isView","entry","_entries","blob","name","filename","knownLength","size","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\nconst { spawnSync } = require(\"child_process\");\nconst { URL } = require(\"whatwg-url\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst tough = require(\"tough-cookie\");\nconst MIMEType = require(\"whatwg-mimetype\");\n\nconst xhrUtils = require(\"./xhr-utils\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst { documentBaseURLSerialized } = require(\"../helpers/document-base-url\");\nconst { asciiCaseInsensitiveMatch } = require(\"../helpers/strings\");\nconst idlUtils = require(\"../generated/utils\");\nconst Document = require(\"../generated/Document\");\nconst Blob = require(\"../generated/Blob\");\nconst FormData = require(\"../generated/FormData\");\nconst XMLHttpRequestEventTargetImpl = require(\"./XMLHttpRequestEventTarget-impl\").implementation;\nconst XMLHttpRequestUpload = require(\"../generated/XMLHttpRequestUpload\");\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\nconst { isArrayBuffer } = require(\"../generated/utils\");\nconst { parseIntoDocument } = require(\"../../browser/parser\");\nconst { fragmentSerialization } = require(\"../domparsing/serialization\");\nconst { setupForSimpleEventAccessors } = require(\"../helpers/create-event-accessor\");\nconst { parseJSONFromBytes } = require(\"../helpers/json\");\nconst { fireAnEvent } = require(\"../helpers/events\");\nconst { copyToArrayBufferInNewRealm } = require(\"../helpers/binary-data\");\n\nconst { READY_STATES } = xhrUtils;\n\nconst syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\n\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\n\nconst forbiddenRequestHeaders = new Set([\n  \"accept-charset\",\n  \"accept-encoding\",\n  \"access-control-request-headers\",\n  \"access-control-request-method\",\n  \"connection\",\n  \"content-length\",\n  \"cookie\",\n  \"cookie2\",\n  \"date\",\n  \"dnt\",\n  \"expect\",\n  \"host\",\n  \"keep-alive\",\n  \"origin\",\n  \"referer\",\n  \"te\",\n  \"trailer\",\n  \"transfer-encoding\",\n  \"upgrade\",\n  \"via\"\n]);\nconst forbiddenResponseHeaders = new Set([\n  \"set-cookie\",\n  \"set-cookie2\"\n]);\nconst uniqueResponseHeaders = new Set([\n  \"content-type\",\n  \"content-length\",\n  \"user-agent\",\n  \"referer\",\n  \"host\",\n  \"authorization\",\n  \"proxy-authorization\",\n  \"if-modified-since\",\n  \"if-unmodified-since\",\n  \"from\",\n  \"location\",\n  \"max-forwards\"\n]);\nconst corsSafeResponseHeaders = new Set([\n  \"cache-control\",\n  \"content-language\",\n  \"content-type\",\n  \"expires\",\n  \"last-modified\",\n  \"pragma\"\n]);\n\nconst allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nconst forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\n\nclass XMLHttpRequestImpl extends XMLHttpRequestEventTargetImpl {\n  constructor(window) {\n    super(window);\n\n    // Avoid running `_ownerDocument` getter multiple times in the constructor:\n    const { _ownerDocument } = this;\n\n    this.upload = XMLHttpRequestUpload.createImpl(window);\n\n    this.readyState = READY_STATES.UNSENT;\n    this.responseURL = \"\";\n    this.status = 0;\n    this.statusText = \"\";\n\n    this.flag = {\n      synchronous: false,\n      withCredentials: false,\n      mimeType: null,\n      auth: null,\n      method: undefined,\n      responseType: \"\",\n      requestHeaders: {},\n      referrer: _ownerDocument.URL,\n      uri: \"\",\n      timeout: 0,\n      body: undefined,\n      formData: false,\n      preflight: false,\n      requestManager: _ownerDocument._requestManager,\n      strictSSL: window._resourceLoader._strictSSL,\n      proxy: window._resourceLoader._proxy,\n      cookieJar: _ownerDocument._cookieJar,\n      encoding: _ownerDocument._encoding,\n      origin: window._origin,\n      userAgent: window.navigator.userAgent\n    };\n\n    this.properties = {\n      beforeSend: false,\n      send: false,\n      client: null,\n\n      timeoutStart: 0,\n      timeoutId: 0,\n      timeoutFn: null,\n\n      responseBuffer: null,\n      responseCache: null,\n      responseTextCache: null,\n      responseXMLCache: null,\n\n      responseHeaders: {},\n      filteredResponseHeaders: [],\n\n      error: \"\",\n      uploadComplete: false,\n      uploadListener: false,\n\n      // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.\n      // In that case the termination reason is \"fatal\", not \"end-user abort\".\n      abortError: false,\n\n      cookieJar: _ownerDocument._cookieJar,\n      bufferStepSize: 1 * 1024 * 1024, // pre-allocate buffer increase step size. init value is 1MB\n      totalReceivedChunkSize: 0\n    };\n  }\n\n  get responseType() {\n    return this.flag.responseType;\n  }\n  set responseType(responseType) {\n    const { flag } = this;\n    if (this.readyState === READY_STATES.LOADING || this.readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState === READY_STATES.OPENED && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    flag.responseType = responseType;\n  }\n\n  get response() {\n    const { properties } = this;\n    if (properties.responseCache) {\n      // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n      return idlUtils.tryWrapperForImpl(properties.responseCache);\n    }\n    let res;\n\n    const responseBuffer = properties.responseBuffer ?\n      properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n      null;\n\n    switch (this.responseType) {\n      case \"\":\n      case \"text\": {\n        res = this.responseText;\n        break;\n      }\n      case \"arraybuffer\": {\n        if (!responseBuffer) {\n          return null;\n        }\n        res = copyToArrayBufferInNewRealm(responseBuffer, this._globalObject);\n        break;\n      }\n      case \"blob\": {\n        if (!responseBuffer) {\n          return null;\n        }\n        const contentType = finalMIMEType(this);\n        res = Blob.createImpl(this._globalObject, [\n          [new Uint8Array(responseBuffer)],\n          { type: contentType || \"\" }\n        ]);\n        break;\n      }\n      case \"document\": {\n        res = this.responseXML;\n        break;\n      }\n      case \"json\": {\n        if (this.readyState !== READY_STATES.DONE || !responseBuffer) {\n          res = null;\n        }\n\n        try {\n          res = parseJSONFromBytes(responseBuffer);\n        } catch (e) {\n          res = null;\n        }\n        break;\n      }\n    }\n    properties.responseCache = res;\n    // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n    return idlUtils.tryWrapperForImpl(res);\n  }\n  get responseText() {\n    const { properties } = this;\n    if (this.responseType !== \"\" && this.responseType !== \"text\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== READY_STATES.LOADING && this.readyState !== READY_STATES.DONE) {\n      return \"\";\n    }\n    if (properties.responseTextCache) {\n      return properties.responseTextCache;\n    }\n    const responseBuffer = properties.responseBuffer ?\n      properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n      null;\n\n    if (!responseBuffer) {\n      return \"\";\n    }\n\n    const fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n\n    properties.responseTextCache = res;\n    return res;\n  }\n  get responseXML() {\n    const { flag, properties } = this;\n    if (this.responseType !== \"\" && this.responseType !== \"document\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== READY_STATES.DONE) {\n      return null;\n    }\n    if (properties.responseXMLCache) {\n      return properties.responseXMLCache;\n    }\n    const responseBuffer = properties.responseBuffer ?\n      properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n      null;\n\n    if (!responseBuffer) {\n      return null;\n    }\n\n    const contentType = finalMIMEType(this);\n    let isHTML = false;\n    let isXML = false;\n    const parsed = MIMEType.parse(contentType);\n    if (parsed) {\n      isHTML = parsed.isHTML();\n      isXML = parsed.isXML();\n      if (!isXML && !isHTML) {\n        return null;\n      }\n    }\n\n    if (this.responseType === \"\" && isHTML) {\n      return null;\n    }\n\n    const encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n    if (!resText) {\n      return null;\n    }\n    const res = Document.createImpl(this._globalObject, [], {\n      options: {\n        url: flag.uri,\n        lastModified: new Date(getResponseHeader(this, \"last-modified\")),\n        parsingMode: isHTML ? \"html\" : \"xml\",\n        cookieJar: { setCookieSync: () => undefined, getCookieStringSync: () => \"\" },\n        encoding,\n        parseOptions: this._ownerDocument._parseOptions\n      }\n    });\n    try {\n      parseIntoDocument(resText, res);\n    } catch (e) {\n      properties.responseXMLCache = null;\n      return null;\n    }\n    res.close();\n    properties.responseXMLCache = res;\n    return res;\n  }\n\n  get timeout() {\n    return this.flag.timeout;\n  }\n  set timeout(val) {\n    const { flag, properties } = this;\n    if (flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    flag.timeout = val;\n    clearTimeout(properties.timeoutId);\n    if (val > 0 && properties.timeoutFn) {\n      properties.timeoutId = setTimeout(\n        properties.timeoutFn,\n        Math.max(0, val - ((new Date()).getTime() - properties.timeoutStart))\n      );\n    } else {\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n    }\n  }\n\n  get withCredentials() {\n    return this.flag.withCredentials;\n  }\n  set withCredentials(val) {\n    const { flag, properties } = this;\n    if (!(this.readyState === READY_STATES.UNSENT || this.readyState === READY_STATES.OPENED)) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    flag.withCredentials = val;\n  }\n\n  abort() {\n    const { properties } = this;\n    // Terminate the request\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n\n    const { client } = properties;\n    if (client) {\n      client.abort();\n      properties.client = null;\n    }\n\n    if (properties.abortError) {\n      // Special case that ideally shouldn't be going through the public API at all.\n      // Run the https://xhr.spec.whatwg.org/#handle-errors \"fatal\" steps.\n      this.readyState = READY_STATES.DONE;\n      properties.send = false;\n      xhrUtils.setResponseToNetworkError(this);\n      return;\n    }\n\n    if ((this.readyState === READY_STATES.OPENED && properties.send) ||\n        this.readyState === READY_STATES.HEADERS_RECEIVED ||\n        this.readyState === READY_STATES.LOADING) {\n      xhrUtils.requestErrorSteps(this, \"abort\");\n    }\n\n    if (this.readyState === READY_STATES.DONE) {\n      this.readyState = READY_STATES.UNSENT;\n\n      xhrUtils.setResponseToNetworkError(this);\n    }\n  }\n  getAllResponseHeaders() {\n    const { properties, readyState } = this;\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return \"\";\n    }\n    return Object.keys(properties.responseHeaders)\n      .filter(key => properties.filteredResponseHeaders.indexOf(key) === -1)\n      .map(key => [key.toLowerCase(), properties.responseHeaders[key]].join(\": \"))\n      .join(\"\\r\\n\");\n  }\n\n  getResponseHeader(header) {\n    const { properties, readyState } = this;\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return null;\n    }\n    const lcHeader = header.toLowerCase();\n    if (properties.filteredResponseHeaders.find(filtered => lcHeader === filtered.toLowerCase())) {\n      return null;\n    }\n    return getResponseHeader(this, lcHeader);\n  }\n\n  open(method, uri, asynchronous, user, password) {\n    const { flag, properties, _ownerDocument } = this;\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (!tokenRegexp.test(method)) {\n      throw DOMException.create(this._globalObject, [\n        \"The string did not match the expected pattern.\",\n        \"SyntaxError\"\n      ]);\n    }\n    const upperCaseMethod = method.toUpperCase();\n    if (forbiddenRequestMethods.has(upperCaseMethod)) {\n      throw DOMException.create(this._globalObject, [\"The operation is insecure.\", \"SecurityError\"]);\n    }\n\n    const { client } = properties;\n    if (client && typeof client.abort === \"function\") {\n      client.abort();\n    }\n\n    if (allowedRequestMethods.has(upperCaseMethod)) {\n      method = upperCaseMethod;\n    }\n    if (typeof asynchronous !== \"undefined\") {\n      flag.synchronous = !asynchronous;\n    } else {\n      flag.synchronous = false;\n    }\n    if (flag.responseType && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    if (flag.synchronous && flag.timeout) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    flag.method = method;\n\n    let urlObj;\n    try {\n      urlObj = new URL(uri, documentBaseURLSerialized(_ownerDocument));\n    } catch (e) {\n      throw DOMException.create(this._globalObject, [\n        \"The string did not match the expected pattern.\",\n        \"SyntaxError\"\n      ]);\n    }\n\n    if (user || (password && !urlObj.username)) {\n      flag.auth = {\n        user,\n        pass: password\n      };\n      urlObj.username = \"\";\n      urlObj.password = \"\";\n    }\n\n    flag.uri = urlObj.href;\n    flag.requestHeaders = {};\n    flag.preflight = false;\n\n    properties.send = false;\n    properties.uploadListener = false;\n    properties.abortError = false;\n    this.responseURL = \"\";\n    readyStateChange(this, READY_STATES.OPENED);\n  }\n\n  overrideMimeType(mime) {\n    const { readyState } = this;\n    if (readyState === READY_STATES.LOADING || readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    this.flag.overrideMIMEType = \"application/octet-stream\";\n\n    // Waiting for better spec: https://github.com/whatwg/xhr/issues/157\n    const parsed = MIMEType.parse(mime);\n    if (parsed) {\n      this.flag.overrideMIMEType = parsed.essence;\n\n      const charset = parsed.parameters.get(\"charset\");\n      if (charset) {\n        this.flag.overrideCharset = whatwgEncoding.labelToName(charset);\n      }\n    }\n  }\n\n  // TODO: Add support for URLSearchParams and ReadableStream\n  send(body) {\n    const { flag, properties, upload, _ownerDocument } = this;\n    // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    properties.beforeSend = true;\n\n    try {\n      if (flag.method === \"GET\" || flag.method === \"HEAD\") {\n        body = null;\n      }\n\n      if (body !== null) {\n        let encoding = null;\n        let mimeType = null;\n\n        if (Document.isImpl(body)) {\n          encoding = \"UTF-8\";\n          mimeType = (body._parsingMode === \"html\" ? \"text/html\" : \"application/xml\") + \";charset=UTF-8\";\n          flag.body = fragmentSerialization(body, { requireWellFormed: false });\n        } else {\n          if (typeof body === \"string\") {\n            encoding = \"UTF-8\";\n          }\n          const { buffer, formData, contentType } = extractBody(body);\n          mimeType = contentType;\n          flag.body = buffer || formData;\n          flag.formData = Boolean(formData);\n        }\n\n        const existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n        if (mimeType !== null && existingContentType === null) {\n          flag.requestHeaders[\"Content-Type\"] = mimeType;\n        } else if (existingContentType !== null && encoding !== null) {\n          // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what\n          // the spec will be, in the meantime.\n          const parsed = MIMEType.parse(existingContentType);\n          if (parsed) {\n            const charset = parsed.parameters.get(\"charset\");\n            if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {\n              parsed.parameters.set(\"charset\", encoding);\n              xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n            }\n          }\n        }\n      }\n    } finally {\n      if (properties.beforeSend) {\n        properties.beforeSend = false;\n      } else {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n    }\n\n    if (Object.keys(upload._eventListeners).length > 0) {\n      properties.uploadListener = true;\n    }\n\n    // request doesn't like zero-length bodies\n    if (flag.body && flag.body.byteLength === 0) {\n      flag.body = null;\n    }\n\n    if (flag.synchronous) {\n      const flagStr = JSON.stringify(flag, function (k, v) {\n        if (this === flag && k === \"requestManager\") {\n          return null;\n        }\n        if (this === flag && k === \"pool\" && v) {\n          return { maxSockets: v.maxSockets };\n        }\n        return v;\n      });\n      const res = spawnSync(\n        process.execPath,\n        [syncWorkerFile],\n        { input: flagStr, maxBuffer: Infinity }\n      );\n      if (res.status !== 0) {\n        throw new Error(res.stderr.toString());\n      }\n      if (res.error) {\n        if (typeof res.error === \"string\") {\n          res.error = new Error(res.error);\n        }\n        throw res.error;\n      }\n\n      const response = JSON.parse(res.stdout.toString());\n      const resProp = response.properties;\n      if (resProp.responseBuffer && resProp.responseBuffer.data) {\n        resProp.responseBuffer = Buffer.from(resProp.responseBuffer.data);\n      }\n      if (resProp.cookieJar) {\n        resProp.cookieJar = tough.CookieJar.deserializeSync(\n          resProp.cookieJar,\n          _ownerDocument._cookieJar.store\n        );\n      }\n\n      this.readyState = READY_STATES.LOADING;\n      this.status = response.status;\n      this.statusText = response.statusText;\n      this.responseURL = response.responseURL;\n      Object.assign(this.properties, response.properties);\n\n      if (resProp.error) {\n        xhrUtils.dispatchError(this);\n        throw DOMException.create(this._globalObject, [resProp.error, \"NetworkError\"]);\n      } else {\n        const { responseBuffer } = properties;\n        const contentLength = getResponseHeader(this, \"content-length\") || \"0\";\n        const bufferLength = parseInt(contentLength) || responseBuffer.length;\n        const progressObj = { lengthComputable: false };\n        if (bufferLength !== 0) {\n          progressObj.total = bufferLength;\n          progressObj.loaded = bufferLength;\n          progressObj.lengthComputable = true;\n        }\n        fireAnEvent(\"progress\", this, ProgressEvent, progressObj);\n        readyStateChange(this, READY_STATES.DONE);\n        fireAnEvent(\"load\", this, ProgressEvent, progressObj);\n        fireAnEvent(\"loadend\", this, ProgressEvent, progressObj);\n      }\n    } else {\n      properties.send = true;\n\n      fireAnEvent(\"loadstart\", this, ProgressEvent);\n\n      const client = xhrUtils.createClient(this);\n\n      properties.client = client;\n      // For new client, reset totalReceivedChunkSize and bufferStepSize\n      properties.totalReceivedChunkSize = 0;\n      properties.bufferStepSize = 1 * 1024 * 1024;\n\n      properties.origin = flag.origin;\n\n      client.on(\"error\", err => {\n        client.removeAllListeners();\n        properties.error = err;\n        xhrUtils.dispatchError(this);\n      });\n\n      client.on(\"response\", res => receiveResponse(this, res));\n\n      client.on(\"redirect\", () => {\n        const { response } = client;\n        const destUrlObj = new URL(response.request.headers.Referer);\n\n        const urlObj = new URL(response.request.uri.href);\n\n        if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n          properties.origin = \"null\";\n        }\n\n        response.request.headers.Origin = properties.origin;\n\n        if (flag.origin !== destUrlObj.origin &&\n            destUrlObj.protocol !== \"data:\") {\n          if (!xhrUtils.validCORSHeaders(this, response, flag, properties, flag.origin)) {\n            return;\n          }\n          if (urlObj.username || urlObj.password) {\n            properties.error = \"Userinfo forbidden in cors redirect\";\n            xhrUtils.dispatchError(this);\n          }\n        }\n      });\n      if (body !== null && body !== \"\") {\n        properties.uploadComplete = false;\n        setDispatchProgressEvents(this);\n      } else {\n        properties.uploadComplete = true;\n      }\n      if (this.timeout > 0) {\n        properties.timeoutStart = (new Date()).getTime();\n        properties.timeoutFn = () => {\n          client.abort();\n          if (!(this.readyState === READY_STATES.UNSENT ||\n              (this.readyState === READY_STATES.OPENED && !properties.send) ||\n              this.readyState === READY_STATES.DONE)) {\n            properties.send = false;\n            let stateChanged = false;\n            if (!properties.uploadComplete) {\n              fireAnEvent(\"progress\", upload, ProgressEvent);\n              readyStateChange(this, READY_STATES.DONE);\n              fireAnEvent(\"timeout\", upload, ProgressEvent);\n              fireAnEvent(\"loadend\", upload, ProgressEvent);\n              stateChanged = true;\n            }\n            fireAnEvent(\"progress\", this, ProgressEvent);\n            if (!stateChanged) {\n              readyStateChange(this, READY_STATES.DONE);\n            }\n            fireAnEvent(\"timeout\", this, ProgressEvent);\n            fireAnEvent(\"loadend\", this, ProgressEvent);\n          }\n          this.readyState = READY_STATES.UNSENT;\n        };\n        properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n      }\n    }\n  }\n\n  setRequestHeader(header, value) {\n    const { flag, properties } = this;\n\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    value = normalizeHeaderValue(value);\n\n    if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n      throw DOMException.create(this._globalObject, [\n        \"The string did not match the expected pattern.\",\n        \"SyntaxError\"\n      ]);\n    }\n\n    const lcHeader = header.toLowerCase();\n\n    if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n      return;\n    }\n\n    const keys = Object.keys(flag.requestHeaders);\n    let n = keys.length;\n    while (n--) {\n      const key = keys[n];\n      if (key.toLowerCase() === lcHeader) {\n        flag.requestHeaders[key] += \", \" + value;\n        return;\n      }\n    }\n    flag.requestHeaders[header] = value;\n  }\n}\n\nsetupForSimpleEventAccessors(XMLHttpRequestImpl.prototype, [\"readystatechange\"]);\n\nfunction readyStateChange(xhr, readyState) {\n  if (xhr.readyState === readyState) {\n    return;\n  }\n\n  xhr.readyState = readyState;\n\n  fireAnEvent(\"readystatechange\", xhr);\n}\n\nfunction receiveResponse(xhr, response) {\n  const { flag, properties } = xhr;\n  const { statusCode } = response;\n\n  let byteOffset = 0;\n\n  const headers = {};\n  const filteredResponseHeaders = [];\n  const headerMap = {};\n  const { rawHeaders } = response;\n  const n = Number(rawHeaders.length);\n  for (let i = 0; i < n; i += 2) {\n    const k = rawHeaders[i];\n    const kl = k.toLowerCase();\n    const v = rawHeaders[i + 1];\n    if (uniqueResponseHeaders.has(kl)) {\n      if (headerMap[kl] !== undefined) {\n        delete headers[headerMap[kl]];\n      }\n      headers[k] = v;\n    } else if (headerMap[kl] !== undefined) {\n      headers[headerMap[kl]] += \", \" + v;\n    } else {\n      headers[k] = v;\n    }\n    headerMap[kl] = k;\n  }\n\n  const destUrlObj = new URL(response.request.uri.href);\n  if (properties.origin !== destUrlObj.origin &&\n      destUrlObj.protocol !== \"data:\") {\n    if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n      return;\n    }\n    const acehStr = response.headers[\"access-control-expose-headers\"];\n    const aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);\n    for (const header in headers) {\n      const lcHeader = header.toLowerCase();\n      if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n        filteredResponseHeaders.push(header);\n      }\n    }\n  }\n\n  for (const header in headers) {\n    const lcHeader = header.toLowerCase();\n    if (forbiddenResponseHeaders.has(lcHeader)) {\n      filteredResponseHeaders.push(header);\n    }\n  }\n\n  xhr.responseURL = destUrlObj.href;\n\n  xhr.status = statusCode;\n  xhr.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n\n  properties.responseHeaders = headers;\n  properties.filteredResponseHeaders = filteredResponseHeaders;\n\n  const contentLength = getResponseHeader(xhr, \"content-length\") || \"0\";\n  const bufferLength = parseInt(contentLength) || 0;\n  const progressObj = { lengthComputable: false };\n  let lastProgressReported;\n  if (bufferLength !== 0) {\n    progressObj.total = bufferLength;\n    progressObj.loaded = 0;\n    progressObj.lengthComputable = true;\n  }\n  // pre-allocate buffer.\n  properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);\n  properties.responseCache = null;\n  properties.responseTextCache = null;\n  properties.responseXMLCache = null;\n  readyStateChange(xhr, READY_STATES.HEADERS_RECEIVED);\n\n  if (!properties.client) {\n    // The request was aborted in reaction to the readystatechange event.\n    return;\n  }\n\n  // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n  // Content-Length).\n  response.on(\"data\", chunk => {\n    byteOffset += chunk.length;\n    progressObj.loaded = byteOffset;\n  });\n\n  properties.client.on(\"data\", chunk => {\n    properties.totalReceivedChunkSize += chunk.length;\n    if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n      properties.bufferStepSize *= 2;\n      while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n        properties.bufferStepSize *= 2;\n      }\n      const tmpBuf = Buffer.alloc(properties.bufferStepSize);\n      properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);\n      properties.responseBuffer = tmpBuf;\n    }\n    chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n\n    if (xhr.readyState === READY_STATES.HEADERS_RECEIVED) {\n      xhr.readyState = READY_STATES.LOADING;\n    }\n    fireAnEvent(\"readystatechange\", xhr);\n\n    if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {\n      if (lastProgressReported !== progressObj.loaded) {\n        // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n        // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n        lastProgressReported = progressObj.loaded;\n        fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n      }\n    }\n  });\n  properties.client.on(\"end\", () => {\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n    properties.client = null;\n    fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n    readyStateChange(xhr, READY_STATES.DONE);\n    fireAnEvent(\"load\", xhr, ProgressEvent, progressObj);\n    fireAnEvent(\"loadend\", xhr, ProgressEvent, progressObj);\n  });\n}\n\nfunction setDispatchProgressEvents(xhr) {\n  const { properties, upload } = xhr;\n  const { client } = properties;\n\n  let total = 0;\n  let lengthComputable = false;\n  const length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n  if (length) {\n    total = length;\n    lengthComputable = true;\n  }\n  const initProgress = {\n    lengthComputable,\n    total,\n    loaded: 0\n  };\n\n  if (properties.uploadListener) {\n    fireAnEvent(\"loadstart\", upload, ProgressEvent, initProgress);\n  }\n\n  client.on(\"request\", req => {\n    req.on(\"response\", () => {\n      properties.uploadComplete = true;\n\n      if (!properties.uploadListener) {\n        return;\n      }\n\n      const progress = {\n        lengthComputable,\n        total,\n        loaded: total\n      };\n      fireAnEvent(\"progress\", upload, ProgressEvent, progress);\n      fireAnEvent(\"load\", upload, ProgressEvent, progress);\n      fireAnEvent(\"loadend\", upload, ProgressEvent, progress);\n    });\n  });\n}\n\nfunction finalMIMEType(xhr) {\n  const { flag } = xhr;\n  return flag.overrideMIMEType || getResponseHeader(xhr, \"content-type\");\n}\n\nfunction finalCharset(xhr) {\n  const { flag } = xhr;\n  if (flag.overrideCharset) {\n    return flag.overrideCharset;\n  }\n  const parsedContentType = MIMEType.parse(getResponseHeader(xhr, \"content-type\"));\n  if (parsedContentType) {\n    return whatwgEncoding.labelToName(parsedContentType.parameters.get(\"charset\"));\n  }\n  return null;\n}\n\nfunction getResponseHeader(xhr, lcHeader) {\n  const { properties } = xhr;\n  const keys = Object.keys(properties.responseHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return properties.responseHeaders[key];\n    }\n  }\n  return null;\n}\n\nfunction normalizeHeaderValue(value) {\n  return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n}\n\nfunction extractBody(bodyInit) {\n  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n  // except we represent the body as a Node.js Buffer instead,\n  // or a special case for FormData since we want request to handle that. Probably it would be\n  // cleaner (and allow a future without request) if we did the form encoding ourself.\n\n  if (Blob.isImpl(bodyInit)) {\n    return {\n      buffer: bodyInit._buffer,\n      contentType: bodyInit.type === \"\" ? null : bodyInit.type\n    };\n  } else if (isArrayBuffer(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit),\n      contentType: null\n    };\n  } else if (ArrayBuffer.isView(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),\n      contentType: null\n    };\n  } else if (FormData.isImpl(bodyInit)) {\n    const formData = [];\n    for (const entry of bodyInit._entries) {\n      let val;\n      if (Blob.isImpl(entry.value)) {\n        const blob = entry.value;\n        val = {\n          name: entry.name,\n          value: blob._buffer,\n          options: {\n            filename: blob.name,\n            contentType: blob.type,\n            knownLength: blob.size\n          }\n        };\n      } else {\n        val = entry;\n      }\n\n      formData.push(val);\n    }\n\n    return { formData };\n  }\n\n  // Must be a string\n  return {\n    buffer: Buffer.from(bodyInit, \"utf-8\"),\n    contentType: \"text/plain;charset=UTF-8\"\n  };\n}\n\nexports.implementation = XMLHttpRequestImpl;\n"]},"metadata":{},"sourceType":"script"}