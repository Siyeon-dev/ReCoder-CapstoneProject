{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\n\nconst request = require(\"request\");\n\nconst {\n  EventEmitter\n} = require(\"events\");\n\nconst {\n  URL\n} = require(\"whatwg-url\");\n\nconst parseDataURL = require(\"data-urls\");\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\n\nconst wrapCookieJarForRequest = require(\"../helpers/wrap-cookie-jar-for-request\");\n\nconst {\n  fireAnEvent\n} = require(\"../helpers/events\");\n\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nconst simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nconst preflightHeaders = new Set([\"access-control-expose-headers\", \"access-control-allow-headers\", \"access-control-allow-credentials\", \"access-control-allow-origin\"]);\nconst READY_STATES = exports.READY_STATES = Object.freeze({\n  UNSENT: 0,\n  OPENED: 1,\n  HEADERS_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4\n});\n\nfunction getRequestHeader(requestHeaders, header) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n\n  while (n--) {\n    const key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n\n  while (n--) {\n    const key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nfunction dispatchError(xhr) {\n  const errMessage = xhr.properties.error;\n  requestErrorSteps(xhr, \"error\", DOMException.create(xhr._globalObject, [errMessage, \"NetworkError\"]));\n\n  if (xhr._ownerDocument) {\n    const error = new Error(errMessage);\n    error.type = \"XMLHttpRequest\"; // TODO this should become \"resource loading\" when XHR goes through resource loader\n\n    xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n  }\n}\n\nfunction validCORSHeaders(xhr, response, flag, properties, origin) {\n  const acaoStr = response.headers[\"access-control-allow-origin\"];\n  const acao = acaoStr ? acaoStr.trim() : null;\n\n  if (acao !== \"*\" && acao !== origin) {\n    properties.error = \"Cross origin \" + origin + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  const acacStr = response.headers[\"access-control-allow-credentials\"];\n  const acac = acacStr ? acacStr.trim() : null;\n\n  if (flag.withCredentials && acac !== \"true\") {\n    properties.error = \"Credentials forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  return true;\n}\n\nfunction validCORSPreflightHeaders(xhr, response, flag, properties) {\n  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n    return false;\n  }\n\n  const acahStr = response.headers[\"access-control-allow-headers\"];\n  const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n  const forbiddenHeaders = Object.keys(flag.requestHeaders).filter(header => {\n    const lcHeader = header.toLowerCase();\n    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n  });\n\n  if (forbiddenHeaders.length > 0) {\n    properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  return true;\n}\n\nfunction requestErrorSteps(xhr, event, exception) {\n  const {\n    flag,\n    properties,\n    upload\n  } = xhr;\n  xhr.readyState = READY_STATES.DONE;\n  properties.send = false;\n  setResponseToNetworkError(xhr);\n\n  if (flag.synchronous) {\n    throw exception;\n  }\n\n  fireAnEvent(\"readystatechange\", xhr);\n\n  if (!properties.uploadComplete) {\n    properties.uploadComplete = true;\n\n    if (properties.uploadListener) {\n      fireAnEvent(event, upload, ProgressEvent, {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      });\n      fireAnEvent(\"loadend\", upload, ProgressEvent, {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      });\n    }\n  }\n\n  fireAnEvent(event, xhr, ProgressEvent, {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  });\n  fireAnEvent(\"loadend\", xhr, ProgressEvent, {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  });\n}\n\nfunction setResponseToNetworkError(xhr) {\n  const {\n    properties\n  } = xhr;\n  properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n  properties.responseHeaders = {};\n  xhr.status = 0;\n  xhr.statusText = \"\";\n} // return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\n\n\nfunction createClient(xhr) {\n  const {\n    flag,\n    properties\n  } = xhr;\n  const urlObj = new URL(flag.uri);\n  const uri = urlObj.href;\n  const ucMethod = flag.method.toUpperCase();\n  const {\n    requestManager\n  } = flag;\n\n  if (urlObj.protocol === \"file:\") {\n    const response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    response.request = {\n      uri: urlObj\n    };\n    const filePath = urlObj.pathname.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, \"$1:/\").replace(/%20/g, \" \");\n    const client = new EventEmitter();\n    const readableStream = fs.createReadStream(filePath, {\n      encoding: null\n    });\n    readableStream.on(\"data\", chunk => {\n      response.emit(\"data\", chunk);\n      client.emit(\"data\", chunk);\n    });\n    readableStream.on(\"end\", () => {\n      response.emit(\"end\");\n      client.emit(\"end\");\n    });\n    readableStream.on(\"error\", err => {\n      client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      readableStream.destroy();\n      client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      const req = {\n        abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n\n      };\n      requestManager.add(req);\n      const rmReq = requestManager.remove.bind(requestManager, req);\n      client.on(\"abort\", rmReq);\n      client.on(\"error\", rmReq);\n      client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(() => client.emit(\"response\", response));\n    return client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    const response = new EventEmitter();\n    response.request = {\n      uri: urlObj\n    };\n    const client = new EventEmitter();\n    let buffer;\n\n    try {\n      const parsed = parseDataURL(uri);\n      const contentType = parsed.mimeType.toString();\n      buffer = parsed.body;\n      response.statusCode = 200;\n      response.rawHeaders = [\"Content-Type\", contentType];\n      response.headers = {\n        \"content-type\": contentType\n      };\n    } catch (err) {\n      process.nextTick(() => client.emit(\"error\", err));\n      return client;\n    }\n\n    client.abort = () => {// do nothing\n    };\n\n    process.nextTick(() => {\n      client.emit(\"response\", response);\n      process.nextTick(() => {\n        response.emit(\"data\", buffer);\n        client.emit(\"data\", buffer);\n        response.emit(\"end\");\n        client.emit(\"end\");\n      });\n    });\n    return client;\n  }\n\n  const requestHeaders = {};\n\n  for (const header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  const crossOrigin = flag.origin !== urlObj.origin;\n\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  const options = {\n    uri,\n    method: flag.method,\n    headers: requestHeaders,\n    gzip: true,\n    maxRedirects: 21,\n    followAllRedirects: true,\n    encoding: null,\n    strictSSL: flag.strictSSL,\n    proxy: flag.proxy,\n    forever: true\n  };\n\n  if (flag.auth) {\n    options.auth = {\n      user: flag.auth.user || \"\",\n      pass: flag.auth.pass || \"\",\n      sendImmediately: false\n    };\n  }\n\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.jar = wrapCookieJarForRequest(flag.cookieJar);\n  }\n\n  const {\n    body\n  } = flag;\n  const hasBody = body !== undefined && body !== null && body !== \"\" && !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && !flag.formData) {\n    options.body = body;\n  }\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      const client = request(options);\n\n      if (hasBody && flag.formData) {\n        const form = client.form();\n\n        for (const entry of body) {\n          form.append(entry.name, entry.value, entry.options);\n        }\n      }\n\n      return client;\n    } catch (e) {\n      const client = new EventEmitter();\n      process.nextTick(() => client.emit(\"error\", e));\n      return client;\n    }\n  }\n\n  let client;\n  const nonSimpleHeaders = Object.keys(flag.requestHeaders).filter(header => !simpleHeaders.has(header.toLowerCase()));\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {\n    client = new EventEmitter();\n    const preflightRequestHeaders = [];\n\n    for (const header in requestHeaders) {\n      // the only existing request headers the cors spec allows on the preflight request are Origin and Referrer\n      const lcHeader = header.toLowerCase();\n\n      if (lcHeader === \"origin\" || lcHeader === \"referrer\") {\n        preflightRequestHeaders[header] = requestHeaders[header];\n      }\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    preflightRequestHeaders[\"User-Agent\"] = flag.userAgent;\n    flag.preflight = true;\n    const preflightOptions = {\n      uri,\n      method: \"OPTIONS\",\n      headers: preflightRequestHeaders,\n      followRedirect: false,\n      encoding: null,\n      pool: flag.pool,\n      strictSSL: flag.strictSSL,\n      proxy: flag.proxy,\n      forever: true\n    };\n    const preflightClient = request(preflightOptions);\n    preflightClient.on(\"response\", resp => {\n      // don't send the real request if the preflight request returned an error\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n        return;\n      } // don't send the real request if we aren't allowed to use the headers\n\n\n      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {\n        setResponseToNetworkError(xhr);\n        return;\n      }\n\n      const realClient = doRequest();\n      realClient.on(\"response\", res => client.emit(\"response\", res));\n      realClient.on(\"data\", chunk => client.emit(\"data\", chunk));\n      realClient.on(\"end\", () => client.emit(\"end\"));\n      realClient.on(\"abort\", () => client.emit(\"abort\"));\n      realClient.on(\"request\", req => {\n        client.headers = realClient.headers;\n        client.emit(\"request\", req);\n      });\n      realClient.on(\"redirect\", () => {\n        client.response = realClient.response;\n        client.emit(\"redirect\");\n      });\n      realClient.on(\"error\", err => client.emit(\"error\", err));\n\n      client.abort = () => {\n        realClient.abort();\n      };\n    });\n    preflightClient.on(\"error\", err => client.emit(\"error\", err));\n\n    client.abort = () => {\n      preflightClient.abort();\n    };\n  } else {\n    client = doRequest();\n  }\n\n  if (requestManager) {\n    const req = {\n      abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n\n    };\n    requestManager.add(req);\n    const rmReq = requestManager.remove.bind(requestManager, req);\n    client.on(\"abort\", rmReq);\n    client.on(\"error\", rmReq);\n    client.on(\"end\", rmReq);\n  }\n\n  return client;\n}\n\nexports.headerListSeparatorRegexp = headerListSeparatorRegexp;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.dispatchError = dispatchError;\nexports.validCORSHeaders = validCORSHeaders;\nexports.requestErrorSteps = requestErrorSteps;\nexports.setResponseToNetworkError = setResponseToNetworkError;\nexports.createClient = createClient;","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/jsdom/lib/jsdom/living/xhr/xhr-utils.js"],"names":["fs","require","request","EventEmitter","URL","parseDataURL","DOMException","ProgressEvent","wrapCookieJarForRequest","fireAnEvent","headerListSeparatorRegexp","simpleMethods","Set","simpleHeaders","preflightHeaders","READY_STATES","exports","Object","freeze","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","getRequestHeader","requestHeaders","header","lcHeader","toLowerCase","keys","n","length","key","updateRequestHeader","newValue","dispatchError","xhr","errMessage","properties","error","requestErrorSteps","create","_globalObject","_ownerDocument","Error","type","_defaultView","_virtualConsole","emit","validCORSHeaders","response","flag","origin","acaoStr","headers","acao","trim","acacStr","acac","withCredentials","validCORSPreflightHeaders","acahStr","acah","split","forbiddenHeaders","filter","has","event","exception","upload","readyState","send","setResponseToNetworkError","synchronous","uploadComplete","uploadListener","loaded","total","lengthComputable","responseCache","responseTextCache","responseXMLCache","responseHeaders","status","statusText","createClient","urlObj","uri","href","ucMethod","method","toUpperCase","requestManager","protocol","statusCode","rawHeaders","filePath","pathname","replace","client","readableStream","createReadStream","encoding","on","chunk","err","abort","destroy","req","abortError","add","rmReq","remove","bind","process","nextTick","buffer","parsed","contentType","mimeType","toString","body","Referer","referrer","userAgent","Accept","crossOrigin","Origin","options","gzip","maxRedirects","followAllRedirects","strictSSL","proxy","forever","auth","user","pass","sendImmediately","cookieJar","jar","hasBody","undefined","formData","doRequest","form","entry","append","name","value","e","nonSimpleHeaders","preflightRequestHeaders","join","preflight","preflightOptions","followRedirect","pool","preflightClient","resp","realClient","res"],"mappings":"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","sourcesContent":["\"use strict\";\nconst fs = require(\"fs\");\nconst request = require(\"request\");\nconst { EventEmitter } = require(\"events\");\nconst { URL } = require(\"whatwg-url\");\nconst parseDataURL = require(\"data-urls\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\n\nconst wrapCookieJarForRequest = require(\"../helpers/wrap-cookie-jar-for-request\");\nconst { fireAnEvent } = require(\"../helpers/events\");\n\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nconst simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nconst preflightHeaders = new Set([\n  \"access-control-expose-headers\",\n  \"access-control-allow-headers\",\n  \"access-control-allow-credentials\",\n  \"access-control-allow-origin\"\n]);\n\nconst READY_STATES = exports.READY_STATES = Object.freeze({\n  UNSENT: 0,\n  OPENED: 1,\n  HEADERS_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4\n});\n\nfunction getRequestHeader(requestHeaders, header) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nfunction dispatchError(xhr) {\n  const errMessage = xhr.properties.error;\n  requestErrorSteps(xhr, \"error\", DOMException.create(xhr._globalObject, [errMessage, \"NetworkError\"]));\n\n  if (xhr._ownerDocument) {\n    const error = new Error(errMessage);\n    error.type = \"XMLHttpRequest\"; // TODO this should become \"resource loading\" when XHR goes through resource loader\n\n    xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n  }\n}\n\nfunction validCORSHeaders(xhr, response, flag, properties, origin) {\n  const acaoStr = response.headers[\"access-control-allow-origin\"];\n  const acao = acaoStr ? acaoStr.trim() : null;\n  if (acao !== \"*\" && acao !== origin) {\n    properties.error = \"Cross origin \" + origin + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  const acacStr = response.headers[\"access-control-allow-credentials\"];\n  const acac = acacStr ? acacStr.trim() : null;\n  if (flag.withCredentials && acac !== \"true\") {\n    properties.error = \"Credentials forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  return true;\n}\n\nfunction validCORSPreflightHeaders(xhr, response, flag, properties) {\n  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n    return false;\n  }\n  const acahStr = response.headers[\"access-control-allow-headers\"];\n  const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n  const forbiddenHeaders = Object.keys(flag.requestHeaders).filter(header => {\n    const lcHeader = header.toLowerCase();\n    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n  });\n  if (forbiddenHeaders.length > 0) {\n    properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  return true;\n}\n\nfunction requestErrorSteps(xhr, event, exception) {\n  const { flag, properties, upload } = xhr;\n\n  xhr.readyState = READY_STATES.DONE;\n  properties.send = false;\n\n  setResponseToNetworkError(xhr);\n\n  if (flag.synchronous) {\n    throw exception;\n  }\n\n  fireAnEvent(\"readystatechange\", xhr);\n\n  if (!properties.uploadComplete) {\n    properties.uploadComplete = true;\n\n    if (properties.uploadListener) {\n      fireAnEvent(event, upload, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n      fireAnEvent(\"loadend\", upload, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n    }\n  }\n\n  fireAnEvent(event, xhr, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n  fireAnEvent(\"loadend\", xhr, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n}\n\nfunction setResponseToNetworkError(xhr) {\n  const { properties } = xhr;\n  properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n  properties.responseHeaders = {};\n  xhr.status = 0;\n  xhr.statusText = \"\";\n}\n\n// return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\nfunction createClient(xhr) {\n  const { flag, properties } = xhr;\n  const urlObj = new URL(flag.uri);\n  const uri = urlObj.href;\n  const ucMethod = flag.method.toUpperCase();\n\n  const { requestManager } = flag;\n\n  if (urlObj.protocol === \"file:\") {\n    const response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    response.request = { uri: urlObj };\n    const filePath = urlObj.pathname\n      .replace(/^file:\\/\\//, \"\")\n      .replace(/^\\/([a-z]):\\//i, \"$1:/\")\n      .replace(/%20/g, \" \");\n\n    const client = new EventEmitter();\n\n    const readableStream = fs.createReadStream(filePath, { encoding: null });\n\n    readableStream.on(\"data\", chunk => {\n      response.emit(\"data\", chunk);\n      client.emit(\"data\", chunk);\n    });\n\n    readableStream.on(\"end\", () => {\n      response.emit(\"end\");\n      client.emit(\"end\");\n    });\n\n    readableStream.on(\"error\", err => {\n      client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      readableStream.destroy();\n      client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      const req = {\n        abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n      };\n      requestManager.add(req);\n      const rmReq = requestManager.remove.bind(requestManager, req);\n      client.on(\"abort\", rmReq);\n      client.on(\"error\", rmReq);\n      client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(() => client.emit(\"response\", response));\n\n    return client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    const response = new EventEmitter();\n\n    response.request = { uri: urlObj };\n\n    const client = new EventEmitter();\n\n    let buffer;\n    try {\n      const parsed = parseDataURL(uri);\n      const contentType = parsed.mimeType.toString();\n      buffer = parsed.body;\n      response.statusCode = 200;\n      response.rawHeaders = [\"Content-Type\", contentType];\n      response.headers = { \"content-type\": contentType };\n    } catch (err) {\n      process.nextTick(() => client.emit(\"error\", err));\n      return client;\n    }\n\n    client.abort = () => {\n      // do nothing\n    };\n\n    process.nextTick(() => {\n      client.emit(\"response\", response);\n      process.nextTick(() => {\n        response.emit(\"data\", buffer);\n        client.emit(\"data\", buffer);\n        response.emit(\"end\");\n        client.emit(\"end\");\n      });\n    });\n\n    return client;\n  }\n\n  const requestHeaders = {};\n\n  for (const header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  const crossOrigin = flag.origin !== urlObj.origin;\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  const options = {\n    uri,\n    method: flag.method,\n    headers: requestHeaders,\n    gzip: true,\n    maxRedirects: 21,\n    followAllRedirects: true,\n    encoding: null,\n    strictSSL: flag.strictSSL,\n    proxy: flag.proxy,\n    forever: true\n  };\n  if (flag.auth) {\n    options.auth = {\n      user: flag.auth.user || \"\",\n      pass: flag.auth.pass || \"\",\n      sendImmediately: false\n    };\n  }\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.jar = wrapCookieJarForRequest(flag.cookieJar);\n  }\n\n  const { body } = flag;\n  const hasBody = body !== undefined &&\n                  body !== null &&\n                  body !== \"\" &&\n                  !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && !flag.formData) {\n    options.body = body;\n  }\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      const client = request(options);\n\n      if (hasBody && flag.formData) {\n        const form = client.form();\n        for (const entry of body) {\n          form.append(entry.name, entry.value, entry.options);\n        }\n      }\n\n      return client;\n    } catch (e) {\n      const client = new EventEmitter();\n      process.nextTick(() => client.emit(\"error\", e));\n      return client;\n    }\n  }\n\n  let client;\n\n  const nonSimpleHeaders = Object.keys(flag.requestHeaders)\n    .filter(header => !simpleHeaders.has(header.toLowerCase()));\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {\n    client = new EventEmitter();\n\n    const preflightRequestHeaders = [];\n    for (const header in requestHeaders) {\n      // the only existing request headers the cors spec allows on the preflight request are Origin and Referrer\n      const lcHeader = header.toLowerCase();\n      if (lcHeader === \"origin\" || lcHeader === \"referrer\") {\n        preflightRequestHeaders[header] = requestHeaders[header];\n      }\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    preflightRequestHeaders[\"User-Agent\"] = flag.userAgent;\n\n    flag.preflight = true;\n\n    const preflightOptions = {\n      uri,\n      method: \"OPTIONS\",\n      headers: preflightRequestHeaders,\n      followRedirect: false,\n      encoding: null,\n      pool: flag.pool,\n      strictSSL: flag.strictSSL,\n      proxy: flag.proxy,\n      forever: true\n    };\n\n    const preflightClient = request(preflightOptions);\n\n    preflightClient.on(\"response\", resp => {\n      // don't send the real request if the preflight request returned an error\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n        return;\n      }\n      // don't send the real request if we aren't allowed to use the headers\n      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {\n        setResponseToNetworkError(xhr);\n        return;\n      }\n      const realClient = doRequest();\n      realClient.on(\"response\", res => client.emit(\"response\", res));\n      realClient.on(\"data\", chunk => client.emit(\"data\", chunk));\n      realClient.on(\"end\", () => client.emit(\"end\"));\n      realClient.on(\"abort\", () => client.emit(\"abort\"));\n      realClient.on(\"request\", req => {\n        client.headers = realClient.headers;\n        client.emit(\"request\", req);\n      });\n      realClient.on(\"redirect\", () => {\n        client.response = realClient.response;\n        client.emit(\"redirect\");\n      });\n      realClient.on(\"error\", err => client.emit(\"error\", err));\n      client.abort = () => {\n        realClient.abort();\n      };\n    });\n\n    preflightClient.on(\"error\", err => client.emit(\"error\", err));\n\n    client.abort = () => {\n      preflightClient.abort();\n    };\n  } else {\n    client = doRequest();\n  }\n\n  if (requestManager) {\n    const req = {\n      abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n    };\n    requestManager.add(req);\n    const rmReq = requestManager.remove.bind(requestManager, req);\n    client.on(\"abort\", rmReq);\n    client.on(\"error\", rmReq);\n    client.on(\"end\", rmReq);\n  }\n\n  return client;\n}\n\nexports.headerListSeparatorRegexp = headerListSeparatorRegexp;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.dispatchError = dispatchError;\nexports.validCORSHeaders = validCORSHeaders;\nexports.requestErrorSteps = requestErrorSteps;\nexports.setResponseToNetworkError = setResponseToNetworkError;\nexports.createClient = createClient;\n"]},"metadata":{},"sourceType":"script"}