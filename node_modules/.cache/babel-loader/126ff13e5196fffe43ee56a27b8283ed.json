{"ast":null,"code":"'use strict';\n\nmodule.exports = class SymbolTreeNode {\n  constructor() {\n    this.parent = null;\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this.firstChild = null;\n    this.lastChild = null;\n    /** This value is incremented anytime a children is added or removed */\n\n    this.childrenVersion = 0;\n    /** The last child object which has a cached index */\n\n    this.childIndexCachedUpTo = null;\n    /** This value represents the cached node index, as long as\n     * cachedIndexVersion matches with the childrenVersion of the parent */\n\n    this.cachedIndex = -1;\n    this.cachedIndexVersion = NaN; // NaN is never equal to anything\n  }\n\n  get isAttached() {\n    return Boolean(this.parent || this.previousSibling || this.nextSibling);\n  }\n\n  get hasChildren() {\n    return Boolean(this.firstChild);\n  }\n\n  childrenChanged() {\n    /* jshint -W016 */\n    // integer wrap around\n    this.childrenVersion = this.childrenVersion + 1 & 0xFFFFFFFF;\n    this.childIndexCachedUpTo = null;\n  }\n\n  getCachedIndex(parentNode) {\n    // (assumes parentNode is actually the parent)\n    if (this.cachedIndexVersion !== parentNode.childrenVersion) {\n      this.cachedIndexVersion = NaN; // cachedIndex is no longer valid\n\n      return -1;\n    }\n\n    return this.cachedIndex; // -1 if not cached\n  }\n\n  setCachedIndex(parentNode, index) {\n    // (assumes parentNode is actually the parent)\n    this.cachedIndexVersion = parentNode.childrenVersion;\n    this.cachedIndex = index;\n  }\n\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/symbol-tree/lib/SymbolTreeNode.js"],"names":["module","exports","SymbolTreeNode","constructor","parent","previousSibling","nextSibling","firstChild","lastChild","childrenVersion","childIndexCachedUpTo","cachedIndex","cachedIndexVersion","NaN","isAttached","Boolean","hasChildren","childrenChanged","getCachedIndex","parentNode","setCachedIndex","index"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,MAAMC,cAAN,CAAqB;AAC9BC,EAAAA,WAAW,GAAG;AACN,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKC,eAAL,GAAuB,IAAvB;AACA,SAAKC,WAAL,GAAmB,IAAnB;AAEA,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKC,SAAL,GAAiB,IAAjB;AAEA;;AACA,SAAKC,eAAL,GAAuB,CAAvB;AACA;;AACA,SAAKC,oBAAL,GAA4B,IAA5B;AAEA;AAChB;;AACgB,SAAKC,WAAL,GAAmB,CAAC,CAApB;AACA,SAAKC,kBAAL,GAA0BC,GAA1B,CAhBM,CAgByB;AACtC;;AAEa,MAAVC,UAAU,GAAG;AACT,WAAOC,OAAO,CAAC,KAAKX,MAAL,IAAe,KAAKC,eAApB,IAAuC,KAAKC,WAA7C,CAAd;AACP;;AAEc,MAAXU,WAAW,GAAG;AACV,WAAOD,OAAO,CAAC,KAAKR,UAAN,CAAd;AACP;;AAEDU,EAAAA,eAAe,GAAG;AACV;AACA;AACA,SAAKR,eAAL,GAAwB,KAAKA,eAAL,GAAuB,CAAxB,GAA6B,UAApD;AACA,SAAKC,oBAAL,GAA4B,IAA5B;AACP;;AAEDQ,EAAAA,cAAc,CAACC,UAAD,EAAa;AACnB;AACA,QAAI,KAAKP,kBAAL,KAA4BO,UAAU,CAACV,eAA3C,EAA4D;AACpD,WAAKG,kBAAL,GAA0BC,GAA1B,CADoD,CAEpD;;AACA,aAAO,CAAC,CAAR;AACP;;AAED,WAAO,KAAKF,WAAZ,CARmB,CAQM;AAChC;;AAEDS,EAAAA,cAAc,CAACD,UAAD,EAAaE,KAAb,EAAoB;AAC1B;AACA,SAAKT,kBAAL,GAA0BO,UAAU,CAACV,eAArC;AACA,SAAKE,WAAL,GAAmBU,KAAnB;AACP;;AAlD6B,CAAtC","sourcesContent":["'use strict';\n\nmodule.exports = class SymbolTreeNode {\n        constructor() {\n                this.parent = null;\n                this.previousSibling = null;\n                this.nextSibling = null;\n\n                this.firstChild = null;\n                this.lastChild = null;\n\n                /** This value is incremented anytime a children is added or removed */\n                this.childrenVersion = 0;\n                /** The last child object which has a cached index */\n                this.childIndexCachedUpTo = null;\n\n                /** This value represents the cached node index, as long as\n                 * cachedIndexVersion matches with the childrenVersion of the parent */\n                this.cachedIndex = -1;\n                this.cachedIndexVersion = NaN; // NaN is never equal to anything\n        }\n\n        get isAttached() {\n                return Boolean(this.parent || this.previousSibling || this.nextSibling);\n        }\n\n        get hasChildren() {\n                return Boolean(this.firstChild);\n        }\n\n        childrenChanged() {\n                /* jshint -W016 */\n                // integer wrap around\n                this.childrenVersion = (this.childrenVersion + 1) & 0xFFFFFFFF;\n                this.childIndexCachedUpTo = null;\n        }\n\n        getCachedIndex(parentNode) {\n                // (assumes parentNode is actually the parent)\n                if (this.cachedIndexVersion !== parentNode.childrenVersion) {\n                        this.cachedIndexVersion = NaN;\n                        // cachedIndex is no longer valid\n                        return -1;\n                }\n\n                return this.cachedIndex; // -1 if not cached\n        }\n\n        setCachedIndex(parentNode, index) {\n                // (assumes parentNode is actually the parent)\n                this.cachedIndexVersion = parentNode.childrenVersion;\n                this.cachedIndex = index;\n        }\n};\n"]},"metadata":{},"sourceType":"script"}