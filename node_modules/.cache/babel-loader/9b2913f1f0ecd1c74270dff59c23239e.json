{"ast":null,"code":"\"use strict\";\n/**\n * Queue for all the resources to be download except async scripts.\n * Async scripts have their own queue AsyncResourceQueue.\n */\n\nmodule.exports = class ResourceQueue {\n  constructor({\n    paused,\n    asyncQueue\n  } = {}) {\n    this.paused = Boolean(paused);\n    this._asyncQueue = asyncQueue;\n  }\n\n  getLastScript() {\n    let head = this.tail;\n\n    while (head) {\n      if (head.isScript) {\n        return head;\n      }\n\n      head = head.prev;\n    }\n\n    return null;\n  }\n\n  _moreScripts() {\n    let found = false;\n    let head = this.tail;\n\n    while (head && !found) {\n      found = head.isScript;\n      head = head.prev;\n    }\n\n    return found;\n  }\n\n  _notify() {\n    if (this._listener) {\n      this._listener();\n    }\n  }\n\n  setListener(listener) {\n    this._listener = listener;\n  }\n\n  push(request, onLoad, onError, keepLast, element) {\n    const isScript = element ? element.localName === \"script\" : false;\n\n    if (!request) {\n      if (isScript && !this._moreScripts()) {\n        return onLoad();\n      }\n\n      request = new Promise(resolve => resolve());\n    }\n\n    const q = this;\n    const item = {\n      isScript,\n      err: null,\n      element,\n      fired: false,\n      data: null,\n      keepLast,\n      prev: q.tail,\n\n      check() {\n        if (!q.paused && !this.prev && this.fired) {\n          let promise;\n\n          if (this.err && onError) {\n            promise = onError(this.err);\n          }\n\n          if (!this.err && onLoad) {\n            promise = onLoad(this.data);\n          }\n\n          Promise.resolve(promise).then(() => {\n            if (this.next) {\n              this.next.prev = null;\n              this.next.check();\n            } else {\n              // q.tail===this\n              q.tail = null;\n\n              q._notify();\n            }\n\n            this.finished = true;\n\n            if (q._asyncQueue) {\n              q._asyncQueue.notifyItem(this);\n            }\n          });\n        }\n      }\n\n    };\n\n    if (q.tail) {\n      if (q.tail.keepLast) {\n        // if the tail is the load event in document and we receive a new element to load\n        // we should add this new request before the load event.\n        if (q.tail.prev) {\n          q.tail.prev.next = item;\n        }\n\n        item.prev = q.tail.prev;\n        q.tail.prev = item;\n        item.next = q.tail;\n      } else {\n        q.tail.next = item;\n        q.tail = item;\n      }\n    } else {\n      q.tail = item;\n    }\n\n    return request.then(data => {\n      item.fired = 1;\n      item.data = data;\n      item.check();\n    }).catch(err => {\n      item.fired = true;\n      item.err = err;\n      item.check();\n    });\n  }\n\n  resume() {\n    if (!this.paused) {\n      return;\n    }\n\n    this.paused = false;\n    let head = this.tail;\n\n    while (head && head.prev) {\n      head = head.prev;\n    }\n\n    if (head) {\n      head.check();\n    }\n  }\n\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js"],"names":["module","exports","ResourceQueue","constructor","paused","asyncQueue","Boolean","_asyncQueue","getLastScript","head","tail","isScript","prev","_moreScripts","found","_notify","_listener","setListener","listener","push","request","onLoad","onError","keepLast","element","localName","Promise","resolve","q","item","err","fired","data","check","promise","then","next","finished","notifyItem","catch","resume"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * Queue for all the resources to be download except async scripts.\n * Async scripts have their own queue AsyncResourceQueue.\n */\nmodule.exports = class ResourceQueue {\n  constructor({ paused, asyncQueue } = {}) {\n    this.paused = Boolean(paused);\n    this._asyncQueue = asyncQueue;\n  }\n\n  getLastScript() {\n    let head = this.tail;\n\n    while (head) {\n      if (head.isScript) {\n        return head;\n      }\n      head = head.prev;\n    }\n\n    return null;\n  }\n\n  _moreScripts() {\n    let found = false;\n\n    let head = this.tail;\n    while (head && !found) {\n      found = head.isScript;\n      head = head.prev;\n    }\n\n    return found;\n  }\n\n  _notify() {\n    if (this._listener) {\n      this._listener();\n    }\n  }\n\n  setListener(listener) {\n    this._listener = listener;\n  }\n\n  push(request, onLoad, onError, keepLast, element) {\n    const isScript = element ? element.localName === \"script\" : false;\n\n    if (!request) {\n      if (isScript && !this._moreScripts()) {\n        return onLoad();\n      }\n\n      request = new Promise(resolve => resolve());\n    }\n    const q = this;\n    const item = {\n      isScript,\n      err: null,\n      element,\n      fired: false,\n      data: null,\n      keepLast,\n      prev: q.tail,\n      check() {\n        if (!q.paused && !this.prev && this.fired) {\n          let promise;\n\n          if (this.err && onError) {\n            promise = onError(this.err);\n          }\n\n          if (!this.err && onLoad) {\n            promise = onLoad(this.data);\n          }\n\n          Promise.resolve(promise)\n            .then(() => {\n              if (this.next) {\n                this.next.prev = null;\n                this.next.check();\n              } else { // q.tail===this\n                q.tail = null;\n                q._notify();\n              }\n\n              this.finished = true;\n\n              if (q._asyncQueue) {\n                q._asyncQueue.notifyItem(this);\n              }\n            });\n        }\n      }\n    };\n    if (q.tail) {\n      if (q.tail.keepLast) {\n        // if the tail is the load event in document and we receive a new element to load\n        // we should add this new request before the load event.\n        if (q.tail.prev) {\n          q.tail.prev.next = item;\n        }\n        item.prev = q.tail.prev;\n        q.tail.prev = item;\n        item.next = q.tail;\n      } else {\n        q.tail.next = item;\n        q.tail = item;\n      }\n    } else {\n      q.tail = item;\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check();\n      })\n      .catch(err => {\n        item.fired = true;\n        item.err = err;\n        item.check();\n      });\n  }\n\n  resume() {\n    if (!this.paused) {\n      return;\n    }\n    this.paused = false;\n\n    let head = this.tail;\n    while (head && head.prev) {\n      head = head.prev;\n    }\n    if (head) {\n      head.check();\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}