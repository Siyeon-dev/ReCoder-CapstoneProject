{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\n\nconst {\n  parseURL\n} = require(\"whatwg-url\");\n\nconst dataURLFromRecord = require(\"data-urls\").fromURLRecord;\n\nconst request = require(\"request-promise-native\");\n\nconst wrapCookieJarForRequest = require(\"../../living/helpers/wrap-cookie-jar-for-request\");\n\nconst packageVersion = require(\"../../../../package.json\").version;\n\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\nmodule.exports = class ResourceLoader {\n  constructor({\n    strictSSL = true,\n    proxy = undefined,\n    userAgent = `Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 ` + `(KHTML, like Gecko) jsdom/${packageVersion}`\n  } = {}) {\n    this._strictSSL = strictSSL;\n    this._proxy = proxy;\n    this._userAgent = userAgent;\n  }\n\n  _readDataURL(urlRecord) {\n    const dataURL = dataURLFromRecord(urlRecord);\n    let timeoutId;\n    const promise = new Promise(resolve => {\n      timeoutId = setTimeout(resolve, 0, dataURL.body);\n    });\n\n    promise.abort = () => {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    };\n\n    return promise;\n  }\n\n  _readFile(filePath) {\n    let readableStream;\n    let abort; // Native Promises doesn't have an \"abort\" method.\n\n    /*\n     * Creating a promise for two reason:\n     *   1. fetch always return a promise.\n     *   2. We need to add an abort handler.\n    */\n\n    const promise = new Promise((resolve, reject) => {\n      readableStream = fs.createReadStream(filePath);\n      let data = Buffer.alloc(0);\n      abort = reject;\n      readableStream.on(\"error\", reject);\n      readableStream.on(\"data\", chunk => {\n        data = Buffer.concat([data, chunk]);\n      });\n      readableStream.on(\"end\", () => {\n        resolve(data);\n      });\n    });\n\n    promise.abort = () => {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      abort(error);\n    };\n\n    return promise;\n  }\n\n  _getRequestOptions({\n    cookieJar,\n    referrer,\n    accept = \"*/*\"\n  }) {\n    const requestOptions = {\n      encoding: null,\n      gzip: true,\n      jar: wrapCookieJarForRequest(cookieJar),\n      strictSSL: this._strictSSL,\n      proxy: this._proxy,\n      forever: true,\n      headers: {\n        \"User-Agent\": this._userAgent,\n        \"Accept-Language\": \"en\",\n        Accept: accept\n      }\n    };\n\n    if (referrer && !IS_BROWSER) {\n      requestOptions.headers.referer = referrer;\n    }\n\n    return requestOptions;\n  }\n\n  fetch(urlString, options = {}) {\n    const url = parseURL(urlString);\n\n    if (!url) {\n      return Promise.reject(new Error(`Tried to fetch invalid URL ${urlString}`));\n    }\n\n    switch (url.scheme) {\n      case \"data\":\n        {\n          return this._readDataURL(url);\n        }\n\n      case \"http\":\n      case \"https\":\n        {\n          const requestOptions = this._getRequestOptions(options);\n\n          return request(urlString, requestOptions);\n        }\n\n      case \"file\":\n        {\n          // TODO: Improve the URL => file algorithm. See https://github.com/jsdom/jsdom/pull/2279#discussion_r199977987\n          const filePath = urlString.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, \"$1:/\").replace(/%20/g, \" \");\n          return this._readFile(filePath);\n        }\n\n      default:\n        {\n          return Promise.reject(new Error(`Tried to fetch URL ${urlString} with invalid scheme ${url.scheme}`));\n        }\n    }\n  }\n\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/jsdom/lib/jsdom/browser/resources/resource-loader.js"],"names":["fs","require","parseURL","dataURLFromRecord","fromURLRecord","request","wrapCookieJarForRequest","packageVersion","version","IS_BROWSER","Object","prototype","toString","call","process","module","exports","ResourceLoader","constructor","strictSSL","proxy","undefined","userAgent","platform","_strictSSL","_proxy","_userAgent","_readDataURL","urlRecord","dataURL","timeoutId","promise","Promise","resolve","setTimeout","body","abort","clearTimeout","_readFile","filePath","readableStream","reject","createReadStream","data","Buffer","alloc","on","chunk","concat","destroy","error","Error","isAbortError","_getRequestOptions","cookieJar","referrer","accept","requestOptions","encoding","gzip","jar","forever","headers","Accept","referer","fetch","urlString","options","url","scheme","replace"],"mappings":"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","sourcesContent":["\"use strict\";\nconst fs = require(\"fs\");\nconst { parseURL } = require(\"whatwg-url\");\nconst dataURLFromRecord = require(\"data-urls\").fromURLRecord;\nconst request = require(\"request-promise-native\");\nconst wrapCookieJarForRequest = require(\"../../living/helpers/wrap-cookie-jar-for-request\");\nconst packageVersion = require(\"../../../../package.json\").version;\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nmodule.exports = class ResourceLoader {\n  constructor({\n    strictSSL = true,\n    proxy = undefined,\n    userAgent = `Mozilla/5.0 (${process.platform || \"unknown OS\"}) AppleWebKit/537.36 ` +\n                `(KHTML, like Gecko) jsdom/${packageVersion}`\n  } = {}) {\n    this._strictSSL = strictSSL;\n    this._proxy = proxy;\n    this._userAgent = userAgent;\n  }\n\n  _readDataURL(urlRecord) {\n    const dataURL = dataURLFromRecord(urlRecord);\n    let timeoutId;\n    const promise = new Promise(resolve => {\n      timeoutId = setTimeout(resolve, 0, dataURL.body);\n    });\n    promise.abort = () => {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    };\n    return promise;\n  }\n\n  _readFile(filePath) {\n    let readableStream;\n    let abort; // Native Promises doesn't have an \"abort\" method.\n\n    /*\n     * Creating a promise for two reason:\n     *   1. fetch always return a promise.\n     *   2. We need to add an abort handler.\n    */\n    const promise = new Promise((resolve, reject) => {\n      readableStream = fs.createReadStream(filePath);\n      let data = Buffer.alloc(0);\n\n      abort = reject;\n\n      readableStream.on(\"error\", reject);\n\n      readableStream.on(\"data\", chunk => {\n        data = Buffer.concat([data, chunk]);\n      });\n\n      readableStream.on(\"end\", () => {\n        resolve(data);\n      });\n    });\n\n    promise.abort = () => {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      abort(error);\n    };\n\n    return promise;\n  }\n\n  _getRequestOptions({ cookieJar, referrer, accept = \"*/*\" }) {\n    const requestOptions = {\n      encoding: null,\n      gzip: true,\n      jar: wrapCookieJarForRequest(cookieJar),\n      strictSSL: this._strictSSL,\n      proxy: this._proxy,\n      forever: true,\n      headers: {\n        \"User-Agent\": this._userAgent,\n        \"Accept-Language\": \"en\",\n        Accept: accept\n      }\n    };\n\n    if (referrer && !IS_BROWSER) {\n      requestOptions.headers.referer = referrer;\n    }\n\n    return requestOptions;\n  }\n\n  fetch(urlString, options = {}) {\n    const url = parseURL(urlString);\n\n    if (!url) {\n      return Promise.reject(new Error(`Tried to fetch invalid URL ${urlString}`));\n    }\n\n    switch (url.scheme) {\n      case \"data\": {\n        return this._readDataURL(url);\n      }\n\n      case \"http\":\n      case \"https\": {\n        const requestOptions = this._getRequestOptions(options);\n        return request(urlString, requestOptions);\n      }\n\n      case \"file\": {\n        // TODO: Improve the URL => file algorithm. See https://github.com/jsdom/jsdom/pull/2279#discussion_r199977987\n        const filePath = urlString\n          .replace(/^file:\\/\\//, \"\")\n          .replace(/^\\/([a-z]):\\//i, \"$1:/\")\n          .replace(/%20/g, \" \");\n\n        return this._readFile(filePath);\n      }\n\n      default: {\n        return Promise.reject(new Error(`Tried to fetch URL ${urlString} with invalid scheme ${url.scheme}`));\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}