{"ast":null,"code":"/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\n  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*global exports:true, require:true, global:true*/\n(function () {\n  'use strict';\n\n  var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;\n  estraverse = require('estraverse');\n  esutils = require('esutils');\n  Syntax = estraverse.Syntax; // Generation is done by generateExpression.\n\n  function isExpression(node) {\n    return CodeGenerator.Expression.hasOwnProperty(node.type);\n  } // Generation is done by generateStatement.\n\n\n  function isStatement(node) {\n    return CodeGenerator.Statement.hasOwnProperty(node.type);\n  }\n\n  Precedence = {\n    Sequence: 0,\n    Yield: 1,\n    Assignment: 1,\n    Conditional: 2,\n    ArrowFunction: 2,\n    LogicalOR: 3,\n    LogicalAND: 4,\n    BitwiseOR: 5,\n    BitwiseXOR: 6,\n    BitwiseAND: 7,\n    Equality: 8,\n    Relational: 9,\n    BitwiseSHIFT: 10,\n    Additive: 11,\n    Multiplicative: 12,\n    Exponentiation: 13,\n    Await: 14,\n    Unary: 14,\n    Postfix: 15,\n    Call: 16,\n    New: 17,\n    TaggedTemplate: 18,\n    Member: 19,\n    Primary: 20\n  };\n  BinaryPrecedence = {\n    '||': Precedence.LogicalOR,\n    '&&': Precedence.LogicalAND,\n    '|': Precedence.BitwiseOR,\n    '^': Precedence.BitwiseXOR,\n    '&': Precedence.BitwiseAND,\n    '==': Precedence.Equality,\n    '!=': Precedence.Equality,\n    '===': Precedence.Equality,\n    '!==': Precedence.Equality,\n    'is': Precedence.Equality,\n    'isnt': Precedence.Equality,\n    '<': Precedence.Relational,\n    '>': Precedence.Relational,\n    '<=': Precedence.Relational,\n    '>=': Precedence.Relational,\n    'in': Precedence.Relational,\n    'instanceof': Precedence.Relational,\n    '<<': Precedence.BitwiseSHIFT,\n    '>>': Precedence.BitwiseSHIFT,\n    '>>>': Precedence.BitwiseSHIFT,\n    '+': Precedence.Additive,\n    '-': Precedence.Additive,\n    '*': Precedence.Multiplicative,\n    '%': Precedence.Multiplicative,\n    '/': Precedence.Multiplicative,\n    '**': Precedence.Exponentiation\n  }; //Flags\n\n  var F_ALLOW_IN = 1,\n      F_ALLOW_CALL = 1 << 1,\n      F_ALLOW_UNPARATH_NEW = 1 << 2,\n      F_FUNC_BODY = 1 << 3,\n      F_DIRECTIVE_CTX = 1 << 4,\n      F_SEMICOLON_OPT = 1 << 5; //Expression flag sets\n  //NOTE: Flag order:\n  // F_ALLOW_IN\n  // F_ALLOW_CALL\n  // F_ALLOW_UNPARATH_NEW\n\n  var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n      E_TTF = F_ALLOW_IN | F_ALLOW_CALL,\n      E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n      E_TFF = F_ALLOW_IN,\n      E_FFT = F_ALLOW_UNPARATH_NEW,\n      E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW; //Statement flag sets\n  //NOTE: Flag order:\n  // F_ALLOW_IN\n  // F_FUNC_BODY\n  // F_DIRECTIVE_CTX\n  // F_SEMICOLON_OPT\n\n  var S_TFFF = F_ALLOW_IN,\n      S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,\n      S_FFFF = 0x00,\n      S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,\n      S_TTFF = F_ALLOW_IN | F_FUNC_BODY;\n\n  function getDefaultOptions() {\n    // default options\n    return {\n      indent: null,\n      base: null,\n      parse: null,\n      comment: false,\n      format: {\n        indent: {\n          style: '    ',\n          base: 0,\n          adjustMultilineComment: false\n        },\n        newline: '\\n',\n        space: ' ',\n        json: false,\n        renumber: false,\n        hexadecimal: false,\n        quotes: 'single',\n        escapeless: false,\n        compact: false,\n        parentheses: true,\n        semicolons: true,\n        safeConcatenation: false,\n        preserveBlankLines: false\n      },\n      moz: {\n        comprehensionExpressionStartsWithAssignment: false,\n        starlessGenerator: false\n      },\n      sourceMap: null,\n      sourceMapRoot: null,\n      sourceMapWithCode: false,\n      directive: false,\n      raw: true,\n      verbatim: null,\n      sourceCode: null\n    };\n  }\n\n  function stringRepeat(str, num) {\n    var result = '';\n\n    for (num |= 0; num > 0; num >>>= 1, str += str) {\n      if (num & 1) {\n        result += str;\n      }\n    }\n\n    return result;\n  }\n\n  function hasLineTerminator(str) {\n    return /[\\r\\n]/g.test(str);\n  }\n\n  function endsWithLineTerminator(str) {\n    var len = str.length;\n    return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));\n  }\n\n  function merge(target, override) {\n    var key;\n\n    for (key in override) {\n      if (override.hasOwnProperty(key)) {\n        target[key] = override[key];\n      }\n    }\n\n    return target;\n  }\n\n  function updateDeeply(target, override) {\n    var key, val;\n\n    function isHashObject(target) {\n      return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);\n    }\n\n    for (key in override) {\n      if (override.hasOwnProperty(key)) {\n        val = override[key];\n\n        if (isHashObject(val)) {\n          if (isHashObject(target[key])) {\n            updateDeeply(target[key], val);\n          } else {\n            target[key] = updateDeeply({}, val);\n          }\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n\n    return target;\n  }\n\n  function generateNumber(value) {\n    var result, point, temp, exponent, pos;\n\n    if (value !== value) {\n      throw new Error('Numeric literal whose value is NaN');\n    }\n\n    if (value < 0 || value === 0 && 1 / value < 0) {\n      throw new Error('Numeric literal whose value is negative');\n    }\n\n    if (value === 1 / 0) {\n      return json ? 'null' : renumber ? '1e400' : '1e+400';\n    }\n\n    result = '' + value;\n\n    if (!renumber || result.length < 3) {\n      return result;\n    }\n\n    point = result.indexOf('.');\n\n    if (!json && result.charCodeAt(0) === 0x30\n    /* 0 */\n    && point === 1) {\n      point = 0;\n      result = result.slice(1);\n    }\n\n    temp = result;\n    result = result.replace('e+', 'e');\n    exponent = 0;\n\n    if ((pos = temp.indexOf('e')) > 0) {\n      exponent = +temp.slice(pos + 1);\n      temp = temp.slice(0, pos);\n    }\n\n    if (point >= 0) {\n      exponent -= temp.length - point - 1;\n      temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';\n    }\n\n    pos = 0;\n\n    while (temp.charCodeAt(temp.length + pos - 1) === 0x30\n    /* 0 */\n    ) {\n      --pos;\n    }\n\n    if (pos !== 0) {\n      exponent -= pos;\n      temp = temp.slice(0, pos);\n    }\n\n    if (exponent !== 0) {\n      temp += 'e' + exponent;\n    }\n\n    if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length) && +temp === value) {\n      result = temp;\n    }\n\n    return result;\n  } // Generate valid RegExp expression.\n  // This function is based on https://github.com/Constellation/iv Engine\n\n\n  function escapeRegExpCharacter(ch, previousIsBackslash) {\n    // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\n    if ((ch & ~1) === 0x2028) {\n      return (previousIsBackslash ? 'u' : '\\\\u') + (ch === 0x2028 ? '2028' : '2029');\n    } else if (ch === 10 || ch === 13) {\n      // \\n, \\r\n      return (previousIsBackslash ? '' : '\\\\') + (ch === 10 ? 'n' : 'r');\n    }\n\n    return String.fromCharCode(ch);\n  }\n\n  function generateRegExp(reg) {\n    var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n    result = reg.toString();\n\n    if (reg.source) {\n      // extract flag from toString result\n      match = result.match(/\\/([^/]*)$/);\n\n      if (!match) {\n        return result;\n      }\n\n      flags = match[1];\n      result = '';\n      characterInBrack = false;\n      previousIsBackslash = false;\n\n      for (i = 0, iz = reg.source.length; i < iz; ++i) {\n        ch = reg.source.charCodeAt(i);\n\n        if (!previousIsBackslash) {\n          if (characterInBrack) {\n            if (ch === 93) {\n              // ]\n              characterInBrack = false;\n            }\n          } else {\n            if (ch === 47) {\n              // /\n              result += '\\\\';\n            } else if (ch === 91) {\n              // [\n              characterInBrack = true;\n            }\n          }\n\n          result += escapeRegExpCharacter(ch, previousIsBackslash);\n          previousIsBackslash = ch === 92; // \\\n        } else {\n          // if new RegExp(\"\\\\\\n') is provided, create /\\n/\n          result += escapeRegExpCharacter(ch, previousIsBackslash); // prevent like /\\\\[/]/\n\n          previousIsBackslash = false;\n        }\n      }\n\n      return '/' + result + '/' + flags;\n    }\n\n    return result;\n  }\n\n  function escapeAllowedCharacter(code, next) {\n    var hex;\n\n    if (code === 0x08\n    /* \\b */\n    ) {\n        return '\\\\b';\n      }\n\n    if (code === 0x0C\n    /* \\f */\n    ) {\n        return '\\\\f';\n      }\n\n    if (code === 0x09\n    /* \\t */\n    ) {\n        return '\\\\t';\n      }\n\n    hex = code.toString(16).toUpperCase();\n\n    if (json || code > 0xFF) {\n      return '\\\\u' + '0000'.slice(hex.length) + hex;\n    } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {\n      return '\\\\0';\n    } else if (code === 0x000B\n    /* \\v */\n    ) {\n        // '\\v'\n        return '\\\\x0B';\n      } else {\n      return '\\\\x' + '00'.slice(hex.length) + hex;\n    }\n  }\n\n  function escapeDisallowedCharacter(code) {\n    if (code === 0x5C\n    /* \\ */\n    ) {\n        return '\\\\\\\\';\n      }\n\n    if (code === 0x0A\n    /* \\n */\n    ) {\n        return '\\\\n';\n      }\n\n    if (code === 0x0D\n    /* \\r */\n    ) {\n        return '\\\\r';\n      }\n\n    if (code === 0x2028) {\n      return '\\\\u2028';\n    }\n\n    if (code === 0x2029) {\n      return '\\\\u2029';\n    }\n\n    throw new Error('Incorrectly classified character');\n  }\n\n  function escapeDirective(str) {\n    var i, iz, code, quote;\n    quote = quotes === 'double' ? '\"' : '\\'';\n\n    for (i = 0, iz = str.length; i < iz; ++i) {\n      code = str.charCodeAt(i);\n\n      if (code === 0x27\n      /* ' */\n      ) {\n          quote = '\"';\n          break;\n        } else if (code === 0x22\n      /* \" */\n      ) {\n          quote = '\\'';\n          break;\n        } else if (code === 0x5C\n      /* \\ */\n      ) {\n          ++i;\n        }\n    }\n\n    return quote + str + quote;\n  }\n\n  function escapeString(str) {\n    var result = '',\n        i,\n        len,\n        code,\n        singleQuotes = 0,\n        doubleQuotes = 0,\n        single,\n        quote;\n\n    for (i = 0, len = str.length; i < len; ++i) {\n      code = str.charCodeAt(i);\n\n      if (code === 0x27\n      /* ' */\n      ) {\n          ++singleQuotes;\n        } else if (code === 0x22\n      /* \" */\n      ) {\n          ++doubleQuotes;\n        } else if (code === 0x2F\n      /* / */\n      && json) {\n        result += '\\\\';\n      } else if (esutils.code.isLineTerminator(code) || code === 0x5C\n      /* \\ */\n      ) {\n          result += escapeDisallowedCharacter(code);\n          continue;\n        } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20\n      /* SP */\n      || !json && !escapeless && (code < 0x20\n      /* SP */\n      || code > 0x7E\n      /* ~ */\n      ))) {\n        result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));\n        continue;\n      }\n\n      result += String.fromCharCode(code);\n    }\n\n    single = !(quotes === 'double' || quotes === 'auto' && doubleQuotes < singleQuotes);\n    quote = single ? '\\'' : '\"';\n\n    if (!(single ? singleQuotes : doubleQuotes)) {\n      return quote + result + quote;\n    }\n\n    str = result;\n    result = quote;\n\n    for (i = 0, len = str.length; i < len; ++i) {\n      code = str.charCodeAt(i);\n\n      if (code === 0x27\n      /* ' */\n      && single || code === 0x22\n      /* \" */\n      && !single) {\n        result += '\\\\';\n      }\n\n      result += String.fromCharCode(code);\n    }\n\n    return result + quote;\n  }\n  /**\n   * flatten an array to a string, where the array can contain\n   * either strings or nested arrays\n   */\n\n\n  function flattenToString(arr) {\n    var i,\n        iz,\n        elem,\n        result = '';\n\n    for (i = 0, iz = arr.length; i < iz; ++i) {\n      elem = arr[i];\n      result += Array.isArray(elem) ? flattenToString(elem) : elem;\n    }\n\n    return result;\n  }\n  /**\n   * convert generated to a SourceNode when source maps are enabled.\n   */\n\n\n  function toSourceNodeWhenNeeded(generated, node) {\n    if (!sourceMap) {\n      // with no source maps, generated is either an\n      // array or a string.  if an array, flatten it.\n      // if a string, just return it\n      if (Array.isArray(generated)) {\n        return flattenToString(generated);\n      } else {\n        return generated;\n      }\n    }\n\n    if (node == null) {\n      if (generated instanceof SourceNode) {\n        return generated;\n      } else {\n        node = {};\n      }\n    }\n\n    if (node.loc == null) {\n      return new SourceNode(null, null, sourceMap, generated, node.name || null);\n    }\n\n    return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);\n  }\n\n  function noEmptySpace() {\n    return space ? space : ' ';\n  }\n\n  function join(left, right) {\n    var leftSource, rightSource, leftCharCode, rightCharCode;\n    leftSource = toSourceNodeWhenNeeded(left).toString();\n\n    if (leftSource.length === 0) {\n      return [right];\n    }\n\n    rightSource = toSourceNodeWhenNeeded(right).toString();\n\n    if (rightSource.length === 0) {\n      return [left];\n    }\n\n    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n    rightCharCode = rightSource.charCodeAt(0);\n\n    if ((leftCharCode === 0x2B\n    /* + */\n    || leftCharCode === 0x2D\n    /* - */\n    ) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 0x2F\n    /* / */\n    && rightCharCode === 0x69\n    /* i */\n    ) {\n        // infix word operators all start with `i`\n        return [left, noEmptySpace(), right];\n      } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {\n      return [left, right];\n    }\n\n    return [left, space, right];\n  }\n\n  function addIndent(stmt) {\n    return [base, stmt];\n  }\n\n  function withIndent(fn) {\n    var previousBase;\n    previousBase = base;\n    base += indent;\n    fn(base);\n    base = previousBase;\n  }\n\n  function calculateSpaces(str) {\n    var i;\n\n    for (i = str.length - 1; i >= 0; --i) {\n      if (esutils.code.isLineTerminator(str.charCodeAt(i))) {\n        break;\n      }\n    }\n\n    return str.length - 1 - i;\n  }\n\n  function adjustMultilineComment(value, specialBase) {\n    var array, i, len, line, j, spaces, previousBase, sn;\n    array = value.split(/\\r\\n|[\\r\\n]/);\n    spaces = Number.MAX_VALUE; // first line doesn't have indentation\n\n    for (i = 1, len = array.length; i < len; ++i) {\n      line = array[i];\n      j = 0;\n\n      while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {\n        ++j;\n      }\n\n      if (spaces > j) {\n        spaces = j;\n      }\n    }\n\n    if (typeof specialBase !== 'undefined') {\n      // pattern like\n      // {\n      //   var t = 20;  /*\n      //                 * this is comment\n      //                 */\n      // }\n      previousBase = base;\n\n      if (array[1][spaces] === '*') {\n        specialBase += ' ';\n      }\n\n      base = specialBase;\n    } else {\n      if (spaces & 1) {\n        // /*\n        //  *\n        //  */\n        // If spaces are odd number, above pattern is considered.\n        // We waste 1 space.\n        --spaces;\n      }\n\n      previousBase = base;\n    }\n\n    for (i = 1, len = array.length; i < len; ++i) {\n      sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));\n      array[i] = sourceMap ? sn.join('') : sn;\n    }\n\n    base = previousBase;\n    return array.join('\\n');\n  }\n\n  function generateComment(comment, specialBase) {\n    if (comment.type === 'Line') {\n      if (endsWithLineTerminator(comment.value)) {\n        return '//' + comment.value;\n      } else {\n        // Always use LineTerminator\n        var result = '//' + comment.value;\n\n        if (!preserveBlankLines) {\n          result += '\\n';\n        }\n\n        return result;\n      }\n    }\n\n    if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\n      return adjustMultilineComment('/*' + comment.value + '*/', specialBase);\n    }\n\n    return '/*' + comment.value + '*/';\n  }\n\n  function addComments(stmt, result) {\n    var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range, prevRange, prefix, infix, suffix, count;\n\n    if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n      save = result;\n\n      if (preserveBlankLines) {\n        comment = stmt.leadingComments[0];\n        result = [];\n        extRange = comment.extendedRange;\n        range = comment.range;\n        prefix = sourceCode.substring(extRange[0], range[0]);\n        count = (prefix.match(/\\n/g) || []).length;\n\n        if (count > 0) {\n          result.push(stringRepeat('\\n', count));\n          result.push(addIndent(generateComment(comment)));\n        } else {\n          result.push(prefix);\n          result.push(generateComment(comment));\n        }\n\n        prevRange = range;\n\n        for (i = 1, len = stmt.leadingComments.length; i < len; i++) {\n          comment = stmt.leadingComments[i];\n          range = comment.range;\n          infix = sourceCode.substring(prevRange[1], range[0]);\n          count = (infix.match(/\\n/g) || []).length;\n          result.push(stringRepeat('\\n', count));\n          result.push(addIndent(generateComment(comment)));\n          prevRange = range;\n        }\n\n        suffix = sourceCode.substring(range[1], extRange[1]);\n        count = (suffix.match(/\\n/g) || []).length;\n        result.push(stringRepeat('\\n', count));\n      } else {\n        comment = stmt.leadingComments[0];\n        result = [];\n\n        if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\n          result.push('\\n');\n        }\n\n        result.push(generateComment(comment));\n\n        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n          result.push('\\n');\n        }\n\n        for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {\n          comment = stmt.leadingComments[i];\n          fragment = [generateComment(comment)];\n\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            fragment.push('\\n');\n          }\n\n          result.push(addIndent(fragment));\n        }\n      }\n\n      result.push(addIndent(save));\n    }\n\n    if (stmt.trailingComments) {\n      if (preserveBlankLines) {\n        comment = stmt.trailingComments[0];\n        extRange = comment.extendedRange;\n        range = comment.range;\n        prefix = sourceCode.substring(extRange[0], range[0]);\n        count = (prefix.match(/\\n/g) || []).length;\n\n        if (count > 0) {\n          result.push(stringRepeat('\\n', count));\n          result.push(addIndent(generateComment(comment)));\n        } else {\n          result.push(prefix);\n          result.push(generateComment(comment));\n        }\n      } else {\n        tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n        specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));\n\n        for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {\n          comment = stmt.trailingComments[i];\n\n          if (tailingToStatement) {\n            // We assume target like following script\n            //\n            // var t = 20;  /**\n            //               * This is comment of t\n            //               */\n            if (i === 0) {\n              // first case\n              result = [result, indent];\n            } else {\n              result = [result, specialBase];\n            }\n\n            result.push(generateComment(comment, specialBase));\n          } else {\n            result = [result, addIndent(generateComment(comment))];\n          }\n\n          if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result = [result, '\\n'];\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function generateBlankLines(start, end, result) {\n    var j,\n        newlineCount = 0;\n\n    for (j = start; j < end; j++) {\n      if (sourceCode[j] === '\\n') {\n        newlineCount++;\n      }\n    }\n\n    for (j = 1; j < newlineCount; j++) {\n      result.push(newline);\n    }\n  }\n\n  function parenthesize(text, current, should) {\n    if (current < should) {\n      return ['(', text, ')'];\n    }\n\n    return text;\n  }\n\n  function generateVerbatimString(string) {\n    var i, iz, result;\n    result = string.split(/\\r\\n|\\n/);\n\n    for (i = 1, iz = result.length; i < iz; i++) {\n      result[i] = newline + base + result[i];\n    }\n\n    return result;\n  }\n\n  function generateVerbatim(expr, precedence) {\n    var verbatim, result, prec;\n    verbatim = expr[extra.verbatim];\n\n    if (typeof verbatim === 'string') {\n      result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);\n    } else {\n      // verbatim is object\n      result = generateVerbatimString(verbatim.content);\n      prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;\n      result = parenthesize(result, prec, precedence);\n    }\n\n    return toSourceNodeWhenNeeded(result, expr);\n  }\n\n  function CodeGenerator() {} // Helpers.\n\n\n  CodeGenerator.prototype.maybeBlock = function (stmt, flags) {\n    var result,\n        noLeadingComment,\n        that = this;\n    noLeadingComment = !extra.comment || !stmt.leadingComments;\n\n    if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n      return [space, this.generateStatement(stmt, flags)];\n    }\n\n    if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n      return ';';\n    }\n\n    withIndent(function () {\n      result = [newline, addIndent(that.generateStatement(stmt, flags))];\n    });\n    return result;\n  };\n\n  CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {\n    var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n\n    if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\n      return [result, space];\n    }\n\n    if (ends) {\n      return [result, base];\n    }\n\n    return [result, newline, base];\n  };\n\n  function generateIdentifier(node) {\n    return toSourceNodeWhenNeeded(node.name, node);\n  }\n\n  function generateAsyncPrefix(node, spaceRequired) {\n    return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';\n  }\n\n  function generateStarSuffix(node) {\n    var isGenerator = node.generator && !extra.moz.starlessGenerator;\n    return isGenerator ? '*' + space : '';\n  }\n\n  function generateMethodPrefix(prop) {\n    var func = prop.value,\n        prefix = '';\n\n    if (func.async) {\n      prefix += generateAsyncPrefix(func, !prop.computed);\n    }\n\n    if (func.generator) {\n      // avoid space before method name\n      prefix += generateStarSuffix(func) ? '*' : '';\n    }\n\n    return prefix;\n  }\n\n  CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {\n    if (node.type === Syntax.Identifier) {\n      return generateIdentifier(node);\n    }\n\n    return this.generateExpression(node, precedence, flags);\n  };\n\n  CodeGenerator.prototype.generateFunctionParams = function (node) {\n    var i, iz, result, hasDefault;\n    hasDefault = false;\n\n    if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {\n      // arg => { } case\n      result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];\n    } else {\n      result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];\n      result.push('(');\n\n      if (node.defaults) {\n        hasDefault = true;\n      }\n\n      for (i = 0, iz = node.params.length; i < iz; ++i) {\n        if (hasDefault && node.defaults[i]) {\n          // Handle default values.\n          result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));\n        } else {\n          result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));\n        }\n\n        if (i + 1 < iz) {\n          result.push(',' + space);\n        }\n      }\n\n      if (node.rest) {\n        if (node.params.length) {\n          result.push(',' + space);\n        }\n\n        result.push('...');\n        result.push(generateIdentifier(node.rest));\n      }\n\n      result.push(')');\n    }\n\n    return result;\n  };\n\n  CodeGenerator.prototype.generateFunctionBody = function (node) {\n    var result, expr;\n    result = this.generateFunctionParams(node);\n\n    if (node.type === Syntax.ArrowFunctionExpression) {\n      result.push(space);\n      result.push('=>');\n    }\n\n    if (node.expression) {\n      result.push(space);\n      expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);\n\n      if (expr.toString().charAt(0) === '{') {\n        expr = ['(', expr, ')'];\n      }\n\n      result.push(expr);\n    } else {\n      result.push(this.maybeBlock(node.body, S_TTFF));\n    }\n\n    return result;\n  };\n\n  CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {\n    var result = ['for' + (stmt.await ? noEmptySpace() + 'await' : '') + space + '('],\n        that = this;\n    withIndent(function () {\n      if (stmt.left.type === Syntax.VariableDeclaration) {\n        withIndent(function () {\n          result.push(stmt.left.kind + noEmptySpace());\n          result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));\n        });\n      } else {\n        result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));\n      }\n\n      result = join(result, operator);\n      result = [join(result, that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)), ')'];\n    });\n    result.push(this.maybeBlock(stmt.body, flags));\n    return result;\n  };\n\n  CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {\n    var result = [];\n\n    if (computed) {\n      result.push('[');\n    }\n\n    result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));\n\n    if (computed) {\n      result.push(']');\n    }\n\n    return result;\n  };\n\n  CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {\n    if (Precedence.Assignment < precedence) {\n      flags |= F_ALLOW_IN;\n    }\n\n    return parenthesize([this.generateExpression(left, Precedence.Call, flags), space + operator + space, this.generateExpression(right, Precedence.Assignment, flags)], Precedence.Assignment, precedence);\n  };\n\n  CodeGenerator.prototype.semicolon = function (flags) {\n    if (!semicolons && flags & F_SEMICOLON_OPT) {\n      return '';\n    }\n\n    return ';';\n  }; // Statements.\n\n\n  CodeGenerator.Statement = {\n    BlockStatement: function (stmt, flags) {\n      var range,\n          content,\n          result = ['{', newline],\n          that = this;\n      withIndent(function () {\n        // handle functions without any code\n        if (stmt.body.length === 0 && preserveBlankLines) {\n          range = stmt.range;\n\n          if (range[1] - range[0] > 2) {\n            content = sourceCode.substring(range[0] + 1, range[1] - 1);\n\n            if (content[0] === '\\n') {\n              result = ['{'];\n            }\n\n            result.push(content);\n          }\n        }\n\n        var i, iz, fragment, bodyFlags;\n        bodyFlags = S_TFFF;\n\n        if (flags & F_FUNC_BODY) {\n          bodyFlags |= F_DIRECTIVE_CTX;\n        }\n\n        for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n          if (preserveBlankLines) {\n            // handle spaces before the first line\n            if (i === 0) {\n              if (stmt.body[0].leadingComments) {\n                range = stmt.body[0].leadingComments[0].extendedRange;\n                content = sourceCode.substring(range[0], range[1]);\n\n                if (content[0] === '\\n') {\n                  result = ['{'];\n                }\n              }\n\n              if (!stmt.body[0].leadingComments) {\n                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);\n              }\n            } // handle spaces between lines\n\n\n            if (i > 0) {\n              if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n              }\n            }\n          }\n\n          if (i === iz - 1) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n\n          if (stmt.body[i].leadingComments && preserveBlankLines) {\n            fragment = that.generateStatement(stmt.body[i], bodyFlags);\n          } else {\n            fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));\n          }\n\n          result.push(fragment);\n\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            if (preserveBlankLines && i < iz - 1) {\n              // don't add a new line if there are leading coments\n              // in the next statement\n              if (!stmt.body[i + 1].leadingComments) {\n                result.push(newline);\n              }\n            } else {\n              result.push(newline);\n            }\n          }\n\n          if (preserveBlankLines) {\n            // handle spaces after the last line\n            if (i === iz - 1) {\n              if (!stmt.body[i].trailingComments) {\n                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n              }\n            }\n          }\n        }\n      });\n      result.push(addIndent('}'));\n      return result;\n    },\n    BreakStatement: function (stmt, flags) {\n      if (stmt.label) {\n        return 'break ' + stmt.label.name + this.semicolon(flags);\n      }\n\n      return 'break' + this.semicolon(flags);\n    },\n    ContinueStatement: function (stmt, flags) {\n      if (stmt.label) {\n        return 'continue ' + stmt.label.name + this.semicolon(flags);\n      }\n\n      return 'continue' + this.semicolon(flags);\n    },\n    ClassBody: function (stmt, flags) {\n      var result = ['{', newline],\n          that = this;\n      withIndent(function (indent) {\n        var i, iz;\n\n        for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n          result.push(indent);\n          result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));\n\n          if (i + 1 < iz) {\n            result.push(newline);\n          }\n        }\n      });\n\n      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n\n      result.push(base);\n      result.push('}');\n      return result;\n    },\n    ClassDeclaration: function (stmt, flags) {\n      var result, fragment;\n      result = ['class'];\n\n      if (stmt.id) {\n        result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));\n      }\n\n      if (stmt.superClass) {\n        fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));\n        result = join(result, fragment);\n      }\n\n      result.push(space);\n      result.push(this.generateStatement(stmt.body, S_TFFT));\n      return result;\n    },\n    DirectiveStatement: function (stmt, flags) {\n      if (extra.raw && stmt.raw) {\n        return stmt.raw + this.semicolon(flags);\n      }\n\n      return escapeDirective(stmt.directive) + this.semicolon(flags);\n    },\n    DoWhileStatement: function (stmt, flags) {\n      // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\n      var result = join('do', this.maybeBlock(stmt.body, S_TFFF));\n      result = this.maybeBlockSuffix(stmt.body, result);\n      return join(result, ['while' + space + '(', this.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ')' + this.semicolon(flags)]);\n    },\n    CatchClause: function (stmt, flags) {\n      var result,\n          that = this;\n      withIndent(function () {\n        var guard;\n\n        if (stmt.param) {\n          result = ['catch' + space + '(', that.generateExpression(stmt.param, Precedence.Sequence, E_TTT), ')'];\n\n          if (stmt.guard) {\n            guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);\n            result.splice(2, 0, ' if ', guard);\n          }\n        } else {\n          result = ['catch'];\n        }\n      });\n      result.push(this.maybeBlock(stmt.body, S_TFFF));\n      return result;\n    },\n    DebuggerStatement: function (stmt, flags) {\n      return 'debugger' + this.semicolon(flags);\n    },\n    EmptyStatement: function (stmt, flags) {\n      return ';';\n    },\n    ExportDefaultDeclaration: function (stmt, flags) {\n      var result = ['export'],\n          bodyFlags;\n      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF; // export default HoistableDeclaration[Default]\n      // export default AssignmentExpression[In] ;\n\n      result = join(result, 'default');\n\n      if (isStatement(stmt.declaration)) {\n        result = join(result, this.generateStatement(stmt.declaration, bodyFlags));\n      } else {\n        result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));\n      }\n\n      return result;\n    },\n    ExportNamedDeclaration: function (stmt, flags) {\n      var result = ['export'],\n          bodyFlags,\n          that = this;\n      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF; // export VariableStatement\n      // export Declaration[Default]\n\n      if (stmt.declaration) {\n        return join(result, this.generateStatement(stmt.declaration, bodyFlags));\n      } // export ExportClause[NoReference] FromClause ;\n      // export ExportClause ;\n\n\n      if (stmt.specifiers) {\n        if (stmt.specifiers.length === 0) {\n          result = join(result, '{' + space + '}');\n        } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {\n          result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));\n        } else {\n          result = join(result, '{');\n          withIndent(function (indent) {\n            var i, iz;\n            result.push(newline);\n\n            for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {\n              result.push(indent);\n              result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n\n              if (i + 1 < iz) {\n                result.push(',' + newline);\n              }\n            }\n          });\n\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result.push(newline);\n          }\n\n          result.push(base + '}');\n        }\n\n        if (stmt.source) {\n          result = join(result, ['from' + space, // ModuleSpecifier\n          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);\n        } else {\n          result.push(this.semicolon(flags));\n        }\n      }\n\n      return result;\n    },\n    ExportAllDeclaration: function (stmt, flags) {\n      // export * FromClause ;\n      return ['export' + space, '*' + space, 'from' + space, // ModuleSpecifier\n      this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)];\n    },\n    ExpressionStatement: function (stmt, flags) {\n      var result, fragment;\n\n      function isClassPrefixed(fragment) {\n        var code;\n\n        if (fragment.slice(0, 5) !== 'class') {\n          return false;\n        }\n\n        code = fragment.charCodeAt(5);\n        return code === 0x7B\n        /* '{' */\n        || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);\n      }\n\n      function isFunctionPrefixed(fragment) {\n        var code;\n\n        if (fragment.slice(0, 8) !== 'function') {\n          return false;\n        }\n\n        code = fragment.charCodeAt(8);\n        return code === 0x28\n        /* '(' */\n        || esutils.code.isWhiteSpace(code) || code === 0x2A\n        /* '*' */\n        || esutils.code.isLineTerminator(code);\n      }\n\n      function isAsyncPrefixed(fragment) {\n        var code, i, iz;\n\n        if (fragment.slice(0, 5) !== 'async') {\n          return false;\n        }\n\n        if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {\n          return false;\n        }\n\n        for (i = 6, iz = fragment.length; i < iz; ++i) {\n          if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {\n            break;\n          }\n        }\n\n        if (i === iz) {\n          return false;\n        }\n\n        if (fragment.slice(i, i + 8) !== 'function') {\n          return false;\n        }\n\n        code = fragment.charCodeAt(i + 8);\n        return code === 0x28\n        /* '(' */\n        || esutils.code.isWhiteSpace(code) || code === 0x2A\n        /* '*' */\n        || esutils.code.isLineTerminator(code);\n      }\n\n      result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)]; // 12.4 '{', 'function', 'class' is not allowed in this position.\n      // wrap expression with parentheses\n\n      fragment = toSourceNodeWhenNeeded(result).toString();\n\n      if (fragment.charCodeAt(0) === 0x7B\n      /* '{' */\n      || // ObjectExpression\n      isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string') {\n        result = ['(', result, ')' + this.semicolon(flags)];\n      } else {\n        result.push(this.semicolon(flags));\n      }\n\n      return result;\n    },\n    ImportDeclaration: function (stmt, flags) {\n      // ES6: 15.2.1 valid import declarations:\n      //     - import ImportClause FromClause ;\n      //     - import ModuleSpecifier ;\n      var result,\n          cursor,\n          that = this; // If no ImportClause is present,\n      // this should be `import ModuleSpecifier` so skip `from`\n      // ModuleSpecifier is StringLiteral.\n\n      if (stmt.specifiers.length === 0) {\n        // import ModuleSpecifier ;\n        return ['import', space, // ModuleSpecifier\n        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)];\n      } // import ImportClause FromClause ;\n\n\n      result = ['import'];\n      cursor = 0; // ImportedBinding\n\n      if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {\n        result = join(result, [this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);\n        ++cursor;\n      }\n\n      if (stmt.specifiers[cursor]) {\n        if (cursor !== 0) {\n          result.push(',');\n        }\n\n        if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {\n          // NameSpaceImport\n          result = join(result, [space, this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);\n        } else {\n          // NamedImports\n          result.push(space + '{');\n\n          if (stmt.specifiers.length - cursor === 1) {\n            // import { ... } from \"...\";\n            result.push(space);\n            result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));\n            result.push(space + '}' + space);\n          } else {\n            // import {\n            //    ...,\n            //    ...,\n            // } from \"...\";\n            withIndent(function (indent) {\n              var i, iz;\n              result.push(newline);\n\n              for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {\n                result.push(indent);\n                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n\n                if (i + 1 < iz) {\n                  result.push(',' + newline);\n                }\n              }\n            });\n\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n              result.push(newline);\n            }\n\n            result.push(base + '}' + space);\n          }\n        }\n      }\n\n      result = join(result, ['from' + space, // ModuleSpecifier\n      this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);\n      return result;\n    },\n    VariableDeclarator: function (stmt, flags) {\n      var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;\n\n      if (stmt.init) {\n        return [this.generateExpression(stmt.id, Precedence.Assignment, itemFlags), space, '=', space, this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)];\n      }\n\n      return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);\n    },\n    VariableDeclaration: function (stmt, flags) {\n      // VariableDeclarator is typed as Statement,\n      // but joined with comma (not LineTerminator).\n      // So if comment is attached to target node, we should specialize.\n      var result,\n          i,\n          iz,\n          node,\n          bodyFlags,\n          that = this;\n      result = [stmt.kind];\n      bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;\n\n      function block() {\n        node = stmt.declarations[0];\n\n        if (extra.comment && node.leadingComments) {\n          result.push('\\n');\n          result.push(addIndent(that.generateStatement(node, bodyFlags)));\n        } else {\n          result.push(noEmptySpace());\n          result.push(that.generateStatement(node, bodyFlags));\n        }\n\n        for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {\n          node = stmt.declarations[i];\n\n          if (extra.comment && node.leadingComments) {\n            result.push(',' + newline);\n            result.push(addIndent(that.generateStatement(node, bodyFlags)));\n          } else {\n            result.push(',' + space);\n            result.push(that.generateStatement(node, bodyFlags));\n          }\n        }\n      }\n\n      if (stmt.declarations.length > 1) {\n        withIndent(block);\n      } else {\n        block();\n      }\n\n      result.push(this.semicolon(flags));\n      return result;\n    },\n    ThrowStatement: function (stmt, flags) {\n      return [join('throw', this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];\n    },\n    TryStatement: function (stmt, flags) {\n      var result, i, iz, guardedHandlers;\n      result = ['try', this.maybeBlock(stmt.block, S_TFFF)];\n      result = this.maybeBlockSuffix(stmt.block, result);\n\n      if (stmt.handlers) {\n        // old interface\n        for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {\n          result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));\n\n          if (stmt.finalizer || i + 1 !== iz) {\n            result = this.maybeBlockSuffix(stmt.handlers[i].body, result);\n          }\n        }\n      } else {\n        guardedHandlers = stmt.guardedHandlers || [];\n\n        for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {\n          result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));\n\n          if (stmt.finalizer || i + 1 !== iz) {\n            result = this.maybeBlockSuffix(guardedHandlers[i].body, result);\n          }\n        } // new interface\n\n\n        if (stmt.handler) {\n          if (Array.isArray(stmt.handler)) {\n            for (i = 0, iz = stmt.handler.length; i < iz; ++i) {\n              result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));\n\n              if (stmt.finalizer || i + 1 !== iz) {\n                result = this.maybeBlockSuffix(stmt.handler[i].body, result);\n              }\n            }\n          } else {\n            result = join(result, this.generateStatement(stmt.handler, S_TFFF));\n\n            if (stmt.finalizer) {\n              result = this.maybeBlockSuffix(stmt.handler.body, result);\n            }\n          }\n        }\n      }\n\n      if (stmt.finalizer) {\n        result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);\n      }\n\n      return result;\n    },\n    SwitchStatement: function (stmt, flags) {\n      var result,\n          fragment,\n          i,\n          iz,\n          bodyFlags,\n          that = this;\n      withIndent(function () {\n        result = ['switch' + space + '(', that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT), ')' + space + '{' + newline];\n      });\n\n      if (stmt.cases) {\n        bodyFlags = S_TFFF;\n\n        for (i = 0, iz = stmt.cases.length; i < iz; ++i) {\n          if (i === iz - 1) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n\n          fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));\n          result.push(fragment);\n\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            result.push(newline);\n          }\n        }\n      }\n\n      result.push(addIndent('}'));\n      return result;\n    },\n    SwitchCase: function (stmt, flags) {\n      var result,\n          fragment,\n          i,\n          iz,\n          bodyFlags,\n          that = this;\n      withIndent(function () {\n        if (stmt.test) {\n          result = [join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)), ':'];\n        } else {\n          result = ['default:'];\n        }\n\n        i = 0;\n        iz = stmt.consequent.length;\n\n        if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {\n          fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);\n          result.push(fragment);\n          i = 1;\n        }\n\n        if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n          result.push(newline);\n        }\n\n        bodyFlags = S_TFFF;\n\n        for (; i < iz; ++i) {\n          if (i === iz - 1 && flags & F_SEMICOLON_OPT) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n\n          fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));\n          result.push(fragment);\n\n          if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            result.push(newline);\n          }\n        }\n      });\n      return result;\n    },\n    IfStatement: function (stmt, flags) {\n      var result,\n          bodyFlags,\n          semicolonOptional,\n          that = this;\n      withIndent(function () {\n        result = ['if' + space + '(', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ')'];\n      });\n      semicolonOptional = flags & F_SEMICOLON_OPT;\n      bodyFlags = S_TFFF;\n\n      if (semicolonOptional) {\n        bodyFlags |= F_SEMICOLON_OPT;\n      }\n\n      if (stmt.alternate) {\n        result.push(this.maybeBlock(stmt.consequent, S_TFFF));\n        result = this.maybeBlockSuffix(stmt.consequent, result);\n\n        if (stmt.alternate.type === Syntax.IfStatement) {\n          result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);\n        } else {\n          result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));\n        }\n      } else {\n        result.push(this.maybeBlock(stmt.consequent, bodyFlags));\n      }\n\n      return result;\n    },\n    ForStatement: function (stmt, flags) {\n      var result,\n          that = this;\n      withIndent(function () {\n        result = ['for' + space + '('];\n\n        if (stmt.init) {\n          if (stmt.init.type === Syntax.VariableDeclaration) {\n            result.push(that.generateStatement(stmt.init, S_FFFF));\n          } else {\n            // F_ALLOW_IN becomes false.\n            result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));\n            result.push(';');\n          }\n        } else {\n          result.push(';');\n        }\n\n        if (stmt.test) {\n          result.push(space);\n          result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));\n          result.push(';');\n        } else {\n          result.push(';');\n        }\n\n        if (stmt.update) {\n          result.push(space);\n          result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));\n          result.push(')');\n        } else {\n          result.push(')');\n        }\n      });\n      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n      return result;\n    },\n    ForInStatement: function (stmt, flags) {\n      return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n    },\n    ForOfStatement: function (stmt, flags) {\n      return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n    },\n    LabeledStatement: function (stmt, flags) {\n      return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];\n    },\n    Program: function (stmt, flags) {\n      var result, fragment, i, iz, bodyFlags;\n      iz = stmt.body.length;\n      result = [safeConcatenation && iz > 0 ? '\\n' : ''];\n      bodyFlags = S_TFTF;\n\n      for (i = 0; i < iz; ++i) {\n        if (!safeConcatenation && i === iz - 1) {\n          bodyFlags |= F_SEMICOLON_OPT;\n        }\n\n        if (preserveBlankLines) {\n          // handle spaces before the first line\n          if (i === 0) {\n            if (!stmt.body[0].leadingComments) {\n              generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);\n            }\n          } // handle spaces between lines\n\n\n          if (i > 0) {\n            if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n              generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n            }\n          }\n        }\n\n        fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));\n        result.push(fragment);\n\n        if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n          if (preserveBlankLines) {\n            if (!stmt.body[i + 1].leadingComments) {\n              result.push(newline);\n            }\n          } else {\n            result.push(newline);\n          }\n        }\n\n        if (preserveBlankLines) {\n          // handle spaces after the last line\n          if (i === iz - 1) {\n            if (!stmt.body[i].trailingComments) {\n              generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n            }\n          }\n        }\n      }\n\n      return result;\n    },\n    FunctionDeclaration: function (stmt, flags) {\n      return [generateAsyncPrefix(stmt, true), 'function', generateStarSuffix(stmt) || noEmptySpace(), stmt.id ? generateIdentifier(stmt.id) : '', this.generateFunctionBody(stmt)];\n    },\n    ReturnStatement: function (stmt, flags) {\n      if (stmt.argument) {\n        return [join('return', this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];\n      }\n\n      return ['return' + this.semicolon(flags)];\n    },\n    WhileStatement: function (stmt, flags) {\n      var result,\n          that = this;\n      withIndent(function () {\n        result = ['while' + space + '(', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ')'];\n      });\n      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n      return result;\n    },\n    WithStatement: function (stmt, flags) {\n      var result,\n          that = this;\n      withIndent(function () {\n        result = ['with' + space + '(', that.generateExpression(stmt.object, Precedence.Sequence, E_TTT), ')'];\n      });\n      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n      return result;\n    }\n  };\n  merge(CodeGenerator.prototype, CodeGenerator.Statement); // Expressions.\n\n  CodeGenerator.Expression = {\n    SequenceExpression: function (expr, precedence, flags) {\n      var result, i, iz;\n\n      if (Precedence.Sequence < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n\n      result = [];\n\n      for (i = 0, iz = expr.expressions.length; i < iz; ++i) {\n        result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));\n\n        if (i + 1 < iz) {\n          result.push(',' + space);\n        }\n      }\n\n      return parenthesize(result, Precedence.Sequence, precedence);\n    },\n    AssignmentExpression: function (expr, precedence, flags) {\n      return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);\n    },\n    ArrowFunctionExpression: function (expr, precedence, flags) {\n      return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);\n    },\n    ConditionalExpression: function (expr, precedence, flags) {\n      if (Precedence.Conditional < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n\n      return parenthesize([this.generateExpression(expr.test, Precedence.LogicalOR, flags), space + '?' + space, this.generateExpression(expr.consequent, Precedence.Assignment, flags), space + ':' + space, this.generateExpression(expr.alternate, Precedence.Assignment, flags)], Precedence.Conditional, precedence);\n    },\n    LogicalExpression: function (expr, precedence, flags) {\n      return this.BinaryExpression(expr, precedence, flags);\n    },\n    BinaryExpression: function (expr, precedence, flags) {\n      var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;\n      currentPrecedence = BinaryPrecedence[expr.operator];\n      leftPrecedence = expr.operator === '**' ? Precedence.Postfix : currentPrecedence;\n      rightPrecedence = expr.operator === '**' ? currentPrecedence : currentPrecedence + 1;\n\n      if (currentPrecedence < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n\n      fragment = this.generateExpression(expr.left, leftPrecedence, flags);\n      leftSource = fragment.toString();\n\n      if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F\n      /* / */\n      && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {\n        result = [fragment, noEmptySpace(), expr.operator];\n      } else {\n        result = join(fragment, expr.operator);\n      }\n\n      fragment = this.generateExpression(expr.right, rightPrecedence, flags);\n\n      if (expr.operator === '/' && fragment.toString().charAt(0) === '/' || expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {\n        // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start\n        result.push(noEmptySpace());\n        result.push(fragment);\n      } else {\n        result = join(result, fragment);\n      }\n\n      if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {\n        return ['(', result, ')'];\n      }\n\n      return parenthesize(result, currentPrecedence, precedence);\n    },\n    CallExpression: function (expr, precedence, flags) {\n      var result, i, iz; // F_ALLOW_UNPARATH_NEW becomes false.\n\n      result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];\n      result.push('(');\n\n      for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {\n        result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n\n        if (i + 1 < iz) {\n          result.push(',' + space);\n        }\n      }\n\n      result.push(')');\n\n      if (!(flags & F_ALLOW_CALL)) {\n        return ['(', result, ')'];\n      }\n\n      return parenthesize(result, Precedence.Call, precedence);\n    },\n    NewExpression: function (expr, precedence, flags) {\n      var result, length, i, iz, itemFlags;\n      length = expr['arguments'].length; // F_ALLOW_CALL becomes false.\n      // F_ALLOW_UNPARATH_NEW may become false.\n\n      itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;\n      result = join('new', this.generateExpression(expr.callee, Precedence.New, itemFlags));\n\n      if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {\n        result.push('(');\n\n        for (i = 0, iz = length; i < iz; ++i) {\n          result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n\n          if (i + 1 < iz) {\n            result.push(',' + space);\n          }\n        }\n\n        result.push(')');\n      }\n\n      return parenthesize(result, Precedence.New, precedence);\n    },\n    MemberExpression: function (expr, precedence, flags) {\n      var result, fragment; // F_ALLOW_UNPARATH_NEW becomes false.\n\n      result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];\n\n      if (expr.computed) {\n        result.push('[');\n        result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));\n        result.push(']');\n      } else {\n        if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {\n          fragment = toSourceNodeWhenNeeded(result).toString(); // When the following conditions are all true,\n          //   1. No floating point\n          //   2. Don't have exponents\n          //   3. The last character is a decimal digit\n          //   4. Not hexadecimal OR octal number literal\n          // we should add a floating point.\n\n          if (fragment.indexOf('.') < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48) // '0'\n          ) {\n              result.push(' ');\n            }\n        }\n\n        result.push('.');\n        result.push(generateIdentifier(expr.property));\n      }\n\n      return parenthesize(result, Precedence.Member, precedence);\n    },\n    MetaProperty: function (expr, precedence, flags) {\n      var result;\n      result = [];\n      result.push(typeof expr.meta === \"string\" ? expr.meta : generateIdentifier(expr.meta));\n      result.push('.');\n      result.push(typeof expr.property === \"string\" ? expr.property : generateIdentifier(expr.property));\n      return parenthesize(result, Precedence.Member, precedence);\n    },\n    UnaryExpression: function (expr, precedence, flags) {\n      var result, fragment, rightCharCode, leftSource, leftCharCode;\n      fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);\n\n      if (space === '') {\n        result = join(expr.operator, fragment);\n      } else {\n        result = [expr.operator];\n\n        if (expr.operator.length > 2) {\n          // delete, void, typeof\n          // get `typeof []`, not `typeof[]`\n          result = join(result, fragment);\n        } else {\n          // Prevent inserting spaces between operator and argument if it is unnecessary\n          // like, `!cond`\n          leftSource = toSourceNodeWhenNeeded(result).toString();\n          leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n          rightCharCode = fragment.toString().charCodeAt(0);\n\n          if ((leftCharCode === 0x2B\n          /* + */\n          || leftCharCode === 0x2D\n          /* - */\n          ) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {\n            result.push(noEmptySpace());\n            result.push(fragment);\n          } else {\n            result.push(fragment);\n          }\n        }\n      }\n\n      return parenthesize(result, Precedence.Unary, precedence);\n    },\n    YieldExpression: function (expr, precedence, flags) {\n      var result;\n\n      if (expr.delegate) {\n        result = 'yield*';\n      } else {\n        result = 'yield';\n      }\n\n      if (expr.argument) {\n        result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));\n      }\n\n      return parenthesize(result, Precedence.Yield, precedence);\n    },\n    AwaitExpression: function (expr, precedence, flags) {\n      var result = join(expr.all ? 'await*' : 'await', this.generateExpression(expr.argument, Precedence.Await, E_TTT));\n      return parenthesize(result, Precedence.Await, precedence);\n    },\n    UpdateExpression: function (expr, precedence, flags) {\n      if (expr.prefix) {\n        return parenthesize([expr.operator, this.generateExpression(expr.argument, Precedence.Unary, E_TTT)], Precedence.Unary, precedence);\n      }\n\n      return parenthesize([this.generateExpression(expr.argument, Precedence.Postfix, E_TTT), expr.operator], Precedence.Postfix, precedence);\n    },\n    FunctionExpression: function (expr, precedence, flags) {\n      var result = [generateAsyncPrefix(expr, true), 'function'];\n\n      if (expr.id) {\n        result.push(generateStarSuffix(expr) || noEmptySpace());\n        result.push(generateIdentifier(expr.id));\n      } else {\n        result.push(generateStarSuffix(expr) || space);\n      }\n\n      result.push(this.generateFunctionBody(expr));\n      return result;\n    },\n    ArrayPattern: function (expr, precedence, flags) {\n      return this.ArrayExpression(expr, precedence, flags, true);\n    },\n    ArrayExpression: function (expr, precedence, flags, isPattern) {\n      var result,\n          multiline,\n          that = this;\n\n      if (!expr.elements.length) {\n        return '[]';\n      }\n\n      multiline = isPattern ? false : expr.elements.length > 1;\n      result = ['[', multiline ? newline : ''];\n      withIndent(function (indent) {\n        var i, iz;\n\n        for (i = 0, iz = expr.elements.length; i < iz; ++i) {\n          if (!expr.elements[i]) {\n            if (multiline) {\n              result.push(indent);\n            }\n\n            if (i + 1 === iz) {\n              result.push(',');\n            }\n          } else {\n            result.push(multiline ? indent : '');\n            result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));\n          }\n\n          if (i + 1 < iz) {\n            result.push(',' + (multiline ? newline : space));\n          }\n        }\n      });\n\n      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n\n      result.push(multiline ? base : '');\n      result.push(']');\n      return result;\n    },\n    RestElement: function (expr, precedence, flags) {\n      return '...' + this.generatePattern(expr.argument);\n    },\n    ClassExpression: function (expr, precedence, flags) {\n      var result, fragment;\n      result = ['class'];\n\n      if (expr.id) {\n        result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));\n      }\n\n      if (expr.superClass) {\n        fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));\n        result = join(result, fragment);\n      }\n\n      result.push(space);\n      result.push(this.generateStatement(expr.body, S_TFFT));\n      return result;\n    },\n    MethodDefinition: function (expr, precedence, flags) {\n      var result, fragment;\n\n      if (expr['static']) {\n        result = ['static' + space];\n      } else {\n        result = [];\n      }\n\n      if (expr.kind === 'get' || expr.kind === 'set') {\n        fragment = [join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)), this.generateFunctionBody(expr.value)];\n      } else {\n        fragment = [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];\n      }\n\n      return join(result, fragment);\n    },\n    Property: function (expr, precedence, flags) {\n      if (expr.kind === 'get' || expr.kind === 'set') {\n        return [expr.kind, noEmptySpace(), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];\n      }\n\n      if (expr.shorthand) {\n        if (expr.value.type === \"AssignmentPattern\") {\n          return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);\n        }\n\n        return this.generatePropertyKey(expr.key, expr.computed);\n      }\n\n      if (expr.method) {\n        return [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];\n      }\n\n      return [this.generatePropertyKey(expr.key, expr.computed), ':' + space, this.generateExpression(expr.value, Precedence.Assignment, E_TTT)];\n    },\n    ObjectExpression: function (expr, precedence, flags) {\n      var multiline,\n          result,\n          fragment,\n          that = this;\n\n      if (!expr.properties.length) {\n        return '{}';\n      }\n\n      multiline = expr.properties.length > 1;\n      withIndent(function () {\n        fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);\n      });\n\n      if (!multiline) {\n        // issues 4\n        // Do not transform from\n        //   dejavu.Class.declare({\n        //       method2: function () {}\n        //   });\n        // to\n        //   dejavu.Class.declare({method2: function () {\n        //       }});\n        if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n          return ['{', space, fragment, space, '}'];\n        }\n      }\n\n      withIndent(function (indent) {\n        var i, iz;\n        result = ['{', newline, indent, fragment];\n\n        if (multiline) {\n          result.push(',' + newline);\n\n          for (i = 1, iz = expr.properties.length; i < iz; ++i) {\n            result.push(indent);\n            result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n\n            if (i + 1 < iz) {\n              result.push(',' + newline);\n            }\n          }\n        }\n      });\n\n      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n\n      result.push(base);\n      result.push('}');\n      return result;\n    },\n    AssignmentPattern: function (expr, precedence, flags) {\n      return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);\n    },\n    ObjectPattern: function (expr, precedence, flags) {\n      var result,\n          i,\n          iz,\n          multiline,\n          property,\n          that = this;\n\n      if (!expr.properties.length) {\n        return '{}';\n      }\n\n      multiline = false;\n\n      if (expr.properties.length === 1) {\n        property = expr.properties[0];\n\n        if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {\n          multiline = true;\n        }\n      } else {\n        for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n          property = expr.properties[i];\n\n          if (property.type === Syntax.Property && !property.shorthand) {\n            multiline = true;\n            break;\n          }\n        }\n      }\n\n      result = ['{', multiline ? newline : ''];\n      withIndent(function (indent) {\n        var i, iz;\n\n        for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n          result.push(multiline ? indent : '');\n          result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n\n          if (i + 1 < iz) {\n            result.push(',' + (multiline ? newline : space));\n          }\n        }\n      });\n\n      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n\n      result.push(multiline ? base : '');\n      result.push('}');\n      return result;\n    },\n    ThisExpression: function (expr, precedence, flags) {\n      return 'this';\n    },\n    Super: function (expr, precedence, flags) {\n      return 'super';\n    },\n    Identifier: function (expr, precedence, flags) {\n      return generateIdentifier(expr);\n    },\n    ImportDefaultSpecifier: function (expr, precedence, flags) {\n      return generateIdentifier(expr.id || expr.local);\n    },\n    ImportNamespaceSpecifier: function (expr, precedence, flags) {\n      var result = ['*'];\n      var id = expr.id || expr.local;\n\n      if (id) {\n        result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));\n      }\n\n      return result;\n    },\n    ImportSpecifier: function (expr, precedence, flags) {\n      var imported = expr.imported;\n      var result = [imported.name];\n      var local = expr.local;\n\n      if (local && local.name !== imported.name) {\n        result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));\n      }\n\n      return result;\n    },\n    ExportSpecifier: function (expr, precedence, flags) {\n      var local = expr.local;\n      var result = [local.name];\n      var exported = expr.exported;\n\n      if (exported && exported.name !== local.name) {\n        result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));\n      }\n\n      return result;\n    },\n    Literal: function (expr, precedence, flags) {\n      var raw;\n\n      if (expr.hasOwnProperty('raw') && parse && extra.raw) {\n        try {\n          raw = parse(expr.raw).body[0].expression;\n\n          if (raw.type === Syntax.Literal) {\n            if (raw.value === expr.value) {\n              return expr.raw;\n            }\n          }\n        } catch (e) {// not use raw property\n        }\n      }\n\n      if (expr.regex) {\n        return '/' + expr.regex.pattern + '/' + expr.regex.flags;\n      }\n\n      if (expr.value === null) {\n        return 'null';\n      }\n\n      if (typeof expr.value === 'string') {\n        return escapeString(expr.value);\n      }\n\n      if (typeof expr.value === 'number') {\n        return generateNumber(expr.value);\n      }\n\n      if (typeof expr.value === 'boolean') {\n        return expr.value ? 'true' : 'false';\n      }\n\n      return generateRegExp(expr.value);\n    },\n    GeneratorExpression: function (expr, precedence, flags) {\n      return this.ComprehensionExpression(expr, precedence, flags);\n    },\n    ComprehensionExpression: function (expr, precedence, flags) {\n      // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]\n      // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6\n      var result,\n          i,\n          iz,\n          fragment,\n          that = this;\n      result = expr.type === Syntax.GeneratorExpression ? ['('] : ['['];\n\n      if (extra.moz.comprehensionExpressionStartsWithAssignment) {\n        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n        result.push(fragment);\n      }\n\n      if (expr.blocks) {\n        withIndent(function () {\n          for (i = 0, iz = expr.blocks.length; i < iz; ++i) {\n            fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);\n\n            if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {\n              result = join(result, fragment);\n            } else {\n              result.push(fragment);\n            }\n          }\n        });\n      }\n\n      if (expr.filter) {\n        result = join(result, 'if' + space);\n        fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);\n        result = join(result, ['(', fragment, ')']);\n      }\n\n      if (!extra.moz.comprehensionExpressionStartsWithAssignment) {\n        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n        result = join(result, fragment);\n      }\n\n      result.push(expr.type === Syntax.GeneratorExpression ? ')' : ']');\n      return result;\n    },\n    ComprehensionBlock: function (expr, precedence, flags) {\n      var fragment;\n\n      if (expr.left.type === Syntax.VariableDeclaration) {\n        fragment = [expr.left.kind, noEmptySpace(), this.generateStatement(expr.left.declarations[0], S_FFFF)];\n      } else {\n        fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);\n      }\n\n      fragment = join(fragment, expr.of ? 'of' : 'in');\n      fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));\n      return ['for' + space + '(', fragment, ')'];\n    },\n    SpreadElement: function (expr, precedence, flags) {\n      return ['...', this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)];\n    },\n    TaggedTemplateExpression: function (expr, precedence, flags) {\n      var itemFlags = E_TTF;\n\n      if (!(flags & F_ALLOW_CALL)) {\n        itemFlags = E_TFF;\n      }\n\n      var result = [this.generateExpression(expr.tag, Precedence.Call, itemFlags), this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)];\n      return parenthesize(result, Precedence.TaggedTemplate, precedence);\n    },\n    TemplateElement: function (expr, precedence, flags) {\n      // Don't use \"cooked\". Since tagged template can use raw template\n      // representation. So if we do so, it breaks the script semantics.\n      return expr.value.raw;\n    },\n    TemplateLiteral: function (expr, precedence, flags) {\n      var result, i, iz;\n      result = ['`'];\n\n      for (i = 0, iz = expr.quasis.length; i < iz; ++i) {\n        result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));\n\n        if (i + 1 < iz) {\n          result.push('${' + space);\n          result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));\n          result.push(space + '}');\n        }\n      }\n\n      result.push('`');\n      return result;\n    },\n    ModuleSpecifier: function (expr, precedence, flags) {\n      return this.Literal(expr, precedence, flags);\n    },\n    ImportExpression: function (expr, precedence, flag) {\n      return parenthesize(['import(', this.generateExpression(expr.source, Precedence.Assignment, E_TTT), ')'], Precedence.Call, precedence);\n    }\n  };\n  merge(CodeGenerator.prototype, CodeGenerator.Expression);\n\n  CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {\n    var result, type;\n    type = expr.type || Syntax.Property;\n\n    if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n      return generateVerbatim(expr, precedence);\n    }\n\n    result = this[type](expr, precedence, flags);\n\n    if (extra.comment) {\n      result = addComments(expr, result);\n    }\n\n    return toSourceNodeWhenNeeded(result, expr);\n  };\n\n  CodeGenerator.prototype.generateStatement = function (stmt, flags) {\n    var result, fragment;\n    result = this[stmt.type](stmt, flags); // Attach comments\n\n    if (extra.comment) {\n      result = addComments(stmt, result);\n    }\n\n    fragment = toSourceNodeWhenNeeded(result).toString();\n\n    if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' && fragment.charAt(fragment.length - 1) === '\\n') {\n      result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\\s+$/, '') : fragment.replace(/\\s+$/, '');\n    }\n\n    return toSourceNodeWhenNeeded(result, stmt);\n  };\n\n  function generateInternal(node) {\n    var codegen;\n    codegen = new CodeGenerator();\n\n    if (isStatement(node)) {\n      return codegen.generateStatement(node, S_TFFF);\n    }\n\n    if (isExpression(node)) {\n      return codegen.generateExpression(node, Precedence.Sequence, E_TTT);\n    }\n\n    throw new Error('Unknown node type: ' + node.type);\n  }\n\n  function generate(node, options) {\n    var defaultOptions = getDefaultOptions(),\n        result,\n        pair;\n\n    if (options != null) {\n      // Obsolete options\n      //\n      //   `options.indent`\n      //   `options.base`\n      //\n      // Instead of them, we can use `option.format.indent`.\n      if (typeof options.indent === 'string') {\n        defaultOptions.format.indent.style = options.indent;\n      }\n\n      if (typeof options.base === 'number') {\n        defaultOptions.format.indent.base = options.base;\n      }\n\n      options = updateDeeply(defaultOptions, options);\n      indent = options.format.indent.style;\n\n      if (typeof options.base === 'string') {\n        base = options.base;\n      } else {\n        base = stringRepeat(indent, options.format.indent.base);\n      }\n    } else {\n      options = defaultOptions;\n      indent = options.format.indent.style;\n      base = stringRepeat(indent, options.format.indent.base);\n    }\n\n    json = options.format.json;\n    renumber = options.format.renumber;\n    hexadecimal = json ? false : options.format.hexadecimal;\n    quotes = json ? 'double' : options.format.quotes;\n    escapeless = options.format.escapeless;\n    newline = options.format.newline;\n    space = options.format.space;\n\n    if (options.format.compact) {\n      newline = space = indent = base = '';\n    }\n\n    parentheses = options.format.parentheses;\n    semicolons = options.format.semicolons;\n    safeConcatenation = options.format.safeConcatenation;\n    directive = options.directive;\n    parse = json ? null : options.parse;\n    sourceMap = options.sourceMap;\n    sourceCode = options.sourceCode;\n    preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;\n    extra = options;\n\n    if (sourceMap) {\n      if (!exports.browser) {\n        // We assume environment is node.js\n        // And prevent from including source-map by browserify\n        SourceNode = require('source-map').SourceNode;\n      } else {\n        SourceNode = global.sourceMap.SourceNode;\n      }\n    }\n\n    result = generateInternal(node);\n\n    if (!sourceMap) {\n      pair = {\n        code: result.toString(),\n        map: null\n      };\n      return options.sourceMapWithCode ? pair : pair.code;\n    }\n\n    pair = result.toStringWithSourceMap({\n      file: options.file,\n      sourceRoot: options.sourceMapRoot\n    });\n\n    if (options.sourceContent) {\n      pair.map.setSourceContent(options.sourceMap, options.sourceContent);\n    }\n\n    if (options.sourceMapWithCode) {\n      return pair;\n    }\n\n    return pair.map.toString();\n  }\n\n  FORMAT_MINIFY = {\n    indent: {\n      style: '',\n      base: 0\n    },\n    renumber: true,\n    hexadecimal: true,\n    quotes: 'auto',\n    escapeless: true,\n    compact: true,\n    parentheses: false,\n    semicolons: false\n  };\n  FORMAT_DEFAULTS = getDefaultOptions().format;\n  exports.version = require('./package.json').version;\n  exports.generate = generate;\n  exports.attachComments = estraverse.attachComments;\n  exports.Precedence = updateDeeply({}, Precedence);\n  exports.browser = false;\n  exports.FORMAT_MINIFY = FORMAT_MINIFY;\n  exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;\n})();\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/escodegen/escodegen.js"],"names":["Syntax","Precedence","BinaryPrecedence","SourceNode","estraverse","esutils","base","indent","json","renumber","hexadecimal","quotes","escapeless","newline","space","parentheses","semicolons","safeConcatenation","directive","extra","parse","sourceMap","sourceCode","preserveBlankLines","FORMAT_MINIFY","FORMAT_DEFAULTS","require","isExpression","node","CodeGenerator","Expression","hasOwnProperty","type","isStatement","Statement","Sequence","Yield","Assignment","Conditional","ArrowFunction","LogicalOR","LogicalAND","BitwiseOR","BitwiseXOR","BitwiseAND","Equality","Relational","BitwiseSHIFT","Additive","Multiplicative","Exponentiation","Await","Unary","Postfix","Call","New","TaggedTemplate","Member","Primary","F_ALLOW_IN","F_ALLOW_CALL","F_ALLOW_UNPARATH_NEW","F_FUNC_BODY","F_DIRECTIVE_CTX","F_SEMICOLON_OPT","E_FTT","E_TTF","E_TTT","E_TFF","E_FFT","E_TFT","S_TFFF","S_TFFT","S_FFFF","S_TFTF","S_TTFF","getDefaultOptions","comment","format","style","adjustMultilineComment","compact","moz","comprehensionExpressionStartsWithAssignment","starlessGenerator","sourceMapRoot","sourceMapWithCode","raw","verbatim","stringRepeat","str","num","result","hasLineTerminator","test","endsWithLineTerminator","len","length","code","isLineTerminator","charCodeAt","merge","target","override","key","updateDeeply","val","isHashObject","Object","RegExp","generateNumber","value","point","temp","exponent","pos","Error","indexOf","slice","replace","Math","floor","toString","escapeRegExpCharacter","ch","previousIsBackslash","String","fromCharCode","generateRegExp","reg","match","flags","i","iz","characterInBrack","source","escapeAllowedCharacter","next","hex","toUpperCase","isDecimalDigit","escapeDisallowedCharacter","escapeDirective","quote","escapeString","singleQuotes","doubleQuotes","single","isIdentifierPartES5","flattenToString","arr","elem","Array","isArray","toSourceNodeWhenNeeded","generated","loc","name","start","line","column","noEmptySpace","join","left","right","leftSource","rightSource","leftCharCode","rightCharCode","isWhiteSpace","addIndent","stmt","withIndent","fn","previousBase","calculateSpaces","specialBase","array","j","spaces","sn","split","Number","MAX_VALUE","generateComment","addComments","save","tailingToStatement","fragment","extRange","range","prevRange","prefix","infix","suffix","count","leadingComments","extendedRange","substring","push","Program","body","trailingComments","generateBlankLines","end","newlineCount","parenthesize","text","current","should","generateVerbatimString","string","generateVerbatim","expr","precedence","prec","content","prototype","maybeBlock","noLeadingComment","that","BlockStatement","generateStatement","EmptyStatement","maybeBlockSuffix","ends","generateIdentifier","generateAsyncPrefix","spaceRequired","async","generateStarSuffix","isGenerator","generator","generateMethodPrefix","prop","func","computed","generatePattern","Identifier","generateExpression","generateFunctionParams","hasDefault","ArrowFunctionExpression","rest","defaults","params","generateAssignment","generateFunctionBody","expression","charAt","generateIterationForStatement","operator","await","VariableDeclaration","kind","declarations","generatePropertyKey","semicolon","bodyFlags","BreakStatement","label","ContinueStatement","ClassBody","ClassDeclaration","id","superClass","DirectiveStatement","DoWhileStatement","CatchClause","guard","param","splice","DebuggerStatement","ExportDefaultDeclaration","declaration","ExportNamedDeclaration","specifiers","ExportBatchSpecifier","ExportAllDeclaration","ExpressionStatement","isClassPrefixed","isFunctionPrefixed","isAsyncPrefixed","Literal","ImportDeclaration","cursor","ImportDefaultSpecifier","ImportNamespaceSpecifier","VariableDeclarator","itemFlags","init","block","ThrowStatement","argument","TryStatement","guardedHandlers","handlers","finalizer","handler","SwitchStatement","discriminant","cases","SwitchCase","consequent","IfStatement","semicolonOptional","alternate","ForStatement","update","ForInStatement","ForOfStatement","LabeledStatement","FunctionDeclaration","ReturnStatement","WhileStatement","WithStatement","object","SequenceExpression","expressions","AssignmentExpression","ConditionalExpression","LogicalExpression","BinaryExpression","leftPrecedence","rightPrecedence","currentPrecedence","CallExpression","callee","NewExpression","MemberExpression","property","MetaProperty","meta","UnaryExpression","YieldExpression","delegate","AwaitExpression","all","UpdateExpression","FunctionExpression","ArrayPattern","ArrayExpression","isPattern","multiline","elements","RestElement","ClassExpression","MethodDefinition","Property","shorthand","AssignmentPattern","method","ObjectExpression","properties","ObjectPattern","ThisExpression","Super","local","ImportSpecifier","imported","ExportSpecifier","exported","e","regex","pattern","GeneratorExpression","ComprehensionExpression","blocks","filter","ComprehensionBlock","of","SpreadElement","TaggedTemplateExpression","tag","quasi","TemplateElement","TemplateLiteral","quasis","ModuleSpecifier","ImportExpression","flag","replaceRight","generateInternal","codegen","generate","options","defaultOptions","pair","exports","browser","global","map","toStringWithSourceMap","file","sourceRoot","sourceContent","setSourceContent","version","attachComments"],"mappings":"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","sourcesContent":["/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\n  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*global exports:true, require:true, global:true*/\n(function () {\n    'use strict';\n\n    var Syntax,\n        Precedence,\n        BinaryPrecedence,\n        SourceNode,\n        estraverse,\n        esutils,\n        base,\n        indent,\n        json,\n        renumber,\n        hexadecimal,\n        quotes,\n        escapeless,\n        newline,\n        space,\n        parentheses,\n        semicolons,\n        safeConcatenation,\n        directive,\n        extra,\n        parse,\n        sourceMap,\n        sourceCode,\n        preserveBlankLines,\n        FORMAT_MINIFY,\n        FORMAT_DEFAULTS;\n\n    estraverse = require('estraverse');\n    esutils = require('esutils');\n\n    Syntax = estraverse.Syntax;\n\n    // Generation is done by generateExpression.\n    function isExpression(node) {\n        return CodeGenerator.Expression.hasOwnProperty(node.type);\n    }\n\n    // Generation is done by generateStatement.\n    function isStatement(node) {\n        return CodeGenerator.Statement.hasOwnProperty(node.type);\n    }\n\n    Precedence = {\n        Sequence: 0,\n        Yield: 1,\n        Assignment: 1,\n        Conditional: 2,\n        ArrowFunction: 2,\n        LogicalOR: 3,\n        LogicalAND: 4,\n        BitwiseOR: 5,\n        BitwiseXOR: 6,\n        BitwiseAND: 7,\n        Equality: 8,\n        Relational: 9,\n        BitwiseSHIFT: 10,\n        Additive: 11,\n        Multiplicative: 12,\n        Exponentiation: 13,\n        Await: 14,\n        Unary: 14,\n        Postfix: 15,\n        Call: 16,\n        New: 17,\n        TaggedTemplate: 18,\n        Member: 19,\n        Primary: 20\n    };\n\n    BinaryPrecedence = {\n        '||': Precedence.LogicalOR,\n        '&&': Precedence.LogicalAND,\n        '|': Precedence.BitwiseOR,\n        '^': Precedence.BitwiseXOR,\n        '&': Precedence.BitwiseAND,\n        '==': Precedence.Equality,\n        '!=': Precedence.Equality,\n        '===': Precedence.Equality,\n        '!==': Precedence.Equality,\n        'is': Precedence.Equality,\n        'isnt': Precedence.Equality,\n        '<': Precedence.Relational,\n        '>': Precedence.Relational,\n        '<=': Precedence.Relational,\n        '>=': Precedence.Relational,\n        'in': Precedence.Relational,\n        'instanceof': Precedence.Relational,\n        '<<': Precedence.BitwiseSHIFT,\n        '>>': Precedence.BitwiseSHIFT,\n        '>>>': Precedence.BitwiseSHIFT,\n        '+': Precedence.Additive,\n        '-': Precedence.Additive,\n        '*': Precedence.Multiplicative,\n        '%': Precedence.Multiplicative,\n        '/': Precedence.Multiplicative,\n        '**': Precedence.Exponentiation\n    };\n\n    //Flags\n    var F_ALLOW_IN = 1,\n        F_ALLOW_CALL = 1 << 1,\n        F_ALLOW_UNPARATH_NEW = 1 << 2,\n        F_FUNC_BODY = 1 << 3,\n        F_DIRECTIVE_CTX = 1 << 4,\n        F_SEMICOLON_OPT = 1 << 5;\n\n    //Expression flag sets\n    //NOTE: Flag order:\n    // F_ALLOW_IN\n    // F_ALLOW_CALL\n    // F_ALLOW_UNPARATH_NEW\n    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n        E_TTF = F_ALLOW_IN | F_ALLOW_CALL,\n        E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n        E_TFF = F_ALLOW_IN,\n        E_FFT = F_ALLOW_UNPARATH_NEW,\n        E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;\n\n    //Statement flag sets\n    //NOTE: Flag order:\n    // F_ALLOW_IN\n    // F_FUNC_BODY\n    // F_DIRECTIVE_CTX\n    // F_SEMICOLON_OPT\n    var S_TFFF = F_ALLOW_IN,\n        S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,\n        S_FFFF = 0x00,\n        S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,\n        S_TTFF = F_ALLOW_IN | F_FUNC_BODY;\n\n    function getDefaultOptions() {\n        // default options\n        return {\n            indent: null,\n            base: null,\n            parse: null,\n            comment: false,\n            format: {\n                indent: {\n                    style: '    ',\n                    base: 0,\n                    adjustMultilineComment: false\n                },\n                newline: '\\n',\n                space: ' ',\n                json: false,\n                renumber: false,\n                hexadecimal: false,\n                quotes: 'single',\n                escapeless: false,\n                compact: false,\n                parentheses: true,\n                semicolons: true,\n                safeConcatenation: false,\n                preserveBlankLines: false\n            },\n            moz: {\n                comprehensionExpressionStartsWithAssignment: false,\n                starlessGenerator: false\n            },\n            sourceMap: null,\n            sourceMapRoot: null,\n            sourceMapWithCode: false,\n            directive: false,\n            raw: true,\n            verbatim: null,\n            sourceCode: null\n        };\n    }\n\n    function stringRepeat(str, num) {\n        var result = '';\n\n        for (num |= 0; num > 0; num >>>= 1, str += str) {\n            if (num & 1) {\n                result += str;\n            }\n        }\n\n        return result;\n    }\n\n    function hasLineTerminator(str) {\n        return (/[\\r\\n]/g).test(str);\n    }\n\n    function endsWithLineTerminator(str) {\n        var len = str.length;\n        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));\n    }\n\n    function merge(target, override) {\n        var key;\n        for (key in override) {\n            if (override.hasOwnProperty(key)) {\n                target[key] = override[key];\n            }\n        }\n        return target;\n    }\n\n    function updateDeeply(target, override) {\n        var key, val;\n\n        function isHashObject(target) {\n            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);\n        }\n\n        for (key in override) {\n            if (override.hasOwnProperty(key)) {\n                val = override[key];\n                if (isHashObject(val)) {\n                    if (isHashObject(target[key])) {\n                        updateDeeply(target[key], val);\n                    } else {\n                        target[key] = updateDeeply({}, val);\n                    }\n                } else {\n                    target[key] = val;\n                }\n            }\n        }\n        return target;\n    }\n\n    function generateNumber(value) {\n        var result, point, temp, exponent, pos;\n\n        if (value !== value) {\n            throw new Error('Numeric literal whose value is NaN');\n        }\n        if (value < 0 || (value === 0 && 1 / value < 0)) {\n            throw new Error('Numeric literal whose value is negative');\n        }\n\n        if (value === 1 / 0) {\n            return json ? 'null' : renumber ? '1e400' : '1e+400';\n        }\n\n        result = '' + value;\n        if (!renumber || result.length < 3) {\n            return result;\n        }\n\n        point = result.indexOf('.');\n        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {\n            point = 0;\n            result = result.slice(1);\n        }\n        temp = result;\n        result = result.replace('e+', 'e');\n        exponent = 0;\n        if ((pos = temp.indexOf('e')) > 0) {\n            exponent = +temp.slice(pos + 1);\n            temp = temp.slice(0, pos);\n        }\n        if (point >= 0) {\n            exponent -= temp.length - point - 1;\n            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';\n        }\n        pos = 0;\n        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {\n            --pos;\n        }\n        if (pos !== 0) {\n            exponent -= pos;\n            temp = temp.slice(0, pos);\n        }\n        if (exponent !== 0) {\n            temp += 'e' + exponent;\n        }\n        if ((temp.length < result.length ||\n                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&\n                +temp === value) {\n            result = temp;\n        }\n\n        return result;\n    }\n\n    // Generate valid RegExp expression.\n    // This function is based on https://github.com/Constellation/iv Engine\n\n    function escapeRegExpCharacter(ch, previousIsBackslash) {\n        // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\n        if ((ch & ~1) === 0x2028) {\n            return (previousIsBackslash ? 'u' : '\\\\u') + ((ch === 0x2028) ? '2028' : '2029');\n        } else if (ch === 10 || ch === 13) {  // \\n, \\r\n            return (previousIsBackslash ? '' : '\\\\') + ((ch === 10) ? 'n' : 'r');\n        }\n        return String.fromCharCode(ch);\n    }\n\n    function generateRegExp(reg) {\n        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n\n        result = reg.toString();\n\n        if (reg.source) {\n            // extract flag from toString result\n            match = result.match(/\\/([^/]*)$/);\n            if (!match) {\n                return result;\n            }\n\n            flags = match[1];\n            result = '';\n\n            characterInBrack = false;\n            previousIsBackslash = false;\n            for (i = 0, iz = reg.source.length; i < iz; ++i) {\n                ch = reg.source.charCodeAt(i);\n\n                if (!previousIsBackslash) {\n                    if (characterInBrack) {\n                        if (ch === 93) {  // ]\n                            characterInBrack = false;\n                        }\n                    } else {\n                        if (ch === 47) {  // /\n                            result += '\\\\';\n                        } else if (ch === 91) {  // [\n                            characterInBrack = true;\n                        }\n                    }\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\n                    previousIsBackslash = ch === 92;  // \\\n                } else {\n                    // if new RegExp(\"\\\\\\n') is provided, create /\\n/\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\n                    // prevent like /\\\\[/]/\n                    previousIsBackslash = false;\n                }\n            }\n\n            return '/' + result + '/' + flags;\n        }\n\n        return result;\n    }\n\n    function escapeAllowedCharacter(code, next) {\n        var hex;\n\n        if (code === 0x08  /* \\b */) {\n            return '\\\\b';\n        }\n\n        if (code === 0x0C  /* \\f */) {\n            return '\\\\f';\n        }\n\n        if (code === 0x09  /* \\t */) {\n            return '\\\\t';\n        }\n\n        hex = code.toString(16).toUpperCase();\n        if (json || code > 0xFF) {\n            return '\\\\u' + '0000'.slice(hex.length) + hex;\n        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {\n            return '\\\\0';\n        } else if (code === 0x000B  /* \\v */) { // '\\v'\n            return '\\\\x0B';\n        } else {\n            return '\\\\x' + '00'.slice(hex.length) + hex;\n        }\n    }\n\n    function escapeDisallowedCharacter(code) {\n        if (code === 0x5C  /* \\ */) {\n            return '\\\\\\\\';\n        }\n\n        if (code === 0x0A  /* \\n */) {\n            return '\\\\n';\n        }\n\n        if (code === 0x0D  /* \\r */) {\n            return '\\\\r';\n        }\n\n        if (code === 0x2028) {\n            return '\\\\u2028';\n        }\n\n        if (code === 0x2029) {\n            return '\\\\u2029';\n        }\n\n        throw new Error('Incorrectly classified character');\n    }\n\n    function escapeDirective(str) {\n        var i, iz, code, quote;\n\n        quote = quotes === 'double' ? '\"' : '\\'';\n        for (i = 0, iz = str.length; i < iz; ++i) {\n            code = str.charCodeAt(i);\n            if (code === 0x27  /* ' */) {\n                quote = '\"';\n                break;\n            } else if (code === 0x22  /* \" */) {\n                quote = '\\'';\n                break;\n            } else if (code === 0x5C  /* \\ */) {\n                ++i;\n            }\n        }\n\n        return quote + str + quote;\n    }\n\n    function escapeString(str) {\n        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;\n\n        for (i = 0, len = str.length; i < len; ++i) {\n            code = str.charCodeAt(i);\n            if (code === 0x27  /* ' */) {\n                ++singleQuotes;\n            } else if (code === 0x22  /* \" */) {\n                ++doubleQuotes;\n            } else if (code === 0x2F  /* / */ && json) {\n                result += '\\\\';\n            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \\ */) {\n                result += escapeDisallowedCharacter(code);\n                continue;\n            } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20  /* SP */ || !json && !escapeless && (code < 0x20  /* SP */ || code > 0x7E  /* ~ */))) {\n                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));\n                continue;\n            }\n            result += String.fromCharCode(code);\n        }\n\n        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));\n        quote = single ? '\\'' : '\"';\n\n        if (!(single ? singleQuotes : doubleQuotes)) {\n            return quote + result + quote;\n        }\n\n        str = result;\n        result = quote;\n\n        for (i = 0, len = str.length; i < len; ++i) {\n            code = str.charCodeAt(i);\n            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* \" */ && !single)) {\n                result += '\\\\';\n            }\n            result += String.fromCharCode(code);\n        }\n\n        return result + quote;\n    }\n\n    /**\n     * flatten an array to a string, where the array can contain\n     * either strings or nested arrays\n     */\n    function flattenToString(arr) {\n        var i, iz, elem, result = '';\n        for (i = 0, iz = arr.length; i < iz; ++i) {\n            elem = arr[i];\n            result += Array.isArray(elem) ? flattenToString(elem) : elem;\n        }\n        return result;\n    }\n\n    /**\n     * convert generated to a SourceNode when source maps are enabled.\n     */\n    function toSourceNodeWhenNeeded(generated, node) {\n        if (!sourceMap) {\n            // with no source maps, generated is either an\n            // array or a string.  if an array, flatten it.\n            // if a string, just return it\n            if (Array.isArray(generated)) {\n                return flattenToString(generated);\n            } else {\n                return generated;\n            }\n        }\n        if (node == null) {\n            if (generated instanceof SourceNode) {\n                return generated;\n            } else {\n                node = {};\n            }\n        }\n        if (node.loc == null) {\n            return new SourceNode(null, null, sourceMap, generated, node.name || null);\n        }\n        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);\n    }\n\n    function noEmptySpace() {\n        return (space) ? space : ' ';\n    }\n\n    function join(left, right) {\n        var leftSource,\n            rightSource,\n            leftCharCode,\n            rightCharCode;\n\n        leftSource = toSourceNodeWhenNeeded(left).toString();\n        if (leftSource.length === 0) {\n            return [right];\n        }\n\n        rightSource = toSourceNodeWhenNeeded(right).toString();\n        if (rightSource.length === 0) {\n            return [left];\n        }\n\n        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n        rightCharCode = rightSource.charCodeAt(0);\n\n        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||\n            esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) ||\n            leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`\n            return [left, noEmptySpace(), right];\n        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||\n                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {\n            return [left, right];\n        }\n        return [left, space, right];\n    }\n\n    function addIndent(stmt) {\n        return [base, stmt];\n    }\n\n    function withIndent(fn) {\n        var previousBase;\n        previousBase = base;\n        base += indent;\n        fn(base);\n        base = previousBase;\n    }\n\n    function calculateSpaces(str) {\n        var i;\n        for (i = str.length - 1; i >= 0; --i) {\n            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {\n                break;\n            }\n        }\n        return (str.length - 1) - i;\n    }\n\n    function adjustMultilineComment(value, specialBase) {\n        var array, i, len, line, j, spaces, previousBase, sn;\n\n        array = value.split(/\\r\\n|[\\r\\n]/);\n        spaces = Number.MAX_VALUE;\n\n        // first line doesn't have indentation\n        for (i = 1, len = array.length; i < len; ++i) {\n            line = array[i];\n            j = 0;\n            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {\n                ++j;\n            }\n            if (spaces > j) {\n                spaces = j;\n            }\n        }\n\n        if (typeof specialBase !== 'undefined') {\n            // pattern like\n            // {\n            //   var t = 20;  /*\n            //                 * this is comment\n            //                 */\n            // }\n            previousBase = base;\n            if (array[1][spaces] === '*') {\n                specialBase += ' ';\n            }\n            base = specialBase;\n        } else {\n            if (spaces & 1) {\n                // /*\n                //  *\n                //  */\n                // If spaces are odd number, above pattern is considered.\n                // We waste 1 space.\n                --spaces;\n            }\n            previousBase = base;\n        }\n\n        for (i = 1, len = array.length; i < len; ++i) {\n            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));\n            array[i] = sourceMap ? sn.join('') : sn;\n        }\n\n        base = previousBase;\n\n        return array.join('\\n');\n    }\n\n    function generateComment(comment, specialBase) {\n        if (comment.type === 'Line') {\n            if (endsWithLineTerminator(comment.value)) {\n                return '//' + comment.value;\n            } else {\n                // Always use LineTerminator\n                var result = '//' + comment.value;\n                if (!preserveBlankLines) {\n                    result += '\\n';\n                }\n                return result;\n            }\n        }\n        if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\n            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);\n        }\n        return '/*' + comment.value + '*/';\n    }\n\n    function addComments(stmt, result) {\n        var i, len, comment, save, tailingToStatement, specialBase, fragment,\n            extRange, range, prevRange, prefix, infix, suffix, count;\n\n        if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n            save = result;\n\n            if (preserveBlankLines) {\n                comment = stmt.leadingComments[0];\n                result = [];\n\n                extRange = comment.extendedRange;\n                range = comment.range;\n\n                prefix = sourceCode.substring(extRange[0], range[0]);\n                count = (prefix.match(/\\n/g) || []).length;\n                if (count > 0) {\n                    result.push(stringRepeat('\\n', count));\n                    result.push(addIndent(generateComment(comment)));\n                } else {\n                    result.push(prefix);\n                    result.push(generateComment(comment));\n                }\n\n                prevRange = range;\n\n                for (i = 1, len = stmt.leadingComments.length; i < len; i++) {\n                    comment = stmt.leadingComments[i];\n                    range = comment.range;\n\n                    infix = sourceCode.substring(prevRange[1], range[0]);\n                    count = (infix.match(/\\n/g) || []).length;\n                    result.push(stringRepeat('\\n', count));\n                    result.push(addIndent(generateComment(comment)));\n\n                    prevRange = range;\n                }\n\n                suffix = sourceCode.substring(range[1], extRange[1]);\n                count = (suffix.match(/\\n/g) || []).length;\n                result.push(stringRepeat('\\n', count));\n            } else {\n                comment = stmt.leadingComments[0];\n                result = [];\n                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\n                    result.push('\\n');\n                }\n                result.push(generateComment(comment));\n                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                    result.push('\\n');\n                }\n\n                for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {\n                    comment = stmt.leadingComments[i];\n                    fragment = [generateComment(comment)];\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        fragment.push('\\n');\n                    }\n                    result.push(addIndent(fragment));\n                }\n            }\n\n            result.push(addIndent(save));\n        }\n\n        if (stmt.trailingComments) {\n\n            if (preserveBlankLines) {\n                comment = stmt.trailingComments[0];\n                extRange = comment.extendedRange;\n                range = comment.range;\n\n                prefix = sourceCode.substring(extRange[0], range[0]);\n                count = (prefix.match(/\\n/g) || []).length;\n\n                if (count > 0) {\n                    result.push(stringRepeat('\\n', count));\n                    result.push(addIndent(generateComment(comment)));\n                } else {\n                    result.push(prefix);\n                    result.push(generateComment(comment));\n                }\n            } else {\n                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n                specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));\n                for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {\n                    comment = stmt.trailingComments[i];\n                    if (tailingToStatement) {\n                        // We assume target like following script\n                        //\n                        // var t = 20;  /**\n                        //               * This is comment of t\n                        //               */\n                        if (i === 0) {\n                            // first case\n                            result = [result, indent];\n                        } else {\n                            result = [result, specialBase];\n                        }\n                        result.push(generateComment(comment, specialBase));\n                    } else {\n                        result = [result, addIndent(generateComment(comment))];\n                    }\n                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                        result = [result, '\\n'];\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    function generateBlankLines(start, end, result) {\n        var j, newlineCount = 0;\n\n        for (j = start; j < end; j++) {\n            if (sourceCode[j] === '\\n') {\n                newlineCount++;\n            }\n        }\n\n        for (j = 1; j < newlineCount; j++) {\n            result.push(newline);\n        }\n    }\n\n    function parenthesize(text, current, should) {\n        if (current < should) {\n            return ['(', text, ')'];\n        }\n        return text;\n    }\n\n    function generateVerbatimString(string) {\n        var i, iz, result;\n        result = string.split(/\\r\\n|\\n/);\n        for (i = 1, iz = result.length; i < iz; i++) {\n            result[i] = newline + base + result[i];\n        }\n        return result;\n    }\n\n    function generateVerbatim(expr, precedence) {\n        var verbatim, result, prec;\n        verbatim = expr[extra.verbatim];\n\n        if (typeof verbatim === 'string') {\n            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);\n        } else {\n            // verbatim is object\n            result = generateVerbatimString(verbatim.content);\n            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;\n            result = parenthesize(result, prec, precedence);\n        }\n\n        return toSourceNodeWhenNeeded(result, expr);\n    }\n\n    function CodeGenerator() {\n    }\n\n    // Helpers.\n\n    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {\n        var result, noLeadingComment, that = this;\n\n        noLeadingComment = !extra.comment || !stmt.leadingComments;\n\n        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n            return [space, this.generateStatement(stmt, flags)];\n        }\n\n        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n            return ';';\n        }\n\n        withIndent(function () {\n            result = [\n                newline,\n                addIndent(that.generateStatement(stmt, flags))\n            ];\n        });\n\n        return result;\n    };\n\n    CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {\n        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\n            return [result, space];\n        }\n        if (ends) {\n            return [result, base];\n        }\n        return [result, newline, base];\n    };\n\n    function generateIdentifier(node) {\n        return toSourceNodeWhenNeeded(node.name, node);\n    }\n\n    function generateAsyncPrefix(node, spaceRequired) {\n        return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';\n    }\n\n    function generateStarSuffix(node) {\n        var isGenerator = node.generator && !extra.moz.starlessGenerator;\n        return isGenerator ? '*' + space : '';\n    }\n\n    function generateMethodPrefix(prop) {\n        var func = prop.value, prefix = '';\n        if (func.async) {\n            prefix += generateAsyncPrefix(func, !prop.computed);\n        }\n        if (func.generator) {\n            // avoid space before method name\n            prefix += generateStarSuffix(func) ? '*' : '';\n        }\n        return prefix;\n    }\n\n    CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {\n        if (node.type === Syntax.Identifier) {\n            return generateIdentifier(node);\n        }\n        return this.generateExpression(node, precedence, flags);\n    };\n\n    CodeGenerator.prototype.generateFunctionParams = function (node) {\n        var i, iz, result, hasDefault;\n\n        hasDefault = false;\n\n        if (node.type === Syntax.ArrowFunctionExpression &&\n                !node.rest && (!node.defaults || node.defaults.length === 0) &&\n                node.params.length === 1 && node.params[0].type === Syntax.Identifier) {\n            // arg => { } case\n            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];\n        } else {\n            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];\n            result.push('(');\n            if (node.defaults) {\n                hasDefault = true;\n            }\n            for (i = 0, iz = node.params.length; i < iz; ++i) {\n                if (hasDefault && node.defaults[i]) {\n                    // Handle default values.\n                    result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));\n                } else {\n                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));\n                }\n                if (i + 1 < iz) {\n                    result.push(',' + space);\n                }\n            }\n\n            if (node.rest) {\n                if (node.params.length) {\n                    result.push(',' + space);\n                }\n                result.push('...');\n                result.push(generateIdentifier(node.rest));\n            }\n\n            result.push(')');\n        }\n\n        return result;\n    };\n\n    CodeGenerator.prototype.generateFunctionBody = function (node) {\n        var result, expr;\n\n        result = this.generateFunctionParams(node);\n\n        if (node.type === Syntax.ArrowFunctionExpression) {\n            result.push(space);\n            result.push('=>');\n        }\n\n        if (node.expression) {\n            result.push(space);\n            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);\n            if (expr.toString().charAt(0) === '{') {\n                expr = ['(', expr, ')'];\n            }\n            result.push(expr);\n        } else {\n            result.push(this.maybeBlock(node.body, S_TTFF));\n        }\n\n        return result;\n    };\n\n    CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {\n        var result = ['for' + (stmt.await ? noEmptySpace() + 'await' : '') + space + '('], that = this;\n        withIndent(function () {\n            if (stmt.left.type === Syntax.VariableDeclaration) {\n                withIndent(function () {\n                    result.push(stmt.left.kind + noEmptySpace());\n                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));\n                });\n            } else {\n                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));\n            }\n\n            result = join(result, operator);\n            result = [join(\n                result,\n                that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)\n            ), ')'];\n        });\n        result.push(this.maybeBlock(stmt.body, flags));\n        return result;\n    };\n\n    CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {\n        var result = [];\n\n        if (computed) {\n            result.push('[');\n        }\n\n        result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));\n\n        if (computed) {\n            result.push(']');\n        }\n\n        return result;\n    };\n\n    CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {\n        if (Precedence.Assignment < precedence) {\n            flags |= F_ALLOW_IN;\n        }\n\n        return parenthesize(\n            [\n                this.generateExpression(left, Precedence.Call, flags),\n                space + operator + space,\n                this.generateExpression(right, Precedence.Assignment, flags)\n            ],\n            Precedence.Assignment,\n            precedence\n        );\n    };\n\n    CodeGenerator.prototype.semicolon = function (flags) {\n        if (!semicolons && flags & F_SEMICOLON_OPT) {\n            return '';\n        }\n        return ';';\n    };\n\n    // Statements.\n\n    CodeGenerator.Statement = {\n\n        BlockStatement: function (stmt, flags) {\n            var range, content, result = ['{', newline], that = this;\n\n            withIndent(function () {\n                // handle functions without any code\n                if (stmt.body.length === 0 && preserveBlankLines) {\n                    range = stmt.range;\n                    if (range[1] - range[0] > 2) {\n                        content = sourceCode.substring(range[0] + 1, range[1] - 1);\n                        if (content[0] === '\\n') {\n                            result = ['{'];\n                        }\n                        result.push(content);\n                    }\n                }\n\n                var i, iz, fragment, bodyFlags;\n                bodyFlags = S_TFFF;\n                if (flags & F_FUNC_BODY) {\n                    bodyFlags |= F_DIRECTIVE_CTX;\n                }\n\n                for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n                    if (preserveBlankLines) {\n                        // handle spaces before the first line\n                        if (i === 0) {\n                            if (stmt.body[0].leadingComments) {\n                                range = stmt.body[0].leadingComments[0].extendedRange;\n                                content = sourceCode.substring(range[0], range[1]);\n                                if (content[0] === '\\n') {\n                                    result = ['{'];\n                                }\n                            }\n                            if (!stmt.body[0].leadingComments) {\n                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);\n                            }\n                        }\n\n                        // handle spaces between lines\n                        if (i > 0) {\n                            if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {\n                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n                            }\n                        }\n                    }\n\n                    if (i === iz - 1) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n\n                    if (stmt.body[i].leadingComments && preserveBlankLines) {\n                        fragment = that.generateStatement(stmt.body[i], bodyFlags);\n                    } else {\n                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));\n                    }\n\n                    result.push(fragment);\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        if (preserveBlankLines && i < iz - 1) {\n                            // don't add a new line if there are leading coments\n                            // in the next statement\n                            if (!stmt.body[i + 1].leadingComments) {\n                                result.push(newline);\n                            }\n                        } else {\n                            result.push(newline);\n                        }\n                    }\n\n                    if (preserveBlankLines) {\n                        // handle spaces after the last line\n                        if (i === iz - 1) {\n                            if (!stmt.body[i].trailingComments) {\n                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n                            }\n                        }\n                    }\n                }\n            });\n\n            result.push(addIndent('}'));\n            return result;\n        },\n\n        BreakStatement: function (stmt, flags) {\n            if (stmt.label) {\n                return 'break ' + stmt.label.name + this.semicolon(flags);\n            }\n            return 'break' + this.semicolon(flags);\n        },\n\n        ContinueStatement: function (stmt, flags) {\n            if (stmt.label) {\n                return 'continue ' + stmt.label.name + this.semicolon(flags);\n            }\n            return 'continue' + this.semicolon(flags);\n        },\n\n        ClassBody: function (stmt, flags) {\n            var result = [ '{', newline], that = this;\n\n            withIndent(function (indent) {\n                var i, iz;\n\n                for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n                    result.push(indent);\n                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(newline);\n                    }\n                }\n            });\n\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(base);\n            result.push('}');\n            return result;\n        },\n\n        ClassDeclaration: function (stmt, flags) {\n            var result, fragment;\n            result  = ['class'];\n            if (stmt.id) {\n                result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));\n            }\n            if (stmt.superClass) {\n                fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));\n                result = join(result, fragment);\n            }\n            result.push(space);\n            result.push(this.generateStatement(stmt.body, S_TFFT));\n            return result;\n        },\n\n        DirectiveStatement: function (stmt, flags) {\n            if (extra.raw && stmt.raw) {\n                return stmt.raw + this.semicolon(flags);\n            }\n            return escapeDirective(stmt.directive) + this.semicolon(flags);\n        },\n\n        DoWhileStatement: function (stmt, flags) {\n            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\n            var result = join('do', this.maybeBlock(stmt.body, S_TFFF));\n            result = this.maybeBlockSuffix(stmt.body, result);\n            return join(result, [\n                'while' + space + '(',\n                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                ')' + this.semicolon(flags)\n            ]);\n        },\n\n        CatchClause: function (stmt, flags) {\n            var result, that = this;\n            withIndent(function () {\n                var guard;\n\n                if (stmt.param) {\n                    result = [\n                        'catch' + space + '(',\n                        that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),\n                        ')'\n                    ];\n\n                    if (stmt.guard) {\n                        guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);\n                        result.splice(2, 0, ' if ', guard);\n                    }\n                } else {\n                    result = ['catch'];\n                }\n            });\n            result.push(this.maybeBlock(stmt.body, S_TFFF));\n            return result;\n        },\n\n        DebuggerStatement: function (stmt, flags) {\n            return 'debugger' + this.semicolon(flags);\n        },\n\n        EmptyStatement: function (stmt, flags) {\n            return ';';\n        },\n\n        ExportDefaultDeclaration: function (stmt, flags) {\n            var result = [ 'export' ], bodyFlags;\n\n            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;\n\n            // export default HoistableDeclaration[Default]\n            // export default AssignmentExpression[In] ;\n            result = join(result, 'default');\n            if (isStatement(stmt.declaration)) {\n                result = join(result, this.generateStatement(stmt.declaration, bodyFlags));\n            } else {\n                result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));\n            }\n            return result;\n        },\n\n        ExportNamedDeclaration: function (stmt, flags) {\n            var result = [ 'export' ], bodyFlags, that = this;\n\n            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;\n\n            // export VariableStatement\n            // export Declaration[Default]\n            if (stmt.declaration) {\n                return join(result, this.generateStatement(stmt.declaration, bodyFlags));\n            }\n\n            // export ExportClause[NoReference] FromClause ;\n            // export ExportClause ;\n            if (stmt.specifiers) {\n                if (stmt.specifiers.length === 0) {\n                    result = join(result, '{' + space + '}');\n                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {\n                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));\n                } else {\n                    result = join(result, '{');\n                    withIndent(function (indent) {\n                        var i, iz;\n                        result.push(newline);\n                        for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {\n                            result.push(indent);\n                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                            if (i + 1 < iz) {\n                                result.push(',' + newline);\n                            }\n                        }\n                    });\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                        result.push(newline);\n                    }\n                    result.push(base + '}');\n                }\n\n                if (stmt.source) {\n                    result = join(result, [\n                        'from' + space,\n                        // ModuleSpecifier\n                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                        this.semicolon(flags)\n                    ]);\n                } else {\n                    result.push(this.semicolon(flags));\n                }\n            }\n            return result;\n        },\n\n        ExportAllDeclaration: function (stmt, flags) {\n            // export * FromClause ;\n            return [\n                'export' + space,\n                '*' + space,\n                'from' + space,\n                // ModuleSpecifier\n                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                this.semicolon(flags)\n            ];\n        },\n\n        ExpressionStatement: function (stmt, flags) {\n            var result, fragment;\n\n            function isClassPrefixed(fragment) {\n                var code;\n                if (fragment.slice(0, 5) !== 'class') {\n                    return false;\n                }\n                code = fragment.charCodeAt(5);\n                return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);\n            }\n\n            function isFunctionPrefixed(fragment) {\n                var code;\n                if (fragment.slice(0, 8) !== 'function') {\n                    return false;\n                }\n                code = fragment.charCodeAt(8);\n                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);\n            }\n\n            function isAsyncPrefixed(fragment) {\n                var code, i, iz;\n                if (fragment.slice(0, 5) !== 'async') {\n                    return false;\n                }\n                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {\n                    return false;\n                }\n                for (i = 6, iz = fragment.length; i < iz; ++i) {\n                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {\n                        break;\n                    }\n                }\n                if (i === iz) {\n                    return false;\n                }\n                if (fragment.slice(i, i + 8) !== 'function') {\n                    return false;\n                }\n                code = fragment.charCodeAt(i + 8);\n                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);\n            }\n\n            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];\n            // 12.4 '{', 'function', 'class' is not allowed in this position.\n            // wrap expression with parentheses\n            fragment = toSourceNodeWhenNeeded(result).toString();\n            if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression\n                    isClassPrefixed(fragment) ||\n                    isFunctionPrefixed(fragment) ||\n                    isAsyncPrefixed(fragment) ||\n                    (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {\n                result = ['(', result, ')' + this.semicolon(flags)];\n            } else {\n                result.push(this.semicolon(flags));\n            }\n            return result;\n        },\n\n        ImportDeclaration: function (stmt, flags) {\n            // ES6: 15.2.1 valid import declarations:\n            //     - import ImportClause FromClause ;\n            //     - import ModuleSpecifier ;\n            var result, cursor, that = this;\n\n            // If no ImportClause is present,\n            // this should be `import ModuleSpecifier` so skip `from`\n            // ModuleSpecifier is StringLiteral.\n            if (stmt.specifiers.length === 0) {\n                // import ModuleSpecifier ;\n                return [\n                    'import',\n                    space,\n                    // ModuleSpecifier\n                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                    this.semicolon(flags)\n                ];\n            }\n\n            // import ImportClause FromClause ;\n            result = [\n                'import'\n            ];\n            cursor = 0;\n\n            // ImportedBinding\n            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {\n                result = join(result, [\n                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\n                ]);\n                ++cursor;\n            }\n\n            if (stmt.specifiers[cursor]) {\n                if (cursor !== 0) {\n                    result.push(',');\n                }\n\n                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {\n                    // NameSpaceImport\n                    result = join(result, [\n                            space,\n                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\n                    ]);\n                } else {\n                    // NamedImports\n                    result.push(space + '{');\n\n                    if ((stmt.specifiers.length - cursor) === 1) {\n                        // import { ... } from \"...\";\n                        result.push(space);\n                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));\n                        result.push(space + '}' + space);\n                    } else {\n                        // import {\n                        //    ...,\n                        //    ...,\n                        // } from \"...\";\n                        withIndent(function (indent) {\n                            var i, iz;\n                            result.push(newline);\n                            for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {\n                                result.push(indent);\n                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                                if (i + 1 < iz) {\n                                    result.push(',' + newline);\n                                }\n                            }\n                        });\n                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                            result.push(newline);\n                        }\n                        result.push(base + '}' + space);\n                    }\n                }\n            }\n\n            result = join(result, [\n                'from' + space,\n                // ModuleSpecifier\n                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                this.semicolon(flags)\n            ]);\n            return result;\n        },\n\n        VariableDeclarator: function (stmt, flags) {\n            var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;\n            if (stmt.init) {\n                return [\n                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),\n                    space,\n                    '=',\n                    space,\n                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)\n                ];\n            }\n            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);\n        },\n\n        VariableDeclaration: function (stmt, flags) {\n            // VariableDeclarator is typed as Statement,\n            // but joined with comma (not LineTerminator).\n            // So if comment is attached to target node, we should specialize.\n            var result, i, iz, node, bodyFlags, that = this;\n\n            result = [ stmt.kind ];\n\n            bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;\n\n            function block() {\n                node = stmt.declarations[0];\n                if (extra.comment && node.leadingComments) {\n                    result.push('\\n');\n                    result.push(addIndent(that.generateStatement(node, bodyFlags)));\n                } else {\n                    result.push(noEmptySpace());\n                    result.push(that.generateStatement(node, bodyFlags));\n                }\n\n                for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {\n                    node = stmt.declarations[i];\n                    if (extra.comment && node.leadingComments) {\n                        result.push(',' + newline);\n                        result.push(addIndent(that.generateStatement(node, bodyFlags)));\n                    } else {\n                        result.push(',' + space);\n                        result.push(that.generateStatement(node, bodyFlags));\n                    }\n                }\n            }\n\n            if (stmt.declarations.length > 1) {\n                withIndent(block);\n            } else {\n                block();\n            }\n\n            result.push(this.semicolon(flags));\n\n            return result;\n        },\n\n        ThrowStatement: function (stmt, flags) {\n            return [join(\n                'throw',\n                this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)\n            ), this.semicolon(flags)];\n        },\n\n        TryStatement: function (stmt, flags) {\n            var result, i, iz, guardedHandlers;\n\n            result = ['try', this.maybeBlock(stmt.block, S_TFFF)];\n            result = this.maybeBlockSuffix(stmt.block, result);\n\n            if (stmt.handlers) {\n                // old interface\n                for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {\n                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));\n                    if (stmt.finalizer || i + 1 !== iz) {\n                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);\n                    }\n                }\n            } else {\n                guardedHandlers = stmt.guardedHandlers || [];\n\n                for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {\n                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));\n                    if (stmt.finalizer || i + 1 !== iz) {\n                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);\n                    }\n                }\n\n                // new interface\n                if (stmt.handler) {\n                    if (Array.isArray(stmt.handler)) {\n                        for (i = 0, iz = stmt.handler.length; i < iz; ++i) {\n                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));\n                            if (stmt.finalizer || i + 1 !== iz) {\n                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);\n                            }\n                        }\n                    } else {\n                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));\n                        if (stmt.finalizer) {\n                            result = this.maybeBlockSuffix(stmt.handler.body, result);\n                        }\n                    }\n                }\n            }\n            if (stmt.finalizer) {\n                result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);\n            }\n            return result;\n        },\n\n        SwitchStatement: function (stmt, flags) {\n            var result, fragment, i, iz, bodyFlags, that = this;\n            withIndent(function () {\n                result = [\n                    'switch' + space + '(',\n                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),\n                    ')' + space + '{' + newline\n                ];\n            });\n            if (stmt.cases) {\n                bodyFlags = S_TFFF;\n                for (i = 0, iz = stmt.cases.length; i < iz; ++i) {\n                    if (i === iz - 1) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));\n                    result.push(fragment);\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            }\n            result.push(addIndent('}'));\n            return result;\n        },\n\n        SwitchCase: function (stmt, flags) {\n            var result, fragment, i, iz, bodyFlags, that = this;\n            withIndent(function () {\n                if (stmt.test) {\n                    result = [\n                        join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),\n                        ':'\n                    ];\n                } else {\n                    result = ['default:'];\n                }\n\n                i = 0;\n                iz = stmt.consequent.length;\n                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {\n                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);\n                    result.push(fragment);\n                    i = 1;\n                }\n\n                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                    result.push(newline);\n                }\n\n                bodyFlags = S_TFFF;\n                for (; i < iz; ++i) {\n                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));\n                    result.push(fragment);\n                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            });\n            return result;\n        },\n\n        IfStatement: function (stmt, flags) {\n            var result, bodyFlags, semicolonOptional, that = this;\n            withIndent(function () {\n                result = [\n                    'if' + space + '(',\n                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                    ')'\n                ];\n            });\n            semicolonOptional = flags & F_SEMICOLON_OPT;\n            bodyFlags = S_TFFF;\n            if (semicolonOptional) {\n                bodyFlags |= F_SEMICOLON_OPT;\n            }\n            if (stmt.alternate) {\n                result.push(this.maybeBlock(stmt.consequent, S_TFFF));\n                result = this.maybeBlockSuffix(stmt.consequent, result);\n                if (stmt.alternate.type === Syntax.IfStatement) {\n                    result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);\n                } else {\n                    result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));\n                }\n            } else {\n                result.push(this.maybeBlock(stmt.consequent, bodyFlags));\n            }\n            return result;\n        },\n\n        ForStatement: function (stmt, flags) {\n            var result, that = this;\n            withIndent(function () {\n                result = ['for' + space + '('];\n                if (stmt.init) {\n                    if (stmt.init.type === Syntax.VariableDeclaration) {\n                        result.push(that.generateStatement(stmt.init, S_FFFF));\n                    } else {\n                        // F_ALLOW_IN becomes false.\n                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));\n                        result.push(';');\n                    }\n                } else {\n                    result.push(';');\n                }\n\n                if (stmt.test) {\n                    result.push(space);\n                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));\n                    result.push(';');\n                } else {\n                    result.push(';');\n                }\n\n                if (stmt.update) {\n                    result.push(space);\n                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));\n                    result.push(')');\n                } else {\n                    result.push(')');\n                }\n            });\n\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        },\n\n        ForInStatement: function (stmt, flags) {\n            return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n        },\n\n        ForOfStatement: function (stmt, flags) {\n            return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n        },\n\n        LabeledStatement: function (stmt, flags) {\n            return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];\n        },\n\n        Program: function (stmt, flags) {\n            var result, fragment, i, iz, bodyFlags;\n            iz = stmt.body.length;\n            result = [safeConcatenation && iz > 0 ? '\\n' : ''];\n            bodyFlags = S_TFTF;\n            for (i = 0; i < iz; ++i) {\n                if (!safeConcatenation && i === iz - 1) {\n                    bodyFlags |= F_SEMICOLON_OPT;\n                }\n\n                if (preserveBlankLines) {\n                    // handle spaces before the first line\n                    if (i === 0) {\n                        if (!stmt.body[0].leadingComments) {\n                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);\n                        }\n                    }\n\n                    // handle spaces between lines\n                    if (i > 0) {\n                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n                        }\n                    }\n                }\n\n                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));\n                result.push(fragment);\n                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                    if (preserveBlankLines) {\n                        if (!stmt.body[i + 1].leadingComments) {\n                            result.push(newline);\n                        }\n                    } else {\n                        result.push(newline);\n                    }\n                }\n\n                if (preserveBlankLines) {\n                    // handle spaces after the last line\n                    if (i === iz - 1) {\n                        if (!stmt.body[i].trailingComments) {\n                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n                        }\n                    }\n                }\n            }\n            return result;\n        },\n\n        FunctionDeclaration: function (stmt, flags) {\n            return [\n                generateAsyncPrefix(stmt, true),\n                'function',\n                generateStarSuffix(stmt) || noEmptySpace(),\n                stmt.id ? generateIdentifier(stmt.id) : '',\n                this.generateFunctionBody(stmt)\n            ];\n        },\n\n        ReturnStatement: function (stmt, flags) {\n            if (stmt.argument) {\n                return [join(\n                    'return',\n                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)\n                ), this.semicolon(flags)];\n            }\n            return ['return' + this.semicolon(flags)];\n        },\n\n        WhileStatement: function (stmt, flags) {\n            var result, that = this;\n            withIndent(function () {\n                result = [\n                    'while' + space + '(',\n                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                    ')'\n                ];\n            });\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        },\n\n        WithStatement: function (stmt, flags) {\n            var result, that = this;\n            withIndent(function () {\n                result = [\n                    'with' + space + '(',\n                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),\n                    ')'\n                ];\n            });\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        }\n\n    };\n\n    merge(CodeGenerator.prototype, CodeGenerator.Statement);\n\n    // Expressions.\n\n    CodeGenerator.Expression = {\n\n        SequenceExpression: function (expr, precedence, flags) {\n            var result, i, iz;\n            if (Precedence.Sequence < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n            result = [];\n            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {\n                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));\n                if (i + 1 < iz) {\n                    result.push(',' + space);\n                }\n            }\n            return parenthesize(result, Precedence.Sequence, precedence);\n        },\n\n        AssignmentExpression: function (expr, precedence, flags) {\n            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);\n        },\n\n        ArrowFunctionExpression: function (expr, precedence, flags) {\n            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);\n        },\n\n        ConditionalExpression: function (expr, precedence, flags) {\n            if (Precedence.Conditional < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n            return parenthesize(\n                [\n                    this.generateExpression(expr.test, Precedence.LogicalOR, flags),\n                    space + '?' + space,\n                    this.generateExpression(expr.consequent, Precedence.Assignment, flags),\n                    space + ':' + space,\n                    this.generateExpression(expr.alternate, Precedence.Assignment, flags)\n                ],\n                Precedence.Conditional,\n                precedence\n            );\n        },\n\n        LogicalExpression: function (expr, precedence, flags) {\n            return this.BinaryExpression(expr, precedence, flags);\n        },\n\n        BinaryExpression: function (expr, precedence, flags) {\n            var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;\n            currentPrecedence = BinaryPrecedence[expr.operator];\n            leftPrecedence = expr.operator === '**' ? Precedence.Postfix : currentPrecedence;\n            rightPrecedence = expr.operator === '**' ? currentPrecedence : currentPrecedence + 1;\n\n            if (currentPrecedence < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n\n            fragment = this.generateExpression(expr.left, leftPrecedence, flags);\n\n            leftSource = fragment.toString();\n\n            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {\n                result = [fragment, noEmptySpace(), expr.operator];\n            } else {\n                result = join(fragment, expr.operator);\n            }\n\n            fragment = this.generateExpression(expr.right, rightPrecedence, flags);\n\n            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||\n            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {\n                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start\n                result.push(noEmptySpace());\n                result.push(fragment);\n            } else {\n                result = join(result, fragment);\n            }\n\n            if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {\n                return ['(', result, ')'];\n            }\n            return parenthesize(result, currentPrecedence, precedence);\n        },\n\n        CallExpression: function (expr, precedence, flags) {\n            var result, i, iz;\n            // F_ALLOW_UNPARATH_NEW becomes false.\n            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];\n            result.push('(');\n            for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {\n                result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n                if (i + 1 < iz) {\n                    result.push(',' + space);\n                }\n            }\n            result.push(')');\n\n            if (!(flags & F_ALLOW_CALL)) {\n                return ['(', result, ')'];\n            }\n            return parenthesize(result, Precedence.Call, precedence);\n        },\n\n        NewExpression: function (expr, precedence, flags) {\n            var result, length, i, iz, itemFlags;\n            length = expr['arguments'].length;\n\n            // F_ALLOW_CALL becomes false.\n            // F_ALLOW_UNPARATH_NEW may become false.\n            itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;\n\n            result = join(\n                'new',\n                this.generateExpression(expr.callee, Precedence.New, itemFlags)\n            );\n\n            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {\n                result.push('(');\n                for (i = 0, iz = length; i < iz; ++i) {\n                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(',' + space);\n                    }\n                }\n                result.push(')');\n            }\n\n            return parenthesize(result, Precedence.New, precedence);\n        },\n\n        MemberExpression: function (expr, precedence, flags) {\n            var result, fragment;\n\n            // F_ALLOW_UNPARATH_NEW becomes false.\n            result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];\n\n            if (expr.computed) {\n                result.push('[');\n                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));\n                result.push(']');\n            } else {\n                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {\n                    fragment = toSourceNodeWhenNeeded(result).toString();\n                    // When the following conditions are all true,\n                    //   1. No floating point\n                    //   2. Don't have exponents\n                    //   3. The last character is a decimal digit\n                    //   4. Not hexadecimal OR octal number literal\n                    // we should add a floating point.\n                    if (\n                            fragment.indexOf('.') < 0 &&\n                            !/[eExX]/.test(fragment) &&\n                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&\n                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'\n                            ) {\n                        result.push(' ');\n                    }\n                }\n                result.push('.');\n                result.push(generateIdentifier(expr.property));\n            }\n\n            return parenthesize(result, Precedence.Member, precedence);\n        },\n\n        MetaProperty: function (expr, precedence, flags) {\n            var result;\n            result = [];\n            result.push(typeof expr.meta === \"string\" ? expr.meta : generateIdentifier(expr.meta));\n            result.push('.');\n            result.push(typeof expr.property === \"string\" ? expr.property : generateIdentifier(expr.property));\n            return parenthesize(result, Precedence.Member, precedence);\n        },\n\n        UnaryExpression: function (expr, precedence, flags) {\n            var result, fragment, rightCharCode, leftSource, leftCharCode;\n            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);\n\n            if (space === '') {\n                result = join(expr.operator, fragment);\n            } else {\n                result = [expr.operator];\n                if (expr.operator.length > 2) {\n                    // delete, void, typeof\n                    // get `typeof []`, not `typeof[]`\n                    result = join(result, fragment);\n                } else {\n                    // Prevent inserting spaces between operator and argument if it is unnecessary\n                    // like, `!cond`\n                    leftSource = toSourceNodeWhenNeeded(result).toString();\n                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n                    rightCharCode = fragment.toString().charCodeAt(0);\n\n                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||\n                            (esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode))) {\n                        result.push(noEmptySpace());\n                        result.push(fragment);\n                    } else {\n                        result.push(fragment);\n                    }\n                }\n            }\n            return parenthesize(result, Precedence.Unary, precedence);\n        },\n\n        YieldExpression: function (expr, precedence, flags) {\n            var result;\n            if (expr.delegate) {\n                result = 'yield*';\n            } else {\n                result = 'yield';\n            }\n            if (expr.argument) {\n                result = join(\n                    result,\n                    this.generateExpression(expr.argument, Precedence.Yield, E_TTT)\n                );\n            }\n            return parenthesize(result, Precedence.Yield, precedence);\n        },\n\n        AwaitExpression: function (expr, precedence, flags) {\n            var result = join(\n                expr.all ? 'await*' : 'await',\n                this.generateExpression(expr.argument, Precedence.Await, E_TTT)\n            );\n            return parenthesize(result, Precedence.Await, precedence);\n        },\n\n        UpdateExpression: function (expr, precedence, flags) {\n            if (expr.prefix) {\n                return parenthesize(\n                    [\n                        expr.operator,\n                        this.generateExpression(expr.argument, Precedence.Unary, E_TTT)\n                    ],\n                    Precedence.Unary,\n                    precedence\n                );\n            }\n            return parenthesize(\n                [\n                    this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),\n                    expr.operator\n                ],\n                Precedence.Postfix,\n                precedence\n            );\n        },\n\n        FunctionExpression: function (expr, precedence, flags) {\n            var result = [\n                generateAsyncPrefix(expr, true),\n                'function'\n            ];\n            if (expr.id) {\n                result.push(generateStarSuffix(expr) || noEmptySpace());\n                result.push(generateIdentifier(expr.id));\n            } else {\n                result.push(generateStarSuffix(expr) || space);\n            }\n            result.push(this.generateFunctionBody(expr));\n            return result;\n        },\n\n        ArrayPattern: function (expr, precedence, flags) {\n            return this.ArrayExpression(expr, precedence, flags, true);\n        },\n\n        ArrayExpression: function (expr, precedence, flags, isPattern) {\n            var result, multiline, that = this;\n            if (!expr.elements.length) {\n                return '[]';\n            }\n            multiline = isPattern ? false : expr.elements.length > 1;\n            result = ['[', multiline ? newline : ''];\n            withIndent(function (indent) {\n                var i, iz;\n                for (i = 0, iz = expr.elements.length; i < iz; ++i) {\n                    if (!expr.elements[i]) {\n                        if (multiline) {\n                            result.push(indent);\n                        }\n                        if (i + 1 === iz) {\n                            result.push(',');\n                        }\n                    } else {\n                        result.push(multiline ? indent : '');\n                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));\n                    }\n                    if (i + 1 < iz) {\n                        result.push(',' + (multiline ? newline : space));\n                    }\n                }\n            });\n            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(multiline ? base : '');\n            result.push(']');\n            return result;\n        },\n\n        RestElement: function(expr, precedence, flags) {\n            return '...' + this.generatePattern(expr.argument);\n        },\n\n        ClassExpression: function (expr, precedence, flags) {\n            var result, fragment;\n            result = ['class'];\n            if (expr.id) {\n                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));\n            }\n            if (expr.superClass) {\n                fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));\n                result = join(result, fragment);\n            }\n            result.push(space);\n            result.push(this.generateStatement(expr.body, S_TFFT));\n            return result;\n        },\n\n        MethodDefinition: function (expr, precedence, flags) {\n            var result, fragment;\n            if (expr['static']) {\n                result = ['static' + space];\n            } else {\n                result = [];\n            }\n            if (expr.kind === 'get' || expr.kind === 'set') {\n                fragment = [\n                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),\n                    this.generateFunctionBody(expr.value)\n                ];\n            } else {\n                fragment = [\n                    generateMethodPrefix(expr),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n            return join(result, fragment);\n        },\n\n        Property: function (expr, precedence, flags) {\n            if (expr.kind === 'get' || expr.kind === 'set') {\n                return [\n                    expr.kind, noEmptySpace(),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n\n            if (expr.shorthand) {\n                if (expr.value.type === \"AssignmentPattern\") {\n                    return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);\n                }\n                return this.generatePropertyKey(expr.key, expr.computed);\n            }\n\n            if (expr.method) {\n                return [\n                    generateMethodPrefix(expr),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n\n            return [\n                this.generatePropertyKey(expr.key, expr.computed),\n                ':' + space,\n                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)\n            ];\n        },\n\n        ObjectExpression: function (expr, precedence, flags) {\n            var multiline, result, fragment, that = this;\n\n            if (!expr.properties.length) {\n                return '{}';\n            }\n            multiline = expr.properties.length > 1;\n\n            withIndent(function () {\n                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);\n            });\n\n            if (!multiline) {\n                // issues 4\n                // Do not transform from\n                //   dejavu.Class.declare({\n                //       method2: function () {}\n                //   });\n                // to\n                //   dejavu.Class.declare({method2: function () {\n                //       }});\n                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                    return [ '{', space, fragment, space, '}' ];\n                }\n            }\n\n            withIndent(function (indent) {\n                var i, iz;\n                result = [ '{', newline, indent, fragment ];\n\n                if (multiline) {\n                    result.push(',' + newline);\n                    for (i = 1, iz = expr.properties.length; i < iz; ++i) {\n                        result.push(indent);\n                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n                        if (i + 1 < iz) {\n                            result.push(',' + newline);\n                        }\n                    }\n                }\n            });\n\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(base);\n            result.push('}');\n            return result;\n        },\n\n        AssignmentPattern: function(expr, precedence, flags) {\n            return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);\n        },\n\n        ObjectPattern: function (expr, precedence, flags) {\n            var result, i, iz, multiline, property, that = this;\n            if (!expr.properties.length) {\n                return '{}';\n            }\n\n            multiline = false;\n            if (expr.properties.length === 1) {\n                property = expr.properties[0];\n                if (\n                    property.type === Syntax.Property\n                    && property.value.type !== Syntax.Identifier\n                ) {\n                    multiline = true;\n                }\n            } else {\n                for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n                    property = expr.properties[i];\n                    if (\n                        property.type === Syntax.Property\n                        && !property.shorthand\n                    ) {\n                        multiline = true;\n                        break;\n                    }\n                }\n            }\n            result = ['{', multiline ? newline : '' ];\n\n            withIndent(function (indent) {\n                var i, iz;\n                for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n                    result.push(multiline ? indent : '');\n                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(',' + (multiline ? newline : space));\n                    }\n                }\n            });\n\n            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(multiline ? base : '');\n            result.push('}');\n            return result;\n        },\n\n        ThisExpression: function (expr, precedence, flags) {\n            return 'this';\n        },\n\n        Super: function (expr, precedence, flags) {\n            return 'super';\n        },\n\n        Identifier: function (expr, precedence, flags) {\n            return generateIdentifier(expr);\n        },\n\n        ImportDefaultSpecifier: function (expr, precedence, flags) {\n            return generateIdentifier(expr.id || expr.local);\n        },\n\n        ImportNamespaceSpecifier: function (expr, precedence, flags) {\n            var result = ['*'];\n            var id = expr.id || expr.local;\n            if (id) {\n                result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));\n            }\n            return result;\n        },\n\n        ImportSpecifier: function (expr, precedence, flags) {\n            var imported = expr.imported;\n            var result = [ imported.name ];\n            var local = expr.local;\n            if (local && local.name !== imported.name) {\n                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));\n            }\n            return result;\n        },\n\n        ExportSpecifier: function (expr, precedence, flags) {\n            var local = expr.local;\n            var result = [ local.name ];\n            var exported = expr.exported;\n            if (exported && exported.name !== local.name) {\n                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));\n            }\n            return result;\n        },\n\n        Literal: function (expr, precedence, flags) {\n            var raw;\n            if (expr.hasOwnProperty('raw') && parse && extra.raw) {\n                try {\n                    raw = parse(expr.raw).body[0].expression;\n                    if (raw.type === Syntax.Literal) {\n                        if (raw.value === expr.value) {\n                            return expr.raw;\n                        }\n                    }\n                } catch (e) {\n                    // not use raw property\n                }\n            }\n\n            if (expr.regex) {\n              return '/' + expr.regex.pattern + '/' + expr.regex.flags;\n            }\n\n            if (expr.value === null) {\n                return 'null';\n            }\n\n            if (typeof expr.value === 'string') {\n                return escapeString(expr.value);\n            }\n\n            if (typeof expr.value === 'number') {\n                return generateNumber(expr.value);\n            }\n\n            if (typeof expr.value === 'boolean') {\n                return expr.value ? 'true' : 'false';\n            }\n\n            return generateRegExp(expr.value);\n        },\n\n        GeneratorExpression: function (expr, precedence, flags) {\n            return this.ComprehensionExpression(expr, precedence, flags);\n        },\n\n        ComprehensionExpression: function (expr, precedence, flags) {\n            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]\n            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6\n\n            var result, i, iz, fragment, that = this;\n            result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];\n\n            if (extra.moz.comprehensionExpressionStartsWithAssignment) {\n                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n                result.push(fragment);\n            }\n\n            if (expr.blocks) {\n                withIndent(function () {\n                    for (i = 0, iz = expr.blocks.length; i < iz; ++i) {\n                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);\n                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {\n                            result = join(result, fragment);\n                        } else {\n                            result.push(fragment);\n                        }\n                    }\n                });\n            }\n\n            if (expr.filter) {\n                result = join(result, 'if' + space);\n                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);\n                result = join(result, [ '(', fragment, ')' ]);\n            }\n\n            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {\n                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n\n                result = join(result, fragment);\n            }\n\n            result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');\n            return result;\n        },\n\n        ComprehensionBlock: function (expr, precedence, flags) {\n            var fragment;\n            if (expr.left.type === Syntax.VariableDeclaration) {\n                fragment = [\n                    expr.left.kind, noEmptySpace(),\n                    this.generateStatement(expr.left.declarations[0], S_FFFF)\n                ];\n            } else {\n                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);\n            }\n\n            fragment = join(fragment, expr.of ? 'of' : 'in');\n            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));\n\n            return [ 'for' + space + '(', fragment, ')' ];\n        },\n\n        SpreadElement: function (expr, precedence, flags) {\n            return [\n                '...',\n                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)\n            ];\n        },\n\n        TaggedTemplateExpression: function (expr, precedence, flags) {\n            var itemFlags = E_TTF;\n            if (!(flags & F_ALLOW_CALL)) {\n                itemFlags = E_TFF;\n            }\n            var result = [\n                this.generateExpression(expr.tag, Precedence.Call, itemFlags),\n                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)\n            ];\n            return parenthesize(result, Precedence.TaggedTemplate, precedence);\n        },\n\n        TemplateElement: function (expr, precedence, flags) {\n            // Don't use \"cooked\". Since tagged template can use raw template\n            // representation. So if we do so, it breaks the script semantics.\n            return expr.value.raw;\n        },\n\n        TemplateLiteral: function (expr, precedence, flags) {\n            var result, i, iz;\n            result = [ '`' ];\n            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {\n                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));\n                if (i + 1 < iz) {\n                    result.push('${' + space);\n                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));\n                    result.push(space + '}');\n                }\n            }\n            result.push('`');\n            return result;\n        },\n\n        ModuleSpecifier: function (expr, precedence, flags) {\n            return this.Literal(expr, precedence, flags);\n        },\n\n        ImportExpression: function(expr, precedence, flag) {\n            return parenthesize([\n                'import(',\n                this.generateExpression(expr.source, Precedence.Assignment, E_TTT),\n                ')'\n            ], Precedence.Call, precedence);\n        },\n\n    };\n\n    merge(CodeGenerator.prototype, CodeGenerator.Expression);\n\n    CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {\n        var result, type;\n\n        type = expr.type || Syntax.Property;\n\n        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n            return generateVerbatim(expr, precedence);\n        }\n\n        result = this[type](expr, precedence, flags);\n\n\n        if (extra.comment) {\n            result = addComments(expr, result);\n        }\n        return toSourceNodeWhenNeeded(result, expr);\n    };\n\n    CodeGenerator.prototype.generateStatement = function (stmt, flags) {\n        var result,\n            fragment;\n\n        result = this[stmt.type](stmt, flags);\n\n        // Attach comments\n\n        if (extra.comment) {\n            result = addComments(stmt, result);\n        }\n\n        fragment = toSourceNodeWhenNeeded(result).toString();\n        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\\n') {\n            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\\s+$/, '') : fragment.replace(/\\s+$/, '');\n        }\n\n        return toSourceNodeWhenNeeded(result, stmt);\n    };\n\n    function generateInternal(node) {\n        var codegen;\n\n        codegen = new CodeGenerator();\n        if (isStatement(node)) {\n            return codegen.generateStatement(node, S_TFFF);\n        }\n\n        if (isExpression(node)) {\n            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);\n        }\n\n        throw new Error('Unknown node type: ' + node.type);\n    }\n\n    function generate(node, options) {\n        var defaultOptions = getDefaultOptions(), result, pair;\n\n        if (options != null) {\n            // Obsolete options\n            //\n            //   `options.indent`\n            //   `options.base`\n            //\n            // Instead of them, we can use `option.format.indent`.\n            if (typeof options.indent === 'string') {\n                defaultOptions.format.indent.style = options.indent;\n            }\n            if (typeof options.base === 'number') {\n                defaultOptions.format.indent.base = options.base;\n            }\n            options = updateDeeply(defaultOptions, options);\n            indent = options.format.indent.style;\n            if (typeof options.base === 'string') {\n                base = options.base;\n            } else {\n                base = stringRepeat(indent, options.format.indent.base);\n            }\n        } else {\n            options = defaultOptions;\n            indent = options.format.indent.style;\n            base = stringRepeat(indent, options.format.indent.base);\n        }\n        json = options.format.json;\n        renumber = options.format.renumber;\n        hexadecimal = json ? false : options.format.hexadecimal;\n        quotes = json ? 'double' : options.format.quotes;\n        escapeless = options.format.escapeless;\n        newline = options.format.newline;\n        space = options.format.space;\n        if (options.format.compact) {\n            newline = space = indent = base = '';\n        }\n        parentheses = options.format.parentheses;\n        semicolons = options.format.semicolons;\n        safeConcatenation = options.format.safeConcatenation;\n        directive = options.directive;\n        parse = json ? null : options.parse;\n        sourceMap = options.sourceMap;\n        sourceCode = options.sourceCode;\n        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;\n        extra = options;\n\n        if (sourceMap) {\n            if (!exports.browser) {\n                // We assume environment is node.js\n                // And prevent from including source-map by browserify\n                SourceNode = require('source-map').SourceNode;\n            } else {\n                SourceNode = global.sourceMap.SourceNode;\n            }\n        }\n\n        result = generateInternal(node);\n\n        if (!sourceMap) {\n            pair = {code: result.toString(), map: null};\n            return options.sourceMapWithCode ? pair : pair.code;\n        }\n\n\n        pair = result.toStringWithSourceMap({\n            file: options.file,\n            sourceRoot: options.sourceMapRoot\n        });\n\n        if (options.sourceContent) {\n            pair.map.setSourceContent(options.sourceMap,\n                                      options.sourceContent);\n        }\n\n        if (options.sourceMapWithCode) {\n            return pair;\n        }\n\n        return pair.map.toString();\n    }\n\n    FORMAT_MINIFY = {\n        indent: {\n            style: '',\n            base: 0\n        },\n        renumber: true,\n        hexadecimal: true,\n        quotes: 'auto',\n        escapeless: true,\n        compact: true,\n        parentheses: false,\n        semicolons: false\n    };\n\n    FORMAT_DEFAULTS = getDefaultOptions().format;\n\n    exports.version = require('./package.json').version;\n    exports.generate = generate;\n    exports.attachComments = estraverse.attachComments;\n    exports.Precedence = updateDeeply({}, Precedence);\n    exports.browser = false;\n    exports.FORMAT_MINIFY = FORMAT_MINIFY;\n    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n"]},"metadata":{},"sourceType":"script"}