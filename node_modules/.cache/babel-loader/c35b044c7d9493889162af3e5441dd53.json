{"ast":null,"code":"\"use strict\";\n/**\n * btoa() as defined by the HTML and Infra specs, which mostly just references\n * RFC 4648.\n */\n\nfunction btoa(s) {\n  let i; // String conversion as required by Web IDL.\n\n  s = `${s}`; // \"The btoa() method must throw an \"InvalidCharacterError\" DOMException if\n  // data contains any character whose code point is greater than U+00FF.\"\n\n  for (i = 0; i < s.length; i++) {\n    if (s.charCodeAt(i) > 255) {\n      return null;\n    }\n  }\n\n  let out = \"\";\n\n  for (i = 0; i < s.length; i += 3) {\n    const groupsOfSix = [undefined, undefined, undefined, undefined];\n    groupsOfSix[0] = s.charCodeAt(i) >> 2;\n    groupsOfSix[1] = (s.charCodeAt(i) & 0x03) << 4;\n\n    if (s.length > i + 1) {\n      groupsOfSix[1] |= s.charCodeAt(i + 1) >> 4;\n      groupsOfSix[2] = (s.charCodeAt(i + 1) & 0x0f) << 2;\n    }\n\n    if (s.length > i + 2) {\n      groupsOfSix[2] |= s.charCodeAt(i + 2) >> 6;\n      groupsOfSix[3] = s.charCodeAt(i + 2) & 0x3f;\n    }\n\n    for (let j = 0; j < groupsOfSix.length; j++) {\n      if (typeof groupsOfSix[j] === \"undefined\") {\n        out += \"=\";\n      } else {\n        out += btoaLookup(groupsOfSix[j]);\n      }\n    }\n  }\n\n  return out;\n}\n/**\n * Lookup table for btoa(), which converts a six-bit number into the\n * corresponding ASCII character.\n */\n\n\nconst keystr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nfunction btoaLookup(index) {\n  if (index >= 0 && index < 64) {\n    return keystr[index];\n  } // Throw INVALID_CHARACTER_ERR exception here -- won't be hit in the tests.\n\n\n  return undefined;\n}\n\nmodule.exports = btoa;","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/abab/lib/btoa.js"],"names":["btoa","s","i","length","charCodeAt","out","groupsOfSix","undefined","j","btoaLookup","keystr","index","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;;AACA,SAASA,IAAT,CAAcC,CAAd,EAAiB;AACf,MAAIC,CAAJ,CADe,CAEf;;AACAD,EAAAA,CAAC,GAAI,GAAEA,CAAE,EAAT,CAHe,CAIf;AACA;;AACA,OAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,CAAC,CAACE,MAAlB,EAA0BD,CAAC,EAA3B,EAA+B;AAC7B,QAAID,CAAC,CAACG,UAAF,CAAaF,CAAb,IAAkB,GAAtB,EAA2B;AACzB,aAAO,IAAP;AACD;AACF;;AACD,MAAIG,GAAG,GAAG,EAAV;;AACA,OAAKH,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,CAAC,CAACE,MAAlB,EAA0BD,CAAC,IAAI,CAA/B,EAAkC;AAChC,UAAMI,WAAW,GAAG,CAACC,SAAD,EAAYA,SAAZ,EAAuBA,SAAvB,EAAkCA,SAAlC,CAApB;AACAD,IAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBL,CAAC,CAACG,UAAF,CAAaF,CAAb,KAAmB,CAApC;AACAI,IAAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,CAACL,CAAC,CAACG,UAAF,CAAaF,CAAb,IAAkB,IAAnB,KAA4B,CAA7C;;AACA,QAAID,CAAC,CAACE,MAAF,GAAWD,CAAC,GAAG,CAAnB,EAAsB;AACpBI,MAAAA,WAAW,CAAC,CAAD,CAAX,IAAkBL,CAAC,CAACG,UAAF,CAAaF,CAAC,GAAG,CAAjB,KAAuB,CAAzC;AACAI,MAAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,CAACL,CAAC,CAACG,UAAF,CAAaF,CAAC,GAAG,CAAjB,IAAsB,IAAvB,KAAgC,CAAjD;AACD;;AACD,QAAID,CAAC,CAACE,MAAF,GAAWD,CAAC,GAAG,CAAnB,EAAsB;AACpBI,MAAAA,WAAW,CAAC,CAAD,CAAX,IAAkBL,CAAC,CAACG,UAAF,CAAaF,CAAC,GAAG,CAAjB,KAAuB,CAAzC;AACAI,MAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBL,CAAC,CAACG,UAAF,CAAaF,CAAC,GAAG,CAAjB,IAAsB,IAAvC;AACD;;AACD,SAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,WAAW,CAACH,MAAhC,EAAwCK,CAAC,EAAzC,EAA6C;AAC3C,UAAI,OAAOF,WAAW,CAACE,CAAD,CAAlB,KAA0B,WAA9B,EAA2C;AACzCH,QAAAA,GAAG,IAAI,GAAP;AACD,OAFD,MAEO;AACLA,QAAAA,GAAG,IAAII,UAAU,CAACH,WAAW,CAACE,CAAD,CAAZ,CAAjB;AACD;AACF;AACF;;AACD,SAAOH,GAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,MAAMK,MAAM,GACV,kEADF;;AAGA,SAASD,UAAT,CAAoBE,KAApB,EAA2B;AACzB,MAAIA,KAAK,IAAI,CAAT,IAAcA,KAAK,GAAG,EAA1B,EAA8B;AAC5B,WAAOD,MAAM,CAACC,KAAD,CAAb;AACD,GAHwB,CAKzB;;;AACA,SAAOJ,SAAP;AACD;;AAEDK,MAAM,CAACC,OAAP,GAAiBb,IAAjB","sourcesContent":["\"use strict\";\n\n/**\n * btoa() as defined by the HTML and Infra specs, which mostly just references\n * RFC 4648.\n */\nfunction btoa(s) {\n  let i;\n  // String conversion as required by Web IDL.\n  s = `${s}`;\n  // \"The btoa() method must throw an \"InvalidCharacterError\" DOMException if\n  // data contains any character whose code point is greater than U+00FF.\"\n  for (i = 0; i < s.length; i++) {\n    if (s.charCodeAt(i) > 255) {\n      return null;\n    }\n  }\n  let out = \"\";\n  for (i = 0; i < s.length; i += 3) {\n    const groupsOfSix = [undefined, undefined, undefined, undefined];\n    groupsOfSix[0] = s.charCodeAt(i) >> 2;\n    groupsOfSix[1] = (s.charCodeAt(i) & 0x03) << 4;\n    if (s.length > i + 1) {\n      groupsOfSix[1] |= s.charCodeAt(i + 1) >> 4;\n      groupsOfSix[2] = (s.charCodeAt(i + 1) & 0x0f) << 2;\n    }\n    if (s.length > i + 2) {\n      groupsOfSix[2] |= s.charCodeAt(i + 2) >> 6;\n      groupsOfSix[3] = s.charCodeAt(i + 2) & 0x3f;\n    }\n    for (let j = 0; j < groupsOfSix.length; j++) {\n      if (typeof groupsOfSix[j] === \"undefined\") {\n        out += \"=\";\n      } else {\n        out += btoaLookup(groupsOfSix[j]);\n      }\n    }\n  }\n  return out;\n}\n\n/**\n * Lookup table for btoa(), which converts a six-bit number into the\n * corresponding ASCII character.\n */\nconst keystr =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nfunction btoaLookup(index) {\n  if (index >= 0 && index < 64) {\n    return keystr[index];\n  }\n\n  // Throw INVALID_CHARACTER_ERR exception here -- won't be hit in the tests.\n  return undefined;\n}\n\nmodule.exports = btoa;\n"]},"metadata":{},"sourceType":"script"}