{"ast":null,"code":"\"use strict\";\n\nconst {\n  SaxesParser\n} = require(\"saxes\");\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst {\n  createElement\n} = require(\"../../living/helpers/create-element\");\n\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\n\nconst DocumentType = require(\"../../living/generated/DocumentType\");\n\nconst CDATASection = require(\"../../living/generated/CDATASection\");\n\nconst Comment = require(\"../../living/generated/Comment\");\n\nconst ProcessingInstruction = require(\"../../living/generated/ProcessingInstruction\");\n\nconst Text = require(\"../../living/generated/Text\");\n\nconst attributes = require(\"../../living/attributes\");\n\nconst {\n  HTML_NS\n} = require(\"../../living/helpers/namespaces\");\n\nconst HTML5_DOCTYPE = /<!doctype html>/i;\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\nconst CUSTOM_NAME_DOCTYPE = /<!doctype\\s+([^\\s>]+)/i;\n\nfunction parseDocType(globalObject, ownerDocument, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentType(globalObject, ownerDocument, \"html\", \"\", \"\");\n  }\n\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\n\n  if (publicPieces) {\n    return createDocumentType(globalObject, ownerDocument, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\n\n  if (systemPieces) {\n    return createDocumentType(globalObject, ownerDocument, systemPieces[1], \"\", systemPieces[2]);\n  }\n\n  const namePiece = CUSTOM_NAME_DOCTYPE.exec(html)[1] || \"html\";\n  return createDocumentType(globalObject, ownerDocument, namePiece, \"\", \"\");\n}\n\nfunction createDocumentType(globalObject, ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl(globalObject, [], {\n    ownerDocument,\n    name,\n    publicId,\n    systemId\n  });\n}\n\nfunction isHTMLTemplateElement(element) {\n  return element.tagName === \"template\" && element.namespaceURI === HTML_NS;\n}\n\nfunction createParser(rootNode, globalObject, saxesOptions) {\n  const parser = new SaxesParser({ ...saxesOptions,\n    // Browsers always have namespace support.\n    xmlns: true,\n    // We force the parser to treat all documents (even documents declaring themselves to be XML 1.1 documents) as XML\n    // 1.0 documents. See https://github.com/jsdom/jsdom/issues/2677 for a discussion of the stakes.\n    defaultXMLVersion: \"1.0\",\n    forceXMLVersion: true\n  });\n  const openStack = [rootNode];\n\n  function getOwnerDocument() {\n    const currentElement = openStack[openStack.length - 1];\n    return isHTMLTemplateElement(currentElement) ? currentElement._templateContents._ownerDocument : currentElement._ownerDocument;\n  }\n\n  function appendChild(child) {\n    const parentElement = openStack[openStack.length - 1];\n\n    if (isHTMLTemplateElement(parentElement)) {\n      parentElement._templateContents._insert(child, null);\n    } else {\n      parentElement._insert(child, null);\n    }\n  }\n\n  parser.on(\"text\", saxesOptions.fragment ? // In a fragment, all text events produced by saxes must result in a text\n  // node.\n  data => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(Text.createImpl(globalObject, [], {\n      data,\n      ownerDocument\n    }));\n  } : // When parsing a whole document, we must ignore those text nodes that are\n  // produced outside the root element. Saxes produces events for them,\n  // but DOM trees do not record text outside the root element.\n  data => {\n    if (openStack.length > 1) {\n      const ownerDocument = getOwnerDocument();\n      appendChild(Text.createImpl(globalObject, [], {\n        data,\n        ownerDocument\n      }));\n    }\n  });\n  parser.on(\"cdata\", data => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(CDATASection.createImpl(globalObject, [], {\n      data,\n      ownerDocument\n    }));\n  });\n  parser.on(\"opentag\", tag => {\n    const {\n      local: tagLocal,\n      attributes: tagAttributes\n    } = tag;\n    const ownerDocument = getOwnerDocument();\n    const tagNamespace = tag.uri === \"\" ? null : tag.uri;\n    const tagPrefix = tag.prefix === \"\" ? null : tag.prefix;\n    const isValue = tagAttributes.is === undefined ? null : tagAttributes.is.value;\n    const elem = createElement(ownerDocument, tagLocal, tagNamespace, tagPrefix, isValue, true); // We mark a script element as \"parser-inserted\", which prevents it from\n    // being immediately executed.\n\n    if (tagLocal === \"script\" && tagNamespace === HTML_NS) {\n      elem._parserInserted = true;\n    }\n\n    for (const key of Object.keys(tagAttributes)) {\n      const {\n        prefix,\n        local,\n        uri,\n        value\n      } = tagAttributes[key];\n      attributes.setAttributeValue(elem, local, value, prefix === \"\" ? null : prefix, uri === \"\" ? null : uri);\n    }\n\n    appendChild(elem);\n    openStack.push(elem);\n  });\n  parser.on(\"closetag\", () => {\n    const elem = openStack.pop(); // Once a script is populated, we can execute it.\n\n    if (elem.localName === \"script\" && elem.namespaceURI === HTML_NS) {\n      elem._eval();\n    }\n  });\n  parser.on(\"comment\", data => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(Comment.createImpl(globalObject, [], {\n      data,\n      ownerDocument\n    }));\n  });\n  parser.on(\"processinginstruction\", ({\n    target,\n    body\n  }) => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(ProcessingInstruction.createImpl(globalObject, [], {\n      target,\n      data: body,\n      ownerDocument\n    }));\n  });\n  parser.on(\"doctype\", dt => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(parseDocType(globalObject, ownerDocument, `<!doctype ${dt}>`));\n    const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n    let result;\n\n    while (result = entityMatcher.exec(dt)) {\n      const [, name, value] = result;\n\n      if (!(name in parser.ENTITIES)) {\n        parser.ENTITIES[name] = value;\n      }\n    }\n  });\n  parser.on(\"error\", err => {\n    throw DOMException.create(globalObject, [err.message, \"SyntaxError\"]);\n  });\n  return parser;\n}\n\nfunction parseFragment(markup, contextElement) {\n  const {\n    _globalObject,\n    _ownerDocument\n  } = contextElement;\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: _ownerDocument\n  }); // Only parseFragment needs resolvePrefix per the saxes documentation:\n  // https://github.com/lddubeau/saxes#parsing-xml-fragments\n\n  const parser = createParser(fragment, _globalObject, {\n    fragment: true,\n\n    resolvePrefix(prefix) {\n      // saxes wants undefined as the return value if the prefix is not defined, not null.\n      return contextElement.lookupNamespaceURI(prefix) || undefined;\n    }\n\n  });\n  parser.write(markup).close();\n  return fragment;\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  const {\n    _globalObject\n  } = ownerDocument;\n  const parser = createParser(ownerDocument, _globalObject, {\n    fileName: ownerDocument.location && ownerDocument.location.href\n  });\n  parser.write(markup).close();\n  return ownerDocument;\n}\n\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/jsdom/lib/jsdom/browser/parser/xml.js"],"names":["SaxesParser","require","DOMException","createElement","DocumentFragment","DocumentType","CDATASection","Comment","ProcessingInstruction","Text","attributes","HTML_NS","HTML5_DOCTYPE","PUBLIC_DOCTYPE","SYSTEM_DOCTYPE","CUSTOM_NAME_DOCTYPE","parseDocType","globalObject","ownerDocument","html","test","createDocumentType","publicPieces","exec","systemPieces","namePiece","name","publicId","systemId","createImpl","isHTMLTemplateElement","element","tagName","namespaceURI","createParser","rootNode","saxesOptions","parser","xmlns","defaultXMLVersion","forceXMLVersion","openStack","getOwnerDocument","currentElement","length","_templateContents","_ownerDocument","appendChild","child","parentElement","_insert","on","fragment","data","tag","local","tagLocal","tagAttributes","tagNamespace","uri","tagPrefix","prefix","isValue","is","undefined","value","elem","_parserInserted","key","Object","keys","setAttributeValue","push","pop","localName","_eval","target","body","dt","entityMatcher","result","ENTITIES","err","create","message","parseFragment","markup","contextElement","_globalObject","resolvePrefix","lookupNamespaceURI","write","close","parseIntoDocument","fileName","location","href","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst { SaxesParser } = require(\"saxes\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst { createElement } = require(\"../../living/helpers/create-element\");\n\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\nconst DocumentType = require(\"../../living/generated/DocumentType\");\nconst CDATASection = require(\"../../living/generated/CDATASection\");\nconst Comment = require(\"../../living/generated/Comment\");\nconst ProcessingInstruction = require(\"../../living/generated/ProcessingInstruction\");\nconst Text = require(\"../../living/generated/Text\");\n\nconst attributes = require(\"../../living/attributes\");\nconst { HTML_NS } = require(\"../../living/helpers/namespaces\");\n\nconst HTML5_DOCTYPE = /<!doctype html>/i;\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\nconst CUSTOM_NAME_DOCTYPE = /<!doctype\\s+([^\\s>]+)/i;\n\nfunction parseDocType(globalObject, ownerDocument, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentType(globalObject, ownerDocument, \"html\", \"\", \"\");\n  }\n\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\n  if (publicPieces) {\n    return createDocumentType(globalObject, ownerDocument, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\n  if (systemPieces) {\n    return createDocumentType(globalObject, ownerDocument, systemPieces[1], \"\", systemPieces[2]);\n  }\n\n  const namePiece = CUSTOM_NAME_DOCTYPE.exec(html)[1] || \"html\";\n  return createDocumentType(globalObject, ownerDocument, namePiece, \"\", \"\");\n}\n\nfunction createDocumentType(globalObject, ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl(globalObject, [], { ownerDocument, name, publicId, systemId });\n}\n\nfunction isHTMLTemplateElement(element) {\n  return element.tagName === \"template\" && element.namespaceURI === HTML_NS;\n}\n\n\nfunction createParser(rootNode, globalObject, saxesOptions) {\n  const parser = new SaxesParser({\n    ...saxesOptions,\n    // Browsers always have namespace support.\n    xmlns: true,\n    // We force the parser to treat all documents (even documents declaring themselves to be XML 1.1 documents) as XML\n    // 1.0 documents. See https://github.com/jsdom/jsdom/issues/2677 for a discussion of the stakes.\n    defaultXMLVersion: \"1.0\",\n    forceXMLVersion: true\n  });\n  const openStack = [rootNode];\n\n  function getOwnerDocument() {\n    const currentElement = openStack[openStack.length - 1];\n\n    return isHTMLTemplateElement(currentElement) ?\n      currentElement._templateContents._ownerDocument :\n      currentElement._ownerDocument;\n  }\n\n  function appendChild(child) {\n    const parentElement = openStack[openStack.length - 1];\n\n    if (isHTMLTemplateElement(parentElement)) {\n      parentElement._templateContents._insert(child, null);\n    } else {\n      parentElement._insert(child, null);\n    }\n  }\n\n  parser.on(\"text\", saxesOptions.fragment ?\n    // In a fragment, all text events produced by saxes must result in a text\n    // node.\n    data => {\n      const ownerDocument = getOwnerDocument();\n      appendChild(Text.createImpl(globalObject, [], { data, ownerDocument }));\n    } :\n    // When parsing a whole document, we must ignore those text nodes that are\n    // produced outside the root element. Saxes produces events for them,\n    // but DOM trees do not record text outside the root element.\n    data => {\n      if (openStack.length > 1) {\n        const ownerDocument = getOwnerDocument();\n        appendChild(Text.createImpl(globalObject, [], { data, ownerDocument }));\n      }\n    });\n\n  parser.on(\"cdata\", data => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(CDATASection.createImpl(globalObject, [], { data, ownerDocument }));\n  });\n\n  parser.on(\"opentag\", tag => {\n    const { local: tagLocal, attributes: tagAttributes } = tag;\n\n    const ownerDocument = getOwnerDocument();\n    const tagNamespace = tag.uri === \"\" ? null : tag.uri;\n    const tagPrefix = tag.prefix === \"\" ? null : tag.prefix;\n    const isValue = tagAttributes.is === undefined ? null : tagAttributes.is.value;\n\n    const elem = createElement(ownerDocument, tagLocal, tagNamespace, tagPrefix, isValue, true);\n\n    // We mark a script element as \"parser-inserted\", which prevents it from\n    // being immediately executed.\n    if (tagLocal === \"script\" && tagNamespace === HTML_NS) {\n      elem._parserInserted = true;\n    }\n\n    for (const key of Object.keys(tagAttributes)) {\n      const { prefix, local, uri, value } = tagAttributes[key];\n      attributes.setAttributeValue(\n        elem, local, value, prefix === \"\" ? null : prefix,\n        uri === \"\" ? null : uri\n      );\n    }\n\n    appendChild(elem);\n    openStack.push(elem);\n  });\n\n  parser.on(\"closetag\", () => {\n    const elem = openStack.pop();\n    // Once a script is populated, we can execute it.\n    if (elem.localName === \"script\" && elem.namespaceURI === HTML_NS) {\n      elem._eval();\n    }\n  });\n\n  parser.on(\"comment\", data => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(Comment.createImpl(globalObject, [], { data, ownerDocument }));\n  });\n\n  parser.on(\"processinginstruction\", ({ target, body }) => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(ProcessingInstruction.createImpl(globalObject, [], { target, data: body, ownerDocument }));\n  });\n\n  parser.on(\"doctype\", dt => {\n    const ownerDocument = getOwnerDocument();\n    appendChild(parseDocType(globalObject, ownerDocument, `<!doctype ${dt}>`));\n\n    const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n    let result;\n    while ((result = entityMatcher.exec(dt))) {\n      const [, name, value] = result;\n      if (!(name in parser.ENTITIES)) {\n        parser.ENTITIES[name] = value;\n      }\n    }\n  });\n\n  parser.on(\"error\", err => {\n    throw DOMException.create(globalObject, [err.message, \"SyntaxError\"]);\n  });\n\n  return parser;\n}\n\nfunction parseFragment(markup, contextElement) {\n  const { _globalObject, _ownerDocument } = contextElement;\n\n  const fragment = DocumentFragment.createImpl(_globalObject, [], { ownerDocument: _ownerDocument });\n\n  // Only parseFragment needs resolvePrefix per the saxes documentation:\n  // https://github.com/lddubeau/saxes#parsing-xml-fragments\n  const parser = createParser(fragment, _globalObject, {\n    fragment: true,\n    resolvePrefix(prefix) {\n      // saxes wants undefined as the return value if the prefix is not defined, not null.\n      return contextElement.lookupNamespaceURI(prefix) || undefined;\n    }\n  });\n\n  parser.write(markup).close();\n\n  return fragment;\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  const { _globalObject } = ownerDocument;\n\n  const parser = createParser(ownerDocument, _globalObject, {\n    fileName: ownerDocument.location && ownerDocument.location.href\n  });\n\n  parser.write(markup).close();\n\n  return ownerDocument;\n}\n\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};\n"]},"metadata":{},"sourceType":"script"}