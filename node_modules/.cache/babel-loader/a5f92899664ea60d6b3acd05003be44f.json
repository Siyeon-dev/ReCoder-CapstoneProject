{"ast":null,"code":"\"use strict\";\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst {\n  nodeRoot\n} = require(\"./node\");\n\nconst {\n  HTML_NS\n} = require(\"./namespaces\");\n\nconst {\n  domSymbolTree\n} = require(\"./internal-constants\");\n\nconst {\n  signalSlotList,\n  queueMutationObserverMicrotask\n} = require(\"./mutation-observers\"); // Valid host element for ShadowRoot.\n// Defined in: https://dom.spec.whatwg.org/#dom-element-attachshadow\n\n\nconst VALID_HOST_ELEMENT_NAME = new Set([\"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\"]);\n\nfunction isValidHostElementName(name) {\n  return VALID_HOST_ELEMENT_NAME.has(name);\n} // Use an approximation by checking the presence of nodeType instead of instead of using the isImpl from\n// \"../generated/Node\" to avoid introduction of circular dependencies.\n\n\nfunction isNode(nodeImpl) {\n  return Boolean(nodeImpl && \"nodeType\" in nodeImpl);\n} // Use an approximation by checking the value of nodeType and presence of nodeType host instead of instead\n// of using the isImpl from \"../generated/ShadowRoot\" to avoid introduction of circular dependencies.\n\n\nfunction isShadowRoot(nodeImpl) {\n  return Boolean(nodeImpl && nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE && \"host\" in nodeImpl);\n} // https://dom.spec.whatwg.org/#concept-slotable\n\n\nfunction isSlotable(nodeImpl) {\n  return nodeImpl && (nodeImpl.nodeType === NODE_TYPE.ELEMENT_NODE || nodeImpl.nodeType === NODE_TYPE.TEXT_NODE);\n}\n\nfunction isSlot(nodeImpl) {\n  return nodeImpl && nodeImpl.localName === \"slot\" && nodeImpl._namespaceURI === HTML_NS;\n} // https://dom.spec.whatwg.org/#concept-shadow-including-inclusive-ancestor\n\n\nfunction isShadowInclusiveAncestor(ancestor, node) {\n  while (isNode(node)) {\n    if (node === ancestor) {\n      return true;\n    }\n\n    if (isShadowRoot(node)) {\n      node = node.host;\n    } else {\n      node = domSymbolTree.parent(node);\n    }\n  }\n\n  return false;\n} // https://dom.spec.whatwg.org/#retarget\n\n\nfunction retarget(a, b) {\n  while (true) {\n    if (!isNode(a)) {\n      return a;\n    }\n\n    const aRoot = nodeRoot(a);\n\n    if (!isShadowRoot(aRoot) || isNode(b) && isShadowInclusiveAncestor(aRoot, b)) {\n      return a;\n    }\n\n    a = nodeRoot(a).host;\n  }\n} // https://dom.spec.whatwg.org/#get-the-parent\n\n\nfunction getEventTargetParent(eventTarget, event) {\n  // _getTheParent will be missing for Window, since it doesn't have an impl class and we don't want to pollute the\n  // user-visible global scope with a _getTheParent value. TODO: remove this entire function and use _getTheParent\n  // directly, once Window gets split into impl/wrapper.\n  return eventTarget._getTheParent ? eventTarget._getTheParent(event) : null;\n} // https://dom.spec.whatwg.org/#concept-shadow-including-root\n\n\nfunction shadowIncludingRoot(node) {\n  const root = nodeRoot(node);\n  return isShadowRoot(root) ? shadowIncludingRoot(root.host) : root;\n} // https://dom.spec.whatwg.org/#assign-a-slot\n\n\nfunction assignSlot(slotable) {\n  const slot = findSlot(slotable);\n\n  if (slot) {\n    assignSlotable(slot);\n  }\n} // https://dom.spec.whatwg.org/#assign-slotables\n\n\nfunction assignSlotable(slot) {\n  const slotables = findSlotable(slot);\n  let shouldFireSlotChange = false;\n\n  if (slotables.length !== slot._assignedNodes.length) {\n    shouldFireSlotChange = true;\n  } else {\n    for (let i = 0; i < slotables.length; i++) {\n      if (slotables[i] !== slot._assignedNodes[i]) {\n        shouldFireSlotChange = true;\n        break;\n      }\n    }\n  }\n\n  if (shouldFireSlotChange) {\n    signalSlotChange(slot);\n  }\n\n  slot._assignedNodes = slotables;\n\n  for (const slotable of slotables) {\n    slotable._assignedSlot = slot;\n  }\n} // https://dom.spec.whatwg.org/#assign-slotables-for-a-tree\n\n\nfunction assignSlotableForTree(root) {\n  for (const slot of domSymbolTree.treeIterator(root)) {\n    if (isSlot(slot)) {\n      assignSlotable(slot);\n    }\n  }\n} // https://dom.spec.whatwg.org/#find-slotables\n\n\nfunction findSlotable(slot) {\n  const result = [];\n  const root = nodeRoot(slot);\n\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  for (const slotable of domSymbolTree.treeIterator(root.host)) {\n    const foundSlot = findSlot(slotable);\n\n    if (foundSlot === slot) {\n      result.push(slotable);\n    }\n  }\n\n  return result;\n} // https://dom.spec.whatwg.org/#find-flattened-slotables\n\n\nfunction findFlattenedSlotables(slot) {\n  const result = [];\n  const root = nodeRoot(slot);\n\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  const slotables = findSlotable(slot);\n\n  if (slotables.length === 0) {\n    for (const child of domSymbolTree.childrenIterator(slot)) {\n      if (isSlotable(child)) {\n        slotables.push(child);\n      }\n    }\n  }\n\n  for (const node of slotables) {\n    if (isSlot(node) && isShadowRoot(nodeRoot(node))) {\n      const temporaryResult = findFlattenedSlotables(node);\n      result.push(...temporaryResult);\n    } else {\n      result.push(node);\n    }\n  }\n\n  return result;\n} // https://dom.spec.whatwg.org/#find-a-slot\n\n\nfunction findSlot(slotable, openFlag) {\n  const {\n    parentNode: parent\n  } = slotable;\n\n  if (!parent) {\n    return null;\n  }\n\n  const shadow = parent._shadowRoot;\n\n  if (!shadow || openFlag && shadow.mode !== \"open\") {\n    return null;\n  }\n\n  for (const child of domSymbolTree.treeIterator(shadow)) {\n    if (isSlot(child) && child.name === slotable._slotableName) {\n      return child;\n    }\n  }\n\n  return null;\n} // https://dom.spec.whatwg.org/#signal-a-slot-change\n\n\nfunction signalSlotChange(slot) {\n  if (!signalSlotList.some(entry => entry === slot)) {\n    signalSlotList.push(slot);\n  }\n\n  queueMutationObserverMicrotask();\n} // https://dom.spec.whatwg.org/#concept-shadow-including-descendant\n\n\nfunction* shadowIncludingInclusiveDescendantsIterator(node) {\n  yield node;\n\n  if (node._shadowRoot) {\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\n  }\n\n  for (const child of domSymbolTree.childrenIterator(node)) {\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\n  }\n} // https://dom.spec.whatwg.org/#concept-shadow-including-descendant\n\n\nfunction* shadowIncludingDescendantsIterator(node) {\n  if (node._shadowRoot) {\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\n  }\n\n  for (const child of domSymbolTree.childrenIterator(node)) {\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\n  }\n}\n\nmodule.exports = {\n  isValidHostElementName,\n  isNode,\n  isSlotable,\n  isSlot,\n  isShadowRoot,\n  isShadowInclusiveAncestor,\n  retarget,\n  getEventTargetParent,\n  shadowIncludingRoot,\n  assignSlot,\n  assignSlotable,\n  assignSlotableForTree,\n  findSlot,\n  findFlattenedSlotables,\n  signalSlotChange,\n  shadowIncludingInclusiveDescendantsIterator,\n  shadowIncludingDescendantsIterator\n};","map":{"version":3,"sources":["/Library/WebServer/Documents/capstone/capstone-project-re-coder/node_modules/jsdom/lib/jsdom/living/helpers/shadow-dom.js"],"names":["NODE_TYPE","require","nodeRoot","HTML_NS","domSymbolTree","signalSlotList","queueMutationObserverMicrotask","VALID_HOST_ELEMENT_NAME","Set","isValidHostElementName","name","has","isNode","nodeImpl","Boolean","isShadowRoot","nodeType","DOCUMENT_FRAGMENT_NODE","isSlotable","ELEMENT_NODE","TEXT_NODE","isSlot","localName","_namespaceURI","isShadowInclusiveAncestor","ancestor","node","host","parent","retarget","a","b","aRoot","getEventTargetParent","eventTarget","event","_getTheParent","shadowIncludingRoot","root","assignSlot","slotable","slot","findSlot","assignSlotable","slotables","findSlotable","shouldFireSlotChange","length","_assignedNodes","i","signalSlotChange","_assignedSlot","assignSlotableForTree","treeIterator","result","foundSlot","push","findFlattenedSlotables","child","childrenIterator","temporaryResult","openFlag","parentNode","shadow","_shadowRoot","mode","_slotableName","some","entry","shadowIncludingInclusiveDescendantsIterator","shadowIncludingDescendantsIterator","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst { nodeRoot } = require(\"./node\");\nconst { HTML_NS } = require(\"./namespaces\");\nconst { domSymbolTree } = require(\"./internal-constants\");\nconst { signalSlotList, queueMutationObserverMicrotask } = require(\"./mutation-observers\");\n\n// Valid host element for ShadowRoot.\n// Defined in: https://dom.spec.whatwg.org/#dom-element-attachshadow\nconst VALID_HOST_ELEMENT_NAME = new Set([\n  \"article\",\n  \"aside\",\n  \"blockquote\",\n  \"body\",\n  \"div\",\n  \"footer\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"header\",\n  \"main\",\n  \"nav\",\n  \"p\",\n  \"section\",\n  \"span\"\n]);\n\nfunction isValidHostElementName(name) {\n  return VALID_HOST_ELEMENT_NAME.has(name);\n}\n\n// Use an approximation by checking the presence of nodeType instead of instead of using the isImpl from\n// \"../generated/Node\" to avoid introduction of circular dependencies.\nfunction isNode(nodeImpl) {\n  return Boolean(nodeImpl && \"nodeType\" in nodeImpl);\n}\n\n// Use an approximation by checking the value of nodeType and presence of nodeType host instead of instead\n// of using the isImpl from \"../generated/ShadowRoot\" to avoid introduction of circular dependencies.\nfunction isShadowRoot(nodeImpl) {\n  return Boolean(nodeImpl && nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE && \"host\" in nodeImpl);\n}\n\n// https://dom.spec.whatwg.org/#concept-slotable\nfunction isSlotable(nodeImpl) {\n  return nodeImpl && (nodeImpl.nodeType === NODE_TYPE.ELEMENT_NODE || nodeImpl.nodeType === NODE_TYPE.TEXT_NODE);\n}\n\nfunction isSlot(nodeImpl) {\n  return nodeImpl && nodeImpl.localName === \"slot\" && nodeImpl._namespaceURI === HTML_NS;\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-inclusive-ancestor\nfunction isShadowInclusiveAncestor(ancestor, node) {\n  while (isNode(node)) {\n    if (node === ancestor) {\n      return true;\n    }\n\n    if (isShadowRoot(node)) {\n      node = node.host;\n    } else {\n      node = domSymbolTree.parent(node);\n    }\n  }\n\n  return false;\n}\n\n// https://dom.spec.whatwg.org/#retarget\nfunction retarget(a, b) {\n  while (true) {\n    if (!isNode(a)) {\n      return a;\n    }\n\n    const aRoot = nodeRoot(a);\n    if (\n      !isShadowRoot(aRoot) ||\n      (isNode(b) && isShadowInclusiveAncestor(aRoot, b))\n    ) {\n      return a;\n    }\n\n    a = nodeRoot(a).host;\n  }\n}\n\n// https://dom.spec.whatwg.org/#get-the-parent\nfunction getEventTargetParent(eventTarget, event) {\n  // _getTheParent will be missing for Window, since it doesn't have an impl class and we don't want to pollute the\n  // user-visible global scope with a _getTheParent value. TODO: remove this entire function and use _getTheParent\n  // directly, once Window gets split into impl/wrapper.\n  return eventTarget._getTheParent ? eventTarget._getTheParent(event) : null;\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-root\nfunction shadowIncludingRoot(node) {\n  const root = nodeRoot(node);\n  return isShadowRoot(root) ? shadowIncludingRoot(root.host) : root;\n}\n\n// https://dom.spec.whatwg.org/#assign-a-slot\nfunction assignSlot(slotable) {\n  const slot = findSlot(slotable);\n\n  if (slot) {\n    assignSlotable(slot);\n  }\n}\n\n// https://dom.spec.whatwg.org/#assign-slotables\nfunction assignSlotable(slot) {\n  const slotables = findSlotable(slot);\n\n  let shouldFireSlotChange = false;\n\n  if (slotables.length !== slot._assignedNodes.length) {\n    shouldFireSlotChange = true;\n  } else {\n    for (let i = 0; i < slotables.length; i++) {\n      if (slotables[i] !== slot._assignedNodes[i]) {\n        shouldFireSlotChange = true;\n        break;\n      }\n    }\n  }\n\n  if (shouldFireSlotChange) {\n    signalSlotChange(slot);\n  }\n\n  slot._assignedNodes = slotables;\n\n  for (const slotable of slotables) {\n    slotable._assignedSlot = slot;\n  }\n}\n\n// https://dom.spec.whatwg.org/#assign-slotables-for-a-tree\nfunction assignSlotableForTree(root) {\n  for (const slot of domSymbolTree.treeIterator(root)) {\n    if (isSlot(slot)) {\n      assignSlotable(slot);\n    }\n  }\n}\n\n// https://dom.spec.whatwg.org/#find-slotables\nfunction findSlotable(slot) {\n  const result = [];\n\n  const root = nodeRoot(slot);\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  for (const slotable of domSymbolTree.treeIterator(root.host)) {\n    const foundSlot = findSlot(slotable);\n\n    if (foundSlot === slot) {\n      result.push(slotable);\n    }\n  }\n\n  return result;\n}\n\n// https://dom.spec.whatwg.org/#find-flattened-slotables\nfunction findFlattenedSlotables(slot) {\n  const result = [];\n\n  const root = nodeRoot(slot);\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  const slotables = findSlotable(slot);\n\n  if (slotables.length === 0) {\n    for (const child of domSymbolTree.childrenIterator(slot)) {\n      if (isSlotable(child)) {\n        slotables.push(child);\n      }\n    }\n  }\n\n  for (const node of slotables) {\n    if (isSlot(node) && isShadowRoot(nodeRoot(node))) {\n      const temporaryResult = findFlattenedSlotables(node);\n      result.push(...temporaryResult);\n    } else {\n      result.push(node);\n    }\n  }\n\n  return result;\n}\n\n// https://dom.spec.whatwg.org/#find-a-slot\nfunction findSlot(slotable, openFlag) {\n  const { parentNode: parent } = slotable;\n\n  if (!parent) {\n    return null;\n  }\n\n  const shadow = parent._shadowRoot;\n\n  if (!shadow || (openFlag && shadow.mode !== \"open\")) {\n    return null;\n  }\n\n  for (const child of domSymbolTree.treeIterator(shadow)) {\n    if (isSlot(child) && child.name === slotable._slotableName) {\n      return child;\n    }\n  }\n\n  return null;\n}\n\n// https://dom.spec.whatwg.org/#signal-a-slot-change\nfunction signalSlotChange(slot) {\n  if (!signalSlotList.some(entry => entry === slot)) {\n    signalSlotList.push(slot);\n  }\n\n  queueMutationObserverMicrotask();\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-descendant\nfunction* shadowIncludingInclusiveDescendantsIterator(node) {\n  yield node;\n\n  if (node._shadowRoot) {\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\n  }\n\n  for (const child of domSymbolTree.childrenIterator(node)) {\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\n  }\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-descendant\nfunction* shadowIncludingDescendantsIterator(node) {\n  if (node._shadowRoot) {\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\n  }\n\n  for (const child of domSymbolTree.childrenIterator(node)) {\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\n  }\n}\n\nmodule.exports = {\n  isValidHostElementName,\n\n  isNode,\n  isSlotable,\n  isSlot,\n  isShadowRoot,\n\n  isShadowInclusiveAncestor,\n  retarget,\n  getEventTargetParent,\n  shadowIncludingRoot,\n\n  assignSlot,\n  assignSlotable,\n  assignSlotableForTree,\n\n  findSlot,\n  findFlattenedSlotables,\n\n  signalSlotChange,\n\n  shadowIncludingInclusiveDescendantsIterator,\n  shadowIncludingDescendantsIterator\n};\n"]},"metadata":{},"sourceType":"script"}